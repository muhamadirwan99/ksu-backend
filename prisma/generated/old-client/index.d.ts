
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model anggota
 * 
 */
export type anggota = $Result.DefaultSelection<Prisma.$anggotaPayload>
/**
 * Model anggota_kredit
 * 
 */
export type anggota_kredit = $Result.DefaultSelection<Prisma.$anggota_kreditPayload>
/**
 * Model bagian
 * 
 */
export type bagian = $Result.DefaultSelection<Prisma.$bagianPayload>
/**
 * Model bank
 * 
 */
export type bank = $Result.DefaultSelection<Prisma.$bankPayload>
/**
 * Model bank_mutasi
 * 
 */
export type bank_mutasi = $Result.DefaultSelection<Prisma.$bank_mutasiPayload>
/**
 * Model bayar
 * 
 */
export type bayar = $Result.DefaultSelection<Prisma.$bayarPayload>
/**
 * Model beban_operasional
 * 
 */
export type beban_operasional = $Result.DefaultSelection<Prisma.$beban_operasionalPayload>
/**
 * Model cash_in_out
 * 
 */
export type cash_in_out = $Result.DefaultSelection<Prisma.$cash_in_outPayload>
/**
 * Model cash_jenis
 * 
 */
export type cash_jenis = $Result.DefaultSelection<Prisma.$cash_jenisPayload>
/**
 * Model config
 * 
 */
export type config = $Result.DefaultSelection<Prisma.$configPayload>
/**
 * Model dana
 * 
 */
export type dana = $Result.DefaultSelection<Prisma.$danaPayload>
/**
 * Model dana_test
 * 
 */
export type dana_test = $Result.DefaultSelection<Prisma.$dana_testPayload>
/**
 * Model divisi
 * 
 */
export type divisi = $Result.DefaultSelection<Prisma.$divisiPayload>
/**
 * Model estimasi
 * 
 */
export type estimasi = $Result.DefaultSelection<Prisma.$estimasiPayload>
/**
 * Model estimasi_item
 * 
 */
export type estimasi_item = $Result.DefaultSelection<Prisma.$estimasi_itemPayload>
/**
 * Model inventaris
 * 
 */
export type inventaris = $Result.DefaultSelection<Prisma.$inventarisPayload>
/**
 * Model pelunasan_pembelian
 * 
 */
export type pelunasan_pembelian = $Result.DefaultSelection<Prisma.$pelunasan_pembelianPayload>
/**
 * Model pemusnahan
 * 
 */
export type pemusnahan = $Result.DefaultSelection<Prisma.$pemusnahanPayload>
/**
 * Model produk
 * 
 */
export type produk = $Result.DefaultSelection<Prisma.$produkPayload>
/**
 * Model produk_harga
 * 
 */
export type produk_harga = $Result.DefaultSelection<Prisma.$produk_hargaPayload>
/**
 * Model rapb
 * 
 */
export type rapb = $Result.DefaultSelection<Prisma.$rapbPayload>
/**
 * Model saldo_toko
 * 
 */
export type saldo_toko = $Result.DefaultSelection<Prisma.$saldo_tokoPayload>
/**
 * Model shu_mutasi
 * 
 */
export type shu_mutasi = $Result.DefaultSelection<Prisma.$shu_mutasiPayload>
/**
 * Model supplier
 * 
 */
export type supplier = $Result.DefaultSelection<Prisma.$supplierPayload>
/**
 * Model supplier_kredit
 * 
 */
export type supplier_kredit = $Result.DefaultSelection<Prisma.$supplier_kreditPayload>
/**
 * Model transaksi
 * 
 */
export type transaksi = $Result.DefaultSelection<Prisma.$transaksiPayload>
/**
 * Model transaksi_item
 * 
 */
export type transaksi_item = $Result.DefaultSelection<Prisma.$transaksi_itemPayload>
/**
 * Model transaksi_jenis
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type transaksi_jenis = $Result.DefaultSelection<Prisma.$transaksi_jenisPayload>
/**
 * Model tujuan
 * 
 */
export type tujuan = $Result.DefaultSelection<Prisma.$tujuanPayload>
/**
 * Model tutup_kasir
 * 
 */
export type tutup_kasir = $Result.DefaultSelection<Prisma.$tutup_kasirPayload>
/**
 * Model utang_sp
 * 
 */
export type utang_sp = $Result.DefaultSelection<Prisma.$utang_spPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs>;

  /**
   * `prisma.anggota`: Exposes CRUD operations for the **anggota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anggotas
    * const anggotas = await prisma.anggota.findMany()
    * ```
    */
  get anggota(): Prisma.anggotaDelegate<ExtArgs>;

  /**
   * `prisma.anggota_kredit`: Exposes CRUD operations for the **anggota_kredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anggota_kredits
    * const anggota_kredits = await prisma.anggota_kredit.findMany()
    * ```
    */
  get anggota_kredit(): Prisma.anggota_kreditDelegate<ExtArgs>;

  /**
   * `prisma.bagian`: Exposes CRUD operations for the **bagian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bagians
    * const bagians = await prisma.bagian.findMany()
    * ```
    */
  get bagian(): Prisma.bagianDelegate<ExtArgs>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.bankDelegate<ExtArgs>;

  /**
   * `prisma.bank_mutasi`: Exposes CRUD operations for the **bank_mutasi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bank_mutasis
    * const bank_mutasis = await prisma.bank_mutasi.findMany()
    * ```
    */
  get bank_mutasi(): Prisma.bank_mutasiDelegate<ExtArgs>;

  /**
   * `prisma.bayar`: Exposes CRUD operations for the **bayar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bayars
    * const bayars = await prisma.bayar.findMany()
    * ```
    */
  get bayar(): Prisma.bayarDelegate<ExtArgs>;

  /**
   * `prisma.beban_operasional`: Exposes CRUD operations for the **beban_operasional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beban_operasionals
    * const beban_operasionals = await prisma.beban_operasional.findMany()
    * ```
    */
  get beban_operasional(): Prisma.beban_operasionalDelegate<ExtArgs>;

  /**
   * `prisma.cash_in_out`: Exposes CRUD operations for the **cash_in_out** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cash_in_outs
    * const cash_in_outs = await prisma.cash_in_out.findMany()
    * ```
    */
  get cash_in_out(): Prisma.cash_in_outDelegate<ExtArgs>;

  /**
   * `prisma.cash_jenis`: Exposes CRUD operations for the **cash_jenis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cash_jenis
    * const cash_jenis = await prisma.cash_jenis.findMany()
    * ```
    */
  get cash_jenis(): Prisma.cash_jenisDelegate<ExtArgs>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.configDelegate<ExtArgs>;

  /**
   * `prisma.dana`: Exposes CRUD operations for the **dana** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Danas
    * const danas = await prisma.dana.findMany()
    * ```
    */
  get dana(): Prisma.danaDelegate<ExtArgs>;

  /**
   * `prisma.dana_test`: Exposes CRUD operations for the **dana_test** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dana_tests
    * const dana_tests = await prisma.dana_test.findMany()
    * ```
    */
  get dana_test(): Prisma.dana_testDelegate<ExtArgs>;

  /**
   * `prisma.divisi`: Exposes CRUD operations for the **divisi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Divisis
    * const divisis = await prisma.divisi.findMany()
    * ```
    */
  get divisi(): Prisma.divisiDelegate<ExtArgs>;

  /**
   * `prisma.estimasi`: Exposes CRUD operations for the **estimasi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimasis
    * const estimasis = await prisma.estimasi.findMany()
    * ```
    */
  get estimasi(): Prisma.estimasiDelegate<ExtArgs>;

  /**
   * `prisma.estimasi_item`: Exposes CRUD operations for the **estimasi_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estimasi_items
    * const estimasi_items = await prisma.estimasi_item.findMany()
    * ```
    */
  get estimasi_item(): Prisma.estimasi_itemDelegate<ExtArgs>;

  /**
   * `prisma.inventaris`: Exposes CRUD operations for the **inventaris** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventarises
    * const inventarises = await prisma.inventaris.findMany()
    * ```
    */
  get inventaris(): Prisma.inventarisDelegate<ExtArgs>;

  /**
   * `prisma.pelunasan_pembelian`: Exposes CRUD operations for the **pelunasan_pembelian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pelunasan_pembelians
    * const pelunasan_pembelians = await prisma.pelunasan_pembelian.findMany()
    * ```
    */
  get pelunasan_pembelian(): Prisma.pelunasan_pembelianDelegate<ExtArgs>;

  /**
   * `prisma.pemusnahan`: Exposes CRUD operations for the **pemusnahan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pemusnahans
    * const pemusnahans = await prisma.pemusnahan.findMany()
    * ```
    */
  get pemusnahan(): Prisma.pemusnahanDelegate<ExtArgs>;

  /**
   * `prisma.produk`: Exposes CRUD operations for the **produk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produks
    * const produks = await prisma.produk.findMany()
    * ```
    */
  get produk(): Prisma.produkDelegate<ExtArgs>;

  /**
   * `prisma.produk_harga`: Exposes CRUD operations for the **produk_harga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produk_hargas
    * const produk_hargas = await prisma.produk_harga.findMany()
    * ```
    */
  get produk_harga(): Prisma.produk_hargaDelegate<ExtArgs>;

  /**
   * `prisma.rapb`: Exposes CRUD operations for the **rapb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rapbs
    * const rapbs = await prisma.rapb.findMany()
    * ```
    */
  get rapb(): Prisma.rapbDelegate<ExtArgs>;

  /**
   * `prisma.saldo_toko`: Exposes CRUD operations for the **saldo_toko** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Saldo_tokos
    * const saldo_tokos = await prisma.saldo_toko.findMany()
    * ```
    */
  get saldo_toko(): Prisma.saldo_tokoDelegate<ExtArgs>;

  /**
   * `prisma.shu_mutasi`: Exposes CRUD operations for the **shu_mutasi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shu_mutasis
    * const shu_mutasis = await prisma.shu_mutasi.findMany()
    * ```
    */
  get shu_mutasi(): Prisma.shu_mutasiDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.supplierDelegate<ExtArgs>;

  /**
   * `prisma.supplier_kredit`: Exposes CRUD operations for the **supplier_kredit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supplier_kredits
    * const supplier_kredits = await prisma.supplier_kredit.findMany()
    * ```
    */
  get supplier_kredit(): Prisma.supplier_kreditDelegate<ExtArgs>;

  /**
   * `prisma.transaksi`: Exposes CRUD operations for the **transaksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksis
    * const transaksis = await prisma.transaksi.findMany()
    * ```
    */
  get transaksi(): Prisma.transaksiDelegate<ExtArgs>;

  /**
   * `prisma.transaksi_item`: Exposes CRUD operations for the **transaksi_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksi_items
    * const transaksi_items = await prisma.transaksi_item.findMany()
    * ```
    */
  get transaksi_item(): Prisma.transaksi_itemDelegate<ExtArgs>;

  /**
   * `prisma.transaksi_jenis`: Exposes CRUD operations for the **transaksi_jenis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksi_jenis
    * const transaksi_jenis = await prisma.transaksi_jenis.findMany()
    * ```
    */
  get transaksi_jenis(): Prisma.transaksi_jenisDelegate<ExtArgs>;

  /**
   * `prisma.tujuan`: Exposes CRUD operations for the **tujuan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tujuans
    * const tujuans = await prisma.tujuan.findMany()
    * ```
    */
  get tujuan(): Prisma.tujuanDelegate<ExtArgs>;

  /**
   * `prisma.tutup_kasir`: Exposes CRUD operations for the **tutup_kasir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutup_kasirs
    * const tutup_kasirs = await prisma.tutup_kasir.findMany()
    * ```
    */
  get tutup_kasir(): Prisma.tutup_kasirDelegate<ExtArgs>;

  /**
   * `prisma.utang_sp`: Exposes CRUD operations for the **utang_sp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utang_sps
    * const utang_sps = await prisma.utang_sp.findMany()
    * ```
    */
  get utang_sp(): Prisma.utang_spDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin: 'admin',
    anggota: 'anggota',
    anggota_kredit: 'anggota_kredit',
    bagian: 'bagian',
    bank: 'bank',
    bank_mutasi: 'bank_mutasi',
    bayar: 'bayar',
    beban_operasional: 'beban_operasional',
    cash_in_out: 'cash_in_out',
    cash_jenis: 'cash_jenis',
    config: 'config',
    dana: 'dana',
    dana_test: 'dana_test',
    divisi: 'divisi',
    estimasi: 'estimasi',
    estimasi_item: 'estimasi_item',
    inventaris: 'inventaris',
    pelunasan_pembelian: 'pelunasan_pembelian',
    pemusnahan: 'pemusnahan',
    produk: 'produk',
    produk_harga: 'produk_harga',
    rapb: 'rapb',
    saldo_toko: 'saldo_toko',
    shu_mutasi: 'shu_mutasi',
    supplier: 'supplier',
    supplier_kredit: 'supplier_kredit',
    transaksi: 'transaksi',
    transaksi_item: 'transaksi_item',
    transaksi_jenis: 'transaksi_jenis',
    tujuan: 'tujuan',
    tutup_kasir: 'tutup_kasir',
    utang_sp: 'utang_sp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "admin" | "anggota" | "anggota_kredit" | "bagian" | "bank" | "bank_mutasi" | "bayar" | "beban_operasional" | "cash_in_out" | "cash_jenis" | "config" | "dana" | "dana_test" | "divisi" | "estimasi" | "estimasi_item" | "inventaris" | "pelunasan_pembelian" | "pemusnahan" | "produk" | "produk_harga" | "rapb" | "saldo_toko" | "shu_mutasi" | "supplier" | "supplier_kredit" | "transaksi" | "transaksi_item" | "transaksi_jenis" | "tujuan" | "tutup_kasir" | "utang_sp"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      anggota: {
        payload: Prisma.$anggotaPayload<ExtArgs>
        fields: Prisma.anggotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anggotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anggotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          findFirst: {
            args: Prisma.anggotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anggotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          findMany: {
            args: Prisma.anggotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>[]
          }
          create: {
            args: Prisma.anggotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          createMany: {
            args: Prisma.anggotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.anggotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          update: {
            args: Prisma.anggotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          deleteMany: {
            args: Prisma.anggotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anggotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anggotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggotaPayload>
          }
          aggregate: {
            args: Prisma.AnggotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnggota>
          }
          groupBy: {
            args: Prisma.anggotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnggotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.anggotaCountArgs<ExtArgs>
            result: $Utils.Optional<AnggotaCountAggregateOutputType> | number
          }
        }
      }
      anggota_kredit: {
        payload: Prisma.$anggota_kreditPayload<ExtArgs>
        fields: Prisma.anggota_kreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anggota_kreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anggota_kreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          findFirst: {
            args: Prisma.anggota_kreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anggota_kreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          findMany: {
            args: Prisma.anggota_kreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>[]
          }
          create: {
            args: Prisma.anggota_kreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          createMany: {
            args: Prisma.anggota_kreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.anggota_kreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          update: {
            args: Prisma.anggota_kreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          deleteMany: {
            args: Prisma.anggota_kreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anggota_kreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anggota_kreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anggota_kreditPayload>
          }
          aggregate: {
            args: Prisma.Anggota_kreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnggota_kredit>
          }
          groupBy: {
            args: Prisma.anggota_kreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<Anggota_kreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.anggota_kreditCountArgs<ExtArgs>
            result: $Utils.Optional<Anggota_kreditCountAggregateOutputType> | number
          }
        }
      }
      bagian: {
        payload: Prisma.$bagianPayload<ExtArgs>
        fields: Prisma.bagianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bagianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bagianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          findFirst: {
            args: Prisma.bagianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bagianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          findMany: {
            args: Prisma.bagianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>[]
          }
          create: {
            args: Prisma.bagianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          createMany: {
            args: Prisma.bagianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bagianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          update: {
            args: Prisma.bagianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          deleteMany: {
            args: Prisma.bagianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bagianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bagianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bagianPayload>
          }
          aggregate: {
            args: Prisma.BagianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBagian>
          }
          groupBy: {
            args: Prisma.bagianGroupByArgs<ExtArgs>
            result: $Utils.Optional<BagianGroupByOutputType>[]
          }
          count: {
            args: Prisma.bagianCountArgs<ExtArgs>
            result: $Utils.Optional<BagianCountAggregateOutputType> | number
          }
        }
      }
      bank: {
        payload: Prisma.$bankPayload<ExtArgs>
        fields: Prisma.bankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          findFirst: {
            args: Prisma.bankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          findMany: {
            args: Prisma.bankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>[]
          }
          create: {
            args: Prisma.bankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          createMany: {
            args: Prisma.bankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          update: {
            args: Prisma.bankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          deleteMany: {
            args: Prisma.bankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.bankGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.bankCountArgs<ExtArgs>
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
      bank_mutasi: {
        payload: Prisma.$bank_mutasiPayload<ExtArgs>
        fields: Prisma.bank_mutasiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bank_mutasiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bank_mutasiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          findFirst: {
            args: Prisma.bank_mutasiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bank_mutasiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          findMany: {
            args: Prisma.bank_mutasiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>[]
          }
          create: {
            args: Prisma.bank_mutasiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          createMany: {
            args: Prisma.bank_mutasiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bank_mutasiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          update: {
            args: Prisma.bank_mutasiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          deleteMany: {
            args: Prisma.bank_mutasiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bank_mutasiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bank_mutasiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bank_mutasiPayload>
          }
          aggregate: {
            args: Prisma.Bank_mutasiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank_mutasi>
          }
          groupBy: {
            args: Prisma.bank_mutasiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bank_mutasiGroupByOutputType>[]
          }
          count: {
            args: Prisma.bank_mutasiCountArgs<ExtArgs>
            result: $Utils.Optional<Bank_mutasiCountAggregateOutputType> | number
          }
        }
      }
      bayar: {
        payload: Prisma.$bayarPayload<ExtArgs>
        fields: Prisma.bayarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bayarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bayarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          findFirst: {
            args: Prisma.bayarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bayarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          findMany: {
            args: Prisma.bayarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>[]
          }
          create: {
            args: Prisma.bayarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          createMany: {
            args: Prisma.bayarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bayarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          update: {
            args: Prisma.bayarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          deleteMany: {
            args: Prisma.bayarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bayarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bayarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bayarPayload>
          }
          aggregate: {
            args: Prisma.BayarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBayar>
          }
          groupBy: {
            args: Prisma.bayarGroupByArgs<ExtArgs>
            result: $Utils.Optional<BayarGroupByOutputType>[]
          }
          count: {
            args: Prisma.bayarCountArgs<ExtArgs>
            result: $Utils.Optional<BayarCountAggregateOutputType> | number
          }
        }
      }
      beban_operasional: {
        payload: Prisma.$beban_operasionalPayload<ExtArgs>
        fields: Prisma.beban_operasionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.beban_operasionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.beban_operasionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          findFirst: {
            args: Prisma.beban_operasionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.beban_operasionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          findMany: {
            args: Prisma.beban_operasionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>[]
          }
          create: {
            args: Prisma.beban_operasionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          createMany: {
            args: Prisma.beban_operasionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.beban_operasionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          update: {
            args: Prisma.beban_operasionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          deleteMany: {
            args: Prisma.beban_operasionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.beban_operasionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.beban_operasionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beban_operasionalPayload>
          }
          aggregate: {
            args: Prisma.Beban_operasionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeban_operasional>
          }
          groupBy: {
            args: Prisma.beban_operasionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Beban_operasionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.beban_operasionalCountArgs<ExtArgs>
            result: $Utils.Optional<Beban_operasionalCountAggregateOutputType> | number
          }
        }
      }
      cash_in_out: {
        payload: Prisma.$cash_in_outPayload<ExtArgs>
        fields: Prisma.cash_in_outFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cash_in_outFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cash_in_outFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          findFirst: {
            args: Prisma.cash_in_outFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cash_in_outFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          findMany: {
            args: Prisma.cash_in_outFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>[]
          }
          create: {
            args: Prisma.cash_in_outCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          createMany: {
            args: Prisma.cash_in_outCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cash_in_outDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          update: {
            args: Prisma.cash_in_outUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          deleteMany: {
            args: Prisma.cash_in_outDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cash_in_outUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cash_in_outUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_in_outPayload>
          }
          aggregate: {
            args: Prisma.Cash_in_outAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCash_in_out>
          }
          groupBy: {
            args: Prisma.cash_in_outGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cash_in_outGroupByOutputType>[]
          }
          count: {
            args: Prisma.cash_in_outCountArgs<ExtArgs>
            result: $Utils.Optional<Cash_in_outCountAggregateOutputType> | number
          }
        }
      }
      cash_jenis: {
        payload: Prisma.$cash_jenisPayload<ExtArgs>
        fields: Prisma.cash_jenisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cash_jenisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cash_jenisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          findFirst: {
            args: Prisma.cash_jenisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cash_jenisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          findMany: {
            args: Prisma.cash_jenisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>[]
          }
          create: {
            args: Prisma.cash_jenisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          createMany: {
            args: Prisma.cash_jenisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cash_jenisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          update: {
            args: Prisma.cash_jenisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          deleteMany: {
            args: Prisma.cash_jenisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cash_jenisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cash_jenisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cash_jenisPayload>
          }
          aggregate: {
            args: Prisma.Cash_jenisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCash_jenis>
          }
          groupBy: {
            args: Prisma.cash_jenisGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cash_jenisGroupByOutputType>[]
          }
          count: {
            args: Prisma.cash_jenisCountArgs<ExtArgs>
            result: $Utils.Optional<Cash_jenisCountAggregateOutputType> | number
          }
        }
      }
      config: {
        payload: Prisma.$configPayload<ExtArgs>
        fields: Prisma.configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findFirst: {
            args: Prisma.configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findMany: {
            args: Prisma.configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          create: {
            args: Prisma.configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          createMany: {
            args: Prisma.configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          update: {
            args: Prisma.configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          deleteMany: {
            args: Prisma.configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.configGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.configCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      dana: {
        payload: Prisma.$danaPayload<ExtArgs>
        fields: Prisma.danaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.danaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.danaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          findFirst: {
            args: Prisma.danaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.danaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          findMany: {
            args: Prisma.danaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>[]
          }
          create: {
            args: Prisma.danaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          createMany: {
            args: Prisma.danaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.danaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          update: {
            args: Prisma.danaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          deleteMany: {
            args: Prisma.danaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.danaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.danaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$danaPayload>
          }
          aggregate: {
            args: Prisma.DanaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDana>
          }
          groupBy: {
            args: Prisma.danaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DanaGroupByOutputType>[]
          }
          count: {
            args: Prisma.danaCountArgs<ExtArgs>
            result: $Utils.Optional<DanaCountAggregateOutputType> | number
          }
        }
      }
      dana_test: {
        payload: Prisma.$dana_testPayload<ExtArgs>
        fields: Prisma.dana_testFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dana_testFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dana_testFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          findFirst: {
            args: Prisma.dana_testFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dana_testFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          findMany: {
            args: Prisma.dana_testFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>[]
          }
          create: {
            args: Prisma.dana_testCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          createMany: {
            args: Prisma.dana_testCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dana_testDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          update: {
            args: Prisma.dana_testUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          deleteMany: {
            args: Prisma.dana_testDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dana_testUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dana_testUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dana_testPayload>
          }
          aggregate: {
            args: Prisma.Dana_testAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDana_test>
          }
          groupBy: {
            args: Prisma.dana_testGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dana_testGroupByOutputType>[]
          }
          count: {
            args: Prisma.dana_testCountArgs<ExtArgs>
            result: $Utils.Optional<Dana_testCountAggregateOutputType> | number
          }
        }
      }
      divisi: {
        payload: Prisma.$divisiPayload<ExtArgs>
        fields: Prisma.divisiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.divisiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.divisiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          findFirst: {
            args: Prisma.divisiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.divisiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          findMany: {
            args: Prisma.divisiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>[]
          }
          create: {
            args: Prisma.divisiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          createMany: {
            args: Prisma.divisiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.divisiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          update: {
            args: Prisma.divisiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          deleteMany: {
            args: Prisma.divisiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.divisiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.divisiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$divisiPayload>
          }
          aggregate: {
            args: Prisma.DivisiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDivisi>
          }
          groupBy: {
            args: Prisma.divisiGroupByArgs<ExtArgs>
            result: $Utils.Optional<DivisiGroupByOutputType>[]
          }
          count: {
            args: Prisma.divisiCountArgs<ExtArgs>
            result: $Utils.Optional<DivisiCountAggregateOutputType> | number
          }
        }
      }
      estimasi: {
        payload: Prisma.$estimasiPayload<ExtArgs>
        fields: Prisma.estimasiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimasiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimasiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          findFirst: {
            args: Prisma.estimasiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimasiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          findMany: {
            args: Prisma.estimasiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>[]
          }
          create: {
            args: Prisma.estimasiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          createMany: {
            args: Prisma.estimasiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estimasiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          update: {
            args: Prisma.estimasiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          deleteMany: {
            args: Prisma.estimasiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimasiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estimasiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasiPayload>
          }
          aggregate: {
            args: Prisma.EstimasiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimasi>
          }
          groupBy: {
            args: Prisma.estimasiGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstimasiGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimasiCountArgs<ExtArgs>
            result: $Utils.Optional<EstimasiCountAggregateOutputType> | number
          }
        }
      }
      estimasi_item: {
        payload: Prisma.$estimasi_itemPayload<ExtArgs>
        fields: Prisma.estimasi_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estimasi_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estimasi_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          findFirst: {
            args: Prisma.estimasi_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estimasi_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          findMany: {
            args: Prisma.estimasi_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>[]
          }
          create: {
            args: Prisma.estimasi_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          createMany: {
            args: Prisma.estimasi_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.estimasi_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          update: {
            args: Prisma.estimasi_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          deleteMany: {
            args: Prisma.estimasi_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estimasi_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.estimasi_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estimasi_itemPayload>
          }
          aggregate: {
            args: Prisma.Estimasi_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstimasi_item>
          }
          groupBy: {
            args: Prisma.estimasi_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Estimasi_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.estimasi_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Estimasi_itemCountAggregateOutputType> | number
          }
        }
      }
      inventaris: {
        payload: Prisma.$inventarisPayload<ExtArgs>
        fields: Prisma.inventarisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventarisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventarisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          findFirst: {
            args: Prisma.inventarisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventarisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          findMany: {
            args: Prisma.inventarisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>[]
          }
          create: {
            args: Prisma.inventarisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          createMany: {
            args: Prisma.inventarisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventarisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          update: {
            args: Prisma.inventarisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          deleteMany: {
            args: Prisma.inventarisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventarisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventarisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventarisPayload>
          }
          aggregate: {
            args: Prisma.InventarisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventaris>
          }
          groupBy: {
            args: Prisma.inventarisGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventarisGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventarisCountArgs<ExtArgs>
            result: $Utils.Optional<InventarisCountAggregateOutputType> | number
          }
        }
      }
      pelunasan_pembelian: {
        payload: Prisma.$pelunasan_pembelianPayload<ExtArgs>
        fields: Prisma.pelunasan_pembelianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pelunasan_pembelianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pelunasan_pembelianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          findFirst: {
            args: Prisma.pelunasan_pembelianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pelunasan_pembelianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          findMany: {
            args: Prisma.pelunasan_pembelianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>[]
          }
          create: {
            args: Prisma.pelunasan_pembelianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          createMany: {
            args: Prisma.pelunasan_pembelianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pelunasan_pembelianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          update: {
            args: Prisma.pelunasan_pembelianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          deleteMany: {
            args: Prisma.pelunasan_pembelianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pelunasan_pembelianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pelunasan_pembelianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pelunasan_pembelianPayload>
          }
          aggregate: {
            args: Prisma.Pelunasan_pembelianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePelunasan_pembelian>
          }
          groupBy: {
            args: Prisma.pelunasan_pembelianGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pelunasan_pembelianGroupByOutputType>[]
          }
          count: {
            args: Prisma.pelunasan_pembelianCountArgs<ExtArgs>
            result: $Utils.Optional<Pelunasan_pembelianCountAggregateOutputType> | number
          }
        }
      }
      pemusnahan: {
        payload: Prisma.$pemusnahanPayload<ExtArgs>
        fields: Prisma.pemusnahanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pemusnahanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pemusnahanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          findFirst: {
            args: Prisma.pemusnahanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pemusnahanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          findMany: {
            args: Prisma.pemusnahanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>[]
          }
          create: {
            args: Prisma.pemusnahanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          createMany: {
            args: Prisma.pemusnahanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pemusnahanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          update: {
            args: Prisma.pemusnahanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          deleteMany: {
            args: Prisma.pemusnahanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pemusnahanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pemusnahanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pemusnahanPayload>
          }
          aggregate: {
            args: Prisma.PemusnahanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePemusnahan>
          }
          groupBy: {
            args: Prisma.pemusnahanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PemusnahanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pemusnahanCountArgs<ExtArgs>
            result: $Utils.Optional<PemusnahanCountAggregateOutputType> | number
          }
        }
      }
      produk: {
        payload: Prisma.$produkPayload<ExtArgs>
        fields: Prisma.produkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          findFirst: {
            args: Prisma.produkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          findMany: {
            args: Prisma.produkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>[]
          }
          create: {
            args: Prisma.produkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          createMany: {
            args: Prisma.produkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.produkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          update: {
            args: Prisma.produkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          deleteMany: {
            args: Prisma.produkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.produkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.produkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produkPayload>
          }
          aggregate: {
            args: Prisma.ProdukAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduk>
          }
          groupBy: {
            args: Prisma.produkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProdukGroupByOutputType>[]
          }
          count: {
            args: Prisma.produkCountArgs<ExtArgs>
            result: $Utils.Optional<ProdukCountAggregateOutputType> | number
          }
        }
      }
      produk_harga: {
        payload: Prisma.$produk_hargaPayload<ExtArgs>
        fields: Prisma.produk_hargaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.produk_hargaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.produk_hargaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          findFirst: {
            args: Prisma.produk_hargaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.produk_hargaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          findMany: {
            args: Prisma.produk_hargaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>[]
          }
          create: {
            args: Prisma.produk_hargaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          createMany: {
            args: Prisma.produk_hargaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.produk_hargaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          update: {
            args: Prisma.produk_hargaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          deleteMany: {
            args: Prisma.produk_hargaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.produk_hargaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.produk_hargaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$produk_hargaPayload>
          }
          aggregate: {
            args: Prisma.Produk_hargaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduk_harga>
          }
          groupBy: {
            args: Prisma.produk_hargaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Produk_hargaGroupByOutputType>[]
          }
          count: {
            args: Prisma.produk_hargaCountArgs<ExtArgs>
            result: $Utils.Optional<Produk_hargaCountAggregateOutputType> | number
          }
        }
      }
      rapb: {
        payload: Prisma.$rapbPayload<ExtArgs>
        fields: Prisma.rapbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rapbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rapbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          findFirst: {
            args: Prisma.rapbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rapbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          findMany: {
            args: Prisma.rapbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>[]
          }
          create: {
            args: Prisma.rapbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          createMany: {
            args: Prisma.rapbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rapbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          update: {
            args: Prisma.rapbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          deleteMany: {
            args: Prisma.rapbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rapbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rapbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapbPayload>
          }
          aggregate: {
            args: Prisma.RapbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRapb>
          }
          groupBy: {
            args: Prisma.rapbGroupByArgs<ExtArgs>
            result: $Utils.Optional<RapbGroupByOutputType>[]
          }
          count: {
            args: Prisma.rapbCountArgs<ExtArgs>
            result: $Utils.Optional<RapbCountAggregateOutputType> | number
          }
        }
      }
      saldo_toko: {
        payload: Prisma.$saldo_tokoPayload<ExtArgs>
        fields: Prisma.saldo_tokoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saldo_tokoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saldo_tokoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          findFirst: {
            args: Prisma.saldo_tokoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saldo_tokoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          findMany: {
            args: Prisma.saldo_tokoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>[]
          }
          create: {
            args: Prisma.saldo_tokoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          createMany: {
            args: Prisma.saldo_tokoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.saldo_tokoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          update: {
            args: Prisma.saldo_tokoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          deleteMany: {
            args: Prisma.saldo_tokoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saldo_tokoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.saldo_tokoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saldo_tokoPayload>
          }
          aggregate: {
            args: Prisma.Saldo_tokoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaldo_toko>
          }
          groupBy: {
            args: Prisma.saldo_tokoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Saldo_tokoGroupByOutputType>[]
          }
          count: {
            args: Prisma.saldo_tokoCountArgs<ExtArgs>
            result: $Utils.Optional<Saldo_tokoCountAggregateOutputType> | number
          }
        }
      }
      shu_mutasi: {
        payload: Prisma.$shu_mutasiPayload<ExtArgs>
        fields: Prisma.shu_mutasiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shu_mutasiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shu_mutasiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          findFirst: {
            args: Prisma.shu_mutasiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shu_mutasiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          findMany: {
            args: Prisma.shu_mutasiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>[]
          }
          create: {
            args: Prisma.shu_mutasiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          createMany: {
            args: Prisma.shu_mutasiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shu_mutasiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          update: {
            args: Prisma.shu_mutasiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          deleteMany: {
            args: Prisma.shu_mutasiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shu_mutasiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shu_mutasiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shu_mutasiPayload>
          }
          aggregate: {
            args: Prisma.Shu_mutasiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShu_mutasi>
          }
          groupBy: {
            args: Prisma.shu_mutasiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shu_mutasiGroupByOutputType>[]
          }
          count: {
            args: Prisma.shu_mutasiCountArgs<ExtArgs>
            result: $Utils.Optional<Shu_mutasiCountAggregateOutputType> | number
          }
        }
      }
      supplier: {
        payload: Prisma.$supplierPayload<ExtArgs>
        fields: Prisma.supplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findFirst: {
            args: Prisma.supplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          findMany: {
            args: Prisma.supplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>[]
          }
          create: {
            args: Prisma.supplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          createMany: {
            args: Prisma.supplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.supplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          update: {
            args: Prisma.supplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          deleteMany: {
            args: Prisma.supplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.supplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.supplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      supplier_kredit: {
        payload: Prisma.$supplier_kreditPayload<ExtArgs>
        fields: Prisma.supplier_kreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supplier_kreditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supplier_kreditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          findFirst: {
            args: Prisma.supplier_kreditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supplier_kreditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          findMany: {
            args: Prisma.supplier_kreditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>[]
          }
          create: {
            args: Prisma.supplier_kreditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          createMany: {
            args: Prisma.supplier_kreditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.supplier_kreditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          update: {
            args: Prisma.supplier_kreditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          deleteMany: {
            args: Prisma.supplier_kreditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supplier_kreditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.supplier_kreditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supplier_kreditPayload>
          }
          aggregate: {
            args: Prisma.Supplier_kreditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier_kredit>
          }
          groupBy: {
            args: Prisma.supplier_kreditGroupByArgs<ExtArgs>
            result: $Utils.Optional<Supplier_kreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.supplier_kreditCountArgs<ExtArgs>
            result: $Utils.Optional<Supplier_kreditCountAggregateOutputType> | number
          }
        }
      }
      transaksi: {
        payload: Prisma.$transaksiPayload<ExtArgs>
        fields: Prisma.transaksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findFirst: {
            args: Prisma.transaksiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findMany: {
            args: Prisma.transaksiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>[]
          }
          create: {
            args: Prisma.transaksiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          createMany: {
            args: Prisma.transaksiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transaksiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          update: {
            args: Prisma.transaksiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          deleteMany: {
            args: Prisma.transaksiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transaksiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          aggregate: {
            args: Prisma.TransaksiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi>
          }
          groupBy: {
            args: Prisma.transaksiGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransaksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksiCountArgs<ExtArgs>
            result: $Utils.Optional<TransaksiCountAggregateOutputType> | number
          }
        }
      }
      transaksi_item: {
        payload: Prisma.$transaksi_itemPayload<ExtArgs>
        fields: Prisma.transaksi_itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksi_itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksi_itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          findFirst: {
            args: Prisma.transaksi_itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksi_itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          findMany: {
            args: Prisma.transaksi_itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>[]
          }
          create: {
            args: Prisma.transaksi_itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          createMany: {
            args: Prisma.transaksi_itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transaksi_itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          update: {
            args: Prisma.transaksi_itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          deleteMany: {
            args: Prisma.transaksi_itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksi_itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transaksi_itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_itemPayload>
          }
          aggregate: {
            args: Prisma.Transaksi_itemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi_item>
          }
          groupBy: {
            args: Prisma.transaksi_itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_itemGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksi_itemCountArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_itemCountAggregateOutputType> | number
          }
        }
      }
      transaksi_jenis: {
        payload: Prisma.$transaksi_jenisPayload<ExtArgs>
        fields: Prisma.transaksi_jenisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksi_jenisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksi_jenisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          findFirst: {
            args: Prisma.transaksi_jenisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksi_jenisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          findMany: {
            args: Prisma.transaksi_jenisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>[]
          }
          create: {
            args: Prisma.transaksi_jenisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          createMany: {
            args: Prisma.transaksi_jenisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transaksi_jenisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          update: {
            args: Prisma.transaksi_jenisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          deleteMany: {
            args: Prisma.transaksi_jenisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksi_jenisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transaksi_jenisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksi_jenisPayload>
          }
          aggregate: {
            args: Prisma.Transaksi_jenisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi_jenis>
          }
          groupBy: {
            args: Prisma.transaksi_jenisGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_jenisGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksi_jenisCountArgs<ExtArgs>
            result: $Utils.Optional<Transaksi_jenisCountAggregateOutputType> | number
          }
        }
      }
      tujuan: {
        payload: Prisma.$tujuanPayload<ExtArgs>
        fields: Prisma.tujuanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tujuanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tujuanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          findFirst: {
            args: Prisma.tujuanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tujuanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          findMany: {
            args: Prisma.tujuanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>[]
          }
          create: {
            args: Prisma.tujuanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          createMany: {
            args: Prisma.tujuanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tujuanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          update: {
            args: Prisma.tujuanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          deleteMany: {
            args: Prisma.tujuanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tujuanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tujuanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tujuanPayload>
          }
          aggregate: {
            args: Prisma.TujuanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTujuan>
          }
          groupBy: {
            args: Prisma.tujuanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TujuanGroupByOutputType>[]
          }
          count: {
            args: Prisma.tujuanCountArgs<ExtArgs>
            result: $Utils.Optional<TujuanCountAggregateOutputType> | number
          }
        }
      }
      tutup_kasir: {
        payload: Prisma.$tutup_kasirPayload<ExtArgs>
        fields: Prisma.tutup_kasirFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tutup_kasirFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tutup_kasirFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          findFirst: {
            args: Prisma.tutup_kasirFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tutup_kasirFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          findMany: {
            args: Prisma.tutup_kasirFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>[]
          }
          create: {
            args: Prisma.tutup_kasirCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          createMany: {
            args: Prisma.tutup_kasirCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tutup_kasirDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          update: {
            args: Prisma.tutup_kasirUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          deleteMany: {
            args: Prisma.tutup_kasirDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tutup_kasirUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tutup_kasirUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tutup_kasirPayload>
          }
          aggregate: {
            args: Prisma.Tutup_kasirAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutup_kasir>
          }
          groupBy: {
            args: Prisma.tutup_kasirGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tutup_kasirGroupByOutputType>[]
          }
          count: {
            args: Prisma.tutup_kasirCountArgs<ExtArgs>
            result: $Utils.Optional<Tutup_kasirCountAggregateOutputType> | number
          }
        }
      }
      utang_sp: {
        payload: Prisma.$utang_spPayload<ExtArgs>
        fields: Prisma.utang_spFieldRefs
        operations: {
          findUnique: {
            args: Prisma.utang_spFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.utang_spFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          findFirst: {
            args: Prisma.utang_spFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.utang_spFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          findMany: {
            args: Prisma.utang_spFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>[]
          }
          create: {
            args: Prisma.utang_spCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          createMany: {
            args: Prisma.utang_spCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.utang_spDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          update: {
            args: Prisma.utang_spUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          deleteMany: {
            args: Prisma.utang_spDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.utang_spUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.utang_spUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$utang_spPayload>
          }
          aggregate: {
            args: Prisma.Utang_spAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtang_sp>
          }
          groupBy: {
            args: Prisma.utang_spGroupByArgs<ExtArgs>
            result: $Utils.Optional<Utang_spGroupByOutputType>[]
          }
          count: {
            args: Prisma.utang_spCountArgs<ExtArgs>
            result: $Utils.Optional<Utang_spCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    bagian: number | null
    level: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    bagian: number | null
    level: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    bagian: number | null
    username: string | null
    password: string | null
    nama: string | null
    type: string | null
    level: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    bagian: number | null
    username: string | null
    password: string | null
    nama: string | null
    type: string | null
    level: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    bagian: number
    username: number
    password: number
    nama: number
    type: number
    level: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    bagian?: true
    level?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    bagian?: true
    level?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    bagian?: true
    username?: true
    password?: true
    nama?: true
    type?: true
    level?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    bagian?: true
    username?: true
    password?: true
    nama?: true
    type?: true
    level?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    bagian?: true
    username?: true
    password?: true
    nama?: true
    type?: true
    level?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    bagian: number
    username: string
    password: string
    nama: string
    type: string
    level: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bagian?: boolean
    username?: boolean
    password?: boolean
    nama?: boolean
    type?: boolean
    level?: boolean
  }, ExtArgs["result"]["admin"]>


  export type adminSelectScalar = {
    id?: boolean
    bagian?: boolean
    username?: boolean
    password?: boolean
    nama?: boolean
    type?: boolean
    level?: boolean
  }


  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bagian: number
      username: string
      password: string
      nama: string
      type: string
      level: number
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */ 
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly bagian: FieldRef<"admin", 'Int'>
    readonly username: FieldRef<"admin", 'String'>
    readonly password: FieldRef<"admin", 'String'>
    readonly nama: FieldRef<"admin", 'String'>
    readonly type: FieldRef<"admin", 'String'>
    readonly level: FieldRef<"admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
  }


  /**
   * Model anggota
   */

  export type AggregateAnggota = {
    _count: AnggotaCountAggregateOutputType | null
    _avg: AnggotaAvgAggregateOutputType | null
    _sum: AnggotaSumAggregateOutputType | null
    _min: AnggotaMinAggregateOutputType | null
    _max: AnggotaMaxAggregateOutputType | null
  }

  export type AnggotaAvgAggregateOutputType = {
    id: number | null
    kredit_limit: Decimal | null
    kredit_pinjaman: Decimal | null
    status: number | null
  }

  export type AnggotaSumAggregateOutputType = {
    id: number | null
    kredit_limit: Decimal | null
    kredit_pinjaman: Decimal | null
    status: number | null
  }

  export type AnggotaMinAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    telp: string | null
    kredit_limit: Decimal | null
    kredit_pinjaman: Decimal | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type AnggotaMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    telp: string | null
    kredit_limit: Decimal | null
    kredit_pinjaman: Decimal | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type AnggotaCountAggregateOutputType = {
    id: number
    kode: number
    nama: number
    alamat: number
    telp: number
    kredit_limit: number
    kredit_pinjaman: number
    status: number
    created: number
    modified: number
    _all: number
  }


  export type AnggotaAvgAggregateInputType = {
    id?: true
    kredit_limit?: true
    kredit_pinjaman?: true
    status?: true
  }

  export type AnggotaSumAggregateInputType = {
    id?: true
    kredit_limit?: true
    kredit_pinjaman?: true
    status?: true
  }

  export type AnggotaMinAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    telp?: true
    kredit_limit?: true
    kredit_pinjaman?: true
    status?: true
    created?: true
    modified?: true
  }

  export type AnggotaMaxAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    telp?: true
    kredit_limit?: true
    kredit_pinjaman?: true
    status?: true
    created?: true
    modified?: true
  }

  export type AnggotaCountAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    telp?: true
    kredit_limit?: true
    kredit_pinjaman?: true
    status?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type AnggotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anggota to aggregate.
     */
    where?: anggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggotas to fetch.
     */
    orderBy?: anggotaOrderByWithRelationInput | anggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anggotas
    **/
    _count?: true | AnggotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnggotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnggotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnggotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnggotaMaxAggregateInputType
  }

  export type GetAnggotaAggregateType<T extends AnggotaAggregateArgs> = {
        [P in keyof T & keyof AggregateAnggota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnggota[P]>
      : GetScalarType<T[P], AggregateAnggota[P]>
  }




  export type anggotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anggotaWhereInput
    orderBy?: anggotaOrderByWithAggregationInput | anggotaOrderByWithAggregationInput[]
    by: AnggotaScalarFieldEnum[] | AnggotaScalarFieldEnum
    having?: anggotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnggotaCountAggregateInputType | true
    _avg?: AnggotaAvgAggregateInputType
    _sum?: AnggotaSumAggregateInputType
    _min?: AnggotaMinAggregateInputType
    _max?: AnggotaMaxAggregateInputType
  }

  export type AnggotaGroupByOutputType = {
    id: number
    kode: string
    nama: string
    alamat: string
    telp: string
    kredit_limit: Decimal
    kredit_pinjaman: Decimal
    status: number
    created: Date | null
    modified: Date | null
    _count: AnggotaCountAggregateOutputType | null
    _avg: AnggotaAvgAggregateOutputType | null
    _sum: AnggotaSumAggregateOutputType | null
    _min: AnggotaMinAggregateOutputType | null
    _max: AnggotaMaxAggregateOutputType | null
  }

  type GetAnggotaGroupByPayload<T extends anggotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnggotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnggotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnggotaGroupByOutputType[P]>
            : GetScalarType<T[P], AnggotaGroupByOutputType[P]>
        }
      >
    >


  export type anggotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    telp?: boolean
    kredit_limit?: boolean
    kredit_pinjaman?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["anggota"]>


  export type anggotaSelectScalar = {
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    telp?: boolean
    kredit_limit?: boolean
    kredit_pinjaman?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $anggotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anggota"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      nama: string
      alamat: string
      telp: string
      kredit_limit: Prisma.Decimal
      kredit_pinjaman: Prisma.Decimal
      status: number
      created: Date | null
      modified: Date | null
    }, ExtArgs["result"]["anggota"]>
    composites: {}
  }

  type anggotaGetPayload<S extends boolean | null | undefined | anggotaDefaultArgs> = $Result.GetResult<Prisma.$anggotaPayload, S>

  type anggotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anggotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnggotaCountAggregateInputType | true
    }

  export interface anggotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anggota'], meta: { name: 'anggota' } }
    /**
     * Find zero or one Anggota that matches the filter.
     * @param {anggotaFindUniqueArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anggotaFindUniqueArgs>(args: SelectSubset<T, anggotaFindUniqueArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Anggota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anggotaFindUniqueOrThrowArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anggotaFindUniqueOrThrowArgs>(args: SelectSubset<T, anggotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Anggota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaFindFirstArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anggotaFindFirstArgs>(args?: SelectSubset<T, anggotaFindFirstArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Anggota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaFindFirstOrThrowArgs} args - Arguments to find a Anggota
     * @example
     * // Get one Anggota
     * const anggota = await prisma.anggota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anggotaFindFirstOrThrowArgs>(args?: SelectSubset<T, anggotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Anggotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anggotas
     * const anggotas = await prisma.anggota.findMany()
     * 
     * // Get first 10 Anggotas
     * const anggotas = await prisma.anggota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anggotaWithIdOnly = await prisma.anggota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends anggotaFindManyArgs>(args?: SelectSubset<T, anggotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Anggota.
     * @param {anggotaCreateArgs} args - Arguments to create a Anggota.
     * @example
     * // Create one Anggota
     * const Anggota = await prisma.anggota.create({
     *   data: {
     *     // ... data to create a Anggota
     *   }
     * })
     * 
     */
    create<T extends anggotaCreateArgs>(args: SelectSubset<T, anggotaCreateArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Anggotas.
     * @param {anggotaCreateManyArgs} args - Arguments to create many Anggotas.
     * @example
     * // Create many Anggotas
     * const anggota = await prisma.anggota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anggotaCreateManyArgs>(args?: SelectSubset<T, anggotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anggota.
     * @param {anggotaDeleteArgs} args - Arguments to delete one Anggota.
     * @example
     * // Delete one Anggota
     * const Anggota = await prisma.anggota.delete({
     *   where: {
     *     // ... filter to delete one Anggota
     *   }
     * })
     * 
     */
    delete<T extends anggotaDeleteArgs>(args: SelectSubset<T, anggotaDeleteArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Anggota.
     * @param {anggotaUpdateArgs} args - Arguments to update one Anggota.
     * @example
     * // Update one Anggota
     * const anggota = await prisma.anggota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anggotaUpdateArgs>(args: SelectSubset<T, anggotaUpdateArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Anggotas.
     * @param {anggotaDeleteManyArgs} args - Arguments to filter Anggotas to delete.
     * @example
     * // Delete a few Anggotas
     * const { count } = await prisma.anggota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anggotaDeleteManyArgs>(args?: SelectSubset<T, anggotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anggotas
     * const anggota = await prisma.anggota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anggotaUpdateManyArgs>(args: SelectSubset<T, anggotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anggota.
     * @param {anggotaUpsertArgs} args - Arguments to update or create a Anggota.
     * @example
     * // Update or create a Anggota
     * const anggota = await prisma.anggota.upsert({
     *   create: {
     *     // ... data to create a Anggota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anggota we want to update
     *   }
     * })
     */
    upsert<T extends anggotaUpsertArgs>(args: SelectSubset<T, anggotaUpsertArgs<ExtArgs>>): Prisma__anggotaClient<$Result.GetResult<Prisma.$anggotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Anggotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaCountArgs} args - Arguments to filter Anggotas to count.
     * @example
     * // Count the number of Anggotas
     * const count = await prisma.anggota.count({
     *   where: {
     *     // ... the filter for the Anggotas we want to count
     *   }
     * })
    **/
    count<T extends anggotaCountArgs>(
      args?: Subset<T, anggotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnggotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnggotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnggotaAggregateArgs>(args: Subset<T, AnggotaAggregateArgs>): Prisma.PrismaPromise<GetAnggotaAggregateType<T>>

    /**
     * Group by Anggota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anggotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anggotaGroupByArgs['orderBy'] }
        : { orderBy?: anggotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anggotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnggotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anggota model
   */
  readonly fields: anggotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anggota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anggotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anggota model
   */ 
  interface anggotaFieldRefs {
    readonly id: FieldRef<"anggota", 'Int'>
    readonly kode: FieldRef<"anggota", 'String'>
    readonly nama: FieldRef<"anggota", 'String'>
    readonly alamat: FieldRef<"anggota", 'String'>
    readonly telp: FieldRef<"anggota", 'String'>
    readonly kredit_limit: FieldRef<"anggota", 'Decimal'>
    readonly kredit_pinjaman: FieldRef<"anggota", 'Decimal'>
    readonly status: FieldRef<"anggota", 'Int'>
    readonly created: FieldRef<"anggota", 'DateTime'>
    readonly modified: FieldRef<"anggota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * anggota findUnique
   */
  export type anggotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter, which anggota to fetch.
     */
    where: anggotaWhereUniqueInput
  }

  /**
   * anggota findUniqueOrThrow
   */
  export type anggotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter, which anggota to fetch.
     */
    where: anggotaWhereUniqueInput
  }

  /**
   * anggota findFirst
   */
  export type anggotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter, which anggota to fetch.
     */
    where?: anggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggotas to fetch.
     */
    orderBy?: anggotaOrderByWithRelationInput | anggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anggotas.
     */
    cursor?: anggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anggotas.
     */
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * anggota findFirstOrThrow
   */
  export type anggotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter, which anggota to fetch.
     */
    where?: anggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggotas to fetch.
     */
    orderBy?: anggotaOrderByWithRelationInput | anggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anggotas.
     */
    cursor?: anggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anggotas.
     */
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * anggota findMany
   */
  export type anggotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter, which anggotas to fetch.
     */
    where?: anggotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggotas to fetch.
     */
    orderBy?: anggotaOrderByWithRelationInput | anggotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anggotas.
     */
    cursor?: anggotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggotas.
     */
    skip?: number
    distinct?: AnggotaScalarFieldEnum | AnggotaScalarFieldEnum[]
  }

  /**
   * anggota create
   */
  export type anggotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * The data needed to create a anggota.
     */
    data: XOR<anggotaCreateInput, anggotaUncheckedCreateInput>
  }

  /**
   * anggota createMany
   */
  export type anggotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anggotas.
     */
    data: anggotaCreateManyInput | anggotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anggota update
   */
  export type anggotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * The data needed to update a anggota.
     */
    data: XOR<anggotaUpdateInput, anggotaUncheckedUpdateInput>
    /**
     * Choose, which anggota to update.
     */
    where: anggotaWhereUniqueInput
  }

  /**
   * anggota updateMany
   */
  export type anggotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anggotas.
     */
    data: XOR<anggotaUpdateManyMutationInput, anggotaUncheckedUpdateManyInput>
    /**
     * Filter which anggotas to update
     */
    where?: anggotaWhereInput
  }

  /**
   * anggota upsert
   */
  export type anggotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * The filter to search for the anggota to update in case it exists.
     */
    where: anggotaWhereUniqueInput
    /**
     * In case the anggota found by the `where` argument doesn't exist, create a new anggota with this data.
     */
    create: XOR<anggotaCreateInput, anggotaUncheckedCreateInput>
    /**
     * In case the anggota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anggotaUpdateInput, anggotaUncheckedUpdateInput>
  }

  /**
   * anggota delete
   */
  export type anggotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
    /**
     * Filter which anggota to delete.
     */
    where: anggotaWhereUniqueInput
  }

  /**
   * anggota deleteMany
   */
  export type anggotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anggotas to delete
     */
    where?: anggotaWhereInput
  }

  /**
   * anggota without action
   */
  export type anggotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota
     */
    select?: anggotaSelect<ExtArgs> | null
  }


  /**
   * Model anggota_kredit
   */

  export type AggregateAnggota_kredit = {
    _count: Anggota_kreditCountAggregateOutputType | null
    _avg: Anggota_kreditAvgAggregateOutputType | null
    _sum: Anggota_kreditSumAggregateOutputType | null
    _min: Anggota_kreditMinAggregateOutputType | null
    _max: Anggota_kreditMaxAggregateOutputType | null
  }

  export type Anggota_kreditAvgAggregateOutputType = {
    id: number | null
    id_anggota: number | null
    id_transaksi: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Anggota_kreditSumAggregateOutputType = {
    id: number | null
    id_anggota: number | null
    id_transaksi: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Anggota_kreditMinAggregateOutputType = {
    id: number | null
    id_anggota: number | null
    id_transaksi: number | null
    ex_bukti: string | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Anggota_kreditMaxAggregateOutputType = {
    id: number | null
    id_anggota: number | null
    id_transaksi: number | null
    ex_bukti: string | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Anggota_kreditCountAggregateOutputType = {
    id: number
    id_anggota: number
    id_transaksi: number
    ex_bukti: number
    tanggal: number
    debet: number
    kredit: number
    keterangan: number
    _all: number
  }


  export type Anggota_kreditAvgAggregateInputType = {
    id?: true
    id_anggota?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
  }

  export type Anggota_kreditSumAggregateInputType = {
    id?: true
    id_anggota?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
  }

  export type Anggota_kreditMinAggregateInputType = {
    id?: true
    id_anggota?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Anggota_kreditMaxAggregateInputType = {
    id?: true
    id_anggota?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Anggota_kreditCountAggregateInputType = {
    id?: true
    id_anggota?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
    _all?: true
  }

  export type Anggota_kreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anggota_kredit to aggregate.
     */
    where?: anggota_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggota_kredits to fetch.
     */
    orderBy?: anggota_kreditOrderByWithRelationInput | anggota_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anggota_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggota_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggota_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anggota_kredits
    **/
    _count?: true | Anggota_kreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Anggota_kreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Anggota_kreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Anggota_kreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Anggota_kreditMaxAggregateInputType
  }

  export type GetAnggota_kreditAggregateType<T extends Anggota_kreditAggregateArgs> = {
        [P in keyof T & keyof AggregateAnggota_kredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnggota_kredit[P]>
      : GetScalarType<T[P], AggregateAnggota_kredit[P]>
  }




  export type anggota_kreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anggota_kreditWhereInput
    orderBy?: anggota_kreditOrderByWithAggregationInput | anggota_kreditOrderByWithAggregationInput[]
    by: Anggota_kreditScalarFieldEnum[] | Anggota_kreditScalarFieldEnum
    having?: anggota_kreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Anggota_kreditCountAggregateInputType | true
    _avg?: Anggota_kreditAvgAggregateInputType
    _sum?: Anggota_kreditSumAggregateInputType
    _min?: Anggota_kreditMinAggregateInputType
    _max?: Anggota_kreditMaxAggregateInputType
  }

  export type Anggota_kreditGroupByOutputType = {
    id: number
    id_anggota: number
    id_transaksi: number
    ex_bukti: string
    tanggal: Date | null
    debet: Decimal
    kredit: Decimal
    keterangan: string
    _count: Anggota_kreditCountAggregateOutputType | null
    _avg: Anggota_kreditAvgAggregateOutputType | null
    _sum: Anggota_kreditSumAggregateOutputType | null
    _min: Anggota_kreditMinAggregateOutputType | null
    _max: Anggota_kreditMaxAggregateOutputType | null
  }

  type GetAnggota_kreditGroupByPayload<T extends anggota_kreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Anggota_kreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Anggota_kreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Anggota_kreditGroupByOutputType[P]>
            : GetScalarType<T[P], Anggota_kreditGroupByOutputType[P]>
        }
      >
    >


  export type anggota_kreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_anggota?: boolean
    id_transaksi?: boolean
    ex_bukti?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["anggota_kredit"]>


  export type anggota_kreditSelectScalar = {
    id?: boolean
    id_anggota?: boolean
    id_transaksi?: boolean
    ex_bukti?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }


  export type $anggota_kreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anggota_kredit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_anggota: number
      id_transaksi: number
      ex_bukti: string
      tanggal: Date | null
      debet: Prisma.Decimal
      kredit: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["anggota_kredit"]>
    composites: {}
  }

  type anggota_kreditGetPayload<S extends boolean | null | undefined | anggota_kreditDefaultArgs> = $Result.GetResult<Prisma.$anggota_kreditPayload, S>

  type anggota_kreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anggota_kreditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Anggota_kreditCountAggregateInputType | true
    }

  export interface anggota_kreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anggota_kredit'], meta: { name: 'anggota_kredit' } }
    /**
     * Find zero or one Anggota_kredit that matches the filter.
     * @param {anggota_kreditFindUniqueArgs} args - Arguments to find a Anggota_kredit
     * @example
     * // Get one Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anggota_kreditFindUniqueArgs>(args: SelectSubset<T, anggota_kreditFindUniqueArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Anggota_kredit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anggota_kreditFindUniqueOrThrowArgs} args - Arguments to find a Anggota_kredit
     * @example
     * // Get one Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anggota_kreditFindUniqueOrThrowArgs>(args: SelectSubset<T, anggota_kreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Anggota_kredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditFindFirstArgs} args - Arguments to find a Anggota_kredit
     * @example
     * // Get one Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anggota_kreditFindFirstArgs>(args?: SelectSubset<T, anggota_kreditFindFirstArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Anggota_kredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditFindFirstOrThrowArgs} args - Arguments to find a Anggota_kredit
     * @example
     * // Get one Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anggota_kreditFindFirstOrThrowArgs>(args?: SelectSubset<T, anggota_kreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Anggota_kredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anggota_kredits
     * const anggota_kredits = await prisma.anggota_kredit.findMany()
     * 
     * // Get first 10 Anggota_kredits
     * const anggota_kredits = await prisma.anggota_kredit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anggota_kreditWithIdOnly = await prisma.anggota_kredit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends anggota_kreditFindManyArgs>(args?: SelectSubset<T, anggota_kreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Anggota_kredit.
     * @param {anggota_kreditCreateArgs} args - Arguments to create a Anggota_kredit.
     * @example
     * // Create one Anggota_kredit
     * const Anggota_kredit = await prisma.anggota_kredit.create({
     *   data: {
     *     // ... data to create a Anggota_kredit
     *   }
     * })
     * 
     */
    create<T extends anggota_kreditCreateArgs>(args: SelectSubset<T, anggota_kreditCreateArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Anggota_kredits.
     * @param {anggota_kreditCreateManyArgs} args - Arguments to create many Anggota_kredits.
     * @example
     * // Create many Anggota_kredits
     * const anggota_kredit = await prisma.anggota_kredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anggota_kreditCreateManyArgs>(args?: SelectSubset<T, anggota_kreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anggota_kredit.
     * @param {anggota_kreditDeleteArgs} args - Arguments to delete one Anggota_kredit.
     * @example
     * // Delete one Anggota_kredit
     * const Anggota_kredit = await prisma.anggota_kredit.delete({
     *   where: {
     *     // ... filter to delete one Anggota_kredit
     *   }
     * })
     * 
     */
    delete<T extends anggota_kreditDeleteArgs>(args: SelectSubset<T, anggota_kreditDeleteArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Anggota_kredit.
     * @param {anggota_kreditUpdateArgs} args - Arguments to update one Anggota_kredit.
     * @example
     * // Update one Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anggota_kreditUpdateArgs>(args: SelectSubset<T, anggota_kreditUpdateArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Anggota_kredits.
     * @param {anggota_kreditDeleteManyArgs} args - Arguments to filter Anggota_kredits to delete.
     * @example
     * // Delete a few Anggota_kredits
     * const { count } = await prisma.anggota_kredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anggota_kreditDeleteManyArgs>(args?: SelectSubset<T, anggota_kreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anggota_kredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anggota_kredits
     * const anggota_kredit = await prisma.anggota_kredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anggota_kreditUpdateManyArgs>(args: SelectSubset<T, anggota_kreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anggota_kredit.
     * @param {anggota_kreditUpsertArgs} args - Arguments to update or create a Anggota_kredit.
     * @example
     * // Update or create a Anggota_kredit
     * const anggota_kredit = await prisma.anggota_kredit.upsert({
     *   create: {
     *     // ... data to create a Anggota_kredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anggota_kredit we want to update
     *   }
     * })
     */
    upsert<T extends anggota_kreditUpsertArgs>(args: SelectSubset<T, anggota_kreditUpsertArgs<ExtArgs>>): Prisma__anggota_kreditClient<$Result.GetResult<Prisma.$anggota_kreditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Anggota_kredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditCountArgs} args - Arguments to filter Anggota_kredits to count.
     * @example
     * // Count the number of Anggota_kredits
     * const count = await prisma.anggota_kredit.count({
     *   where: {
     *     // ... the filter for the Anggota_kredits we want to count
     *   }
     * })
    **/
    count<T extends anggota_kreditCountArgs>(
      args?: Subset<T, anggota_kreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Anggota_kreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anggota_kredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Anggota_kreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Anggota_kreditAggregateArgs>(args: Subset<T, Anggota_kreditAggregateArgs>): Prisma.PrismaPromise<GetAnggota_kreditAggregateType<T>>

    /**
     * Group by Anggota_kredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anggota_kreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anggota_kreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anggota_kreditGroupByArgs['orderBy'] }
        : { orderBy?: anggota_kreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anggota_kreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnggota_kreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anggota_kredit model
   */
  readonly fields: anggota_kreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anggota_kredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anggota_kreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anggota_kredit model
   */ 
  interface anggota_kreditFieldRefs {
    readonly id: FieldRef<"anggota_kredit", 'Int'>
    readonly id_anggota: FieldRef<"anggota_kredit", 'Int'>
    readonly id_transaksi: FieldRef<"anggota_kredit", 'Int'>
    readonly ex_bukti: FieldRef<"anggota_kredit", 'String'>
    readonly tanggal: FieldRef<"anggota_kredit", 'DateTime'>
    readonly debet: FieldRef<"anggota_kredit", 'Decimal'>
    readonly kredit: FieldRef<"anggota_kredit", 'Decimal'>
    readonly keterangan: FieldRef<"anggota_kredit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * anggota_kredit findUnique
   */
  export type anggota_kreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter, which anggota_kredit to fetch.
     */
    where: anggota_kreditWhereUniqueInput
  }

  /**
   * anggota_kredit findUniqueOrThrow
   */
  export type anggota_kreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter, which anggota_kredit to fetch.
     */
    where: anggota_kreditWhereUniqueInput
  }

  /**
   * anggota_kredit findFirst
   */
  export type anggota_kreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter, which anggota_kredit to fetch.
     */
    where?: anggota_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggota_kredits to fetch.
     */
    orderBy?: anggota_kreditOrderByWithRelationInput | anggota_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anggota_kredits.
     */
    cursor?: anggota_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggota_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggota_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anggota_kredits.
     */
    distinct?: Anggota_kreditScalarFieldEnum | Anggota_kreditScalarFieldEnum[]
  }

  /**
   * anggota_kredit findFirstOrThrow
   */
  export type anggota_kreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter, which anggota_kredit to fetch.
     */
    where?: anggota_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggota_kredits to fetch.
     */
    orderBy?: anggota_kreditOrderByWithRelationInput | anggota_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anggota_kredits.
     */
    cursor?: anggota_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggota_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggota_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anggota_kredits.
     */
    distinct?: Anggota_kreditScalarFieldEnum | Anggota_kreditScalarFieldEnum[]
  }

  /**
   * anggota_kredit findMany
   */
  export type anggota_kreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter, which anggota_kredits to fetch.
     */
    where?: anggota_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anggota_kredits to fetch.
     */
    orderBy?: anggota_kreditOrderByWithRelationInput | anggota_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anggota_kredits.
     */
    cursor?: anggota_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anggota_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anggota_kredits.
     */
    skip?: number
    distinct?: Anggota_kreditScalarFieldEnum | Anggota_kreditScalarFieldEnum[]
  }

  /**
   * anggota_kredit create
   */
  export type anggota_kreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * The data needed to create a anggota_kredit.
     */
    data: XOR<anggota_kreditCreateInput, anggota_kreditUncheckedCreateInput>
  }

  /**
   * anggota_kredit createMany
   */
  export type anggota_kreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anggota_kredits.
     */
    data: anggota_kreditCreateManyInput | anggota_kreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anggota_kredit update
   */
  export type anggota_kreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * The data needed to update a anggota_kredit.
     */
    data: XOR<anggota_kreditUpdateInput, anggota_kreditUncheckedUpdateInput>
    /**
     * Choose, which anggota_kredit to update.
     */
    where: anggota_kreditWhereUniqueInput
  }

  /**
   * anggota_kredit updateMany
   */
  export type anggota_kreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anggota_kredits.
     */
    data: XOR<anggota_kreditUpdateManyMutationInput, anggota_kreditUncheckedUpdateManyInput>
    /**
     * Filter which anggota_kredits to update
     */
    where?: anggota_kreditWhereInput
  }

  /**
   * anggota_kredit upsert
   */
  export type anggota_kreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * The filter to search for the anggota_kredit to update in case it exists.
     */
    where: anggota_kreditWhereUniqueInput
    /**
     * In case the anggota_kredit found by the `where` argument doesn't exist, create a new anggota_kredit with this data.
     */
    create: XOR<anggota_kreditCreateInput, anggota_kreditUncheckedCreateInput>
    /**
     * In case the anggota_kredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anggota_kreditUpdateInput, anggota_kreditUncheckedUpdateInput>
  }

  /**
   * anggota_kredit delete
   */
  export type anggota_kreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
    /**
     * Filter which anggota_kredit to delete.
     */
    where: anggota_kreditWhereUniqueInput
  }

  /**
   * anggota_kredit deleteMany
   */
  export type anggota_kreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anggota_kredits to delete
     */
    where?: anggota_kreditWhereInput
  }

  /**
   * anggota_kredit without action
   */
  export type anggota_kreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anggota_kredit
     */
    select?: anggota_kreditSelect<ExtArgs> | null
  }


  /**
   * Model bagian
   */

  export type AggregateBagian = {
    _count: BagianCountAggregateOutputType | null
    _avg: BagianAvgAggregateOutputType | null
    _sum: BagianSumAggregateOutputType | null
    _min: BagianMinAggregateOutputType | null
    _max: BagianMaxAggregateOutputType | null
  }

  export type BagianAvgAggregateOutputType = {
    id: number | null
  }

  export type BagianSumAggregateOutputType = {
    id: number | null
  }

  export type BagianMinAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type BagianMaxAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type BagianCountAggregateOutputType = {
    id: number
    nama: number
    _all: number
  }


  export type BagianAvgAggregateInputType = {
    id?: true
  }

  export type BagianSumAggregateInputType = {
    id?: true
  }

  export type BagianMinAggregateInputType = {
    id?: true
    nama?: true
  }

  export type BagianMaxAggregateInputType = {
    id?: true
    nama?: true
  }

  export type BagianCountAggregateInputType = {
    id?: true
    nama?: true
    _all?: true
  }

  export type BagianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bagian to aggregate.
     */
    where?: bagianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bagians to fetch.
     */
    orderBy?: bagianOrderByWithRelationInput | bagianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bagianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bagians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bagians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bagians
    **/
    _count?: true | BagianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BagianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BagianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BagianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BagianMaxAggregateInputType
  }

  export type GetBagianAggregateType<T extends BagianAggregateArgs> = {
        [P in keyof T & keyof AggregateBagian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBagian[P]>
      : GetScalarType<T[P], AggregateBagian[P]>
  }




  export type bagianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bagianWhereInput
    orderBy?: bagianOrderByWithAggregationInput | bagianOrderByWithAggregationInput[]
    by: BagianScalarFieldEnum[] | BagianScalarFieldEnum
    having?: bagianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BagianCountAggregateInputType | true
    _avg?: BagianAvgAggregateInputType
    _sum?: BagianSumAggregateInputType
    _min?: BagianMinAggregateInputType
    _max?: BagianMaxAggregateInputType
  }

  export type BagianGroupByOutputType = {
    id: number
    nama: string
    _count: BagianCountAggregateOutputType | null
    _avg: BagianAvgAggregateOutputType | null
    _sum: BagianSumAggregateOutputType | null
    _min: BagianMinAggregateOutputType | null
    _max: BagianMaxAggregateOutputType | null
  }

  type GetBagianGroupByPayload<T extends bagianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BagianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BagianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BagianGroupByOutputType[P]>
            : GetScalarType<T[P], BagianGroupByOutputType[P]>
        }
      >
    >


  export type bagianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
  }, ExtArgs["result"]["bagian"]>


  export type bagianSelectScalar = {
    id?: boolean
    nama?: boolean
  }


  export type $bagianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bagian"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
    }, ExtArgs["result"]["bagian"]>
    composites: {}
  }

  type bagianGetPayload<S extends boolean | null | undefined | bagianDefaultArgs> = $Result.GetResult<Prisma.$bagianPayload, S>

  type bagianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bagianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BagianCountAggregateInputType | true
    }

  export interface bagianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bagian'], meta: { name: 'bagian' } }
    /**
     * Find zero or one Bagian that matches the filter.
     * @param {bagianFindUniqueArgs} args - Arguments to find a Bagian
     * @example
     * // Get one Bagian
     * const bagian = await prisma.bagian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bagianFindUniqueArgs>(args: SelectSubset<T, bagianFindUniqueArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bagian that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bagianFindUniqueOrThrowArgs} args - Arguments to find a Bagian
     * @example
     * // Get one Bagian
     * const bagian = await prisma.bagian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bagianFindUniqueOrThrowArgs>(args: SelectSubset<T, bagianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bagian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianFindFirstArgs} args - Arguments to find a Bagian
     * @example
     * // Get one Bagian
     * const bagian = await prisma.bagian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bagianFindFirstArgs>(args?: SelectSubset<T, bagianFindFirstArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bagian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianFindFirstOrThrowArgs} args - Arguments to find a Bagian
     * @example
     * // Get one Bagian
     * const bagian = await prisma.bagian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bagianFindFirstOrThrowArgs>(args?: SelectSubset<T, bagianFindFirstOrThrowArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bagians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bagians
     * const bagians = await prisma.bagian.findMany()
     * 
     * // Get first 10 Bagians
     * const bagians = await prisma.bagian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bagianWithIdOnly = await prisma.bagian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bagianFindManyArgs>(args?: SelectSubset<T, bagianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bagian.
     * @param {bagianCreateArgs} args - Arguments to create a Bagian.
     * @example
     * // Create one Bagian
     * const Bagian = await prisma.bagian.create({
     *   data: {
     *     // ... data to create a Bagian
     *   }
     * })
     * 
     */
    create<T extends bagianCreateArgs>(args: SelectSubset<T, bagianCreateArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bagians.
     * @param {bagianCreateManyArgs} args - Arguments to create many Bagians.
     * @example
     * // Create many Bagians
     * const bagian = await prisma.bagian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bagianCreateManyArgs>(args?: SelectSubset<T, bagianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bagian.
     * @param {bagianDeleteArgs} args - Arguments to delete one Bagian.
     * @example
     * // Delete one Bagian
     * const Bagian = await prisma.bagian.delete({
     *   where: {
     *     // ... filter to delete one Bagian
     *   }
     * })
     * 
     */
    delete<T extends bagianDeleteArgs>(args: SelectSubset<T, bagianDeleteArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bagian.
     * @param {bagianUpdateArgs} args - Arguments to update one Bagian.
     * @example
     * // Update one Bagian
     * const bagian = await prisma.bagian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bagianUpdateArgs>(args: SelectSubset<T, bagianUpdateArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bagians.
     * @param {bagianDeleteManyArgs} args - Arguments to filter Bagians to delete.
     * @example
     * // Delete a few Bagians
     * const { count } = await prisma.bagian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bagianDeleteManyArgs>(args?: SelectSubset<T, bagianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bagians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bagians
     * const bagian = await prisma.bagian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bagianUpdateManyArgs>(args: SelectSubset<T, bagianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bagian.
     * @param {bagianUpsertArgs} args - Arguments to update or create a Bagian.
     * @example
     * // Update or create a Bagian
     * const bagian = await prisma.bagian.upsert({
     *   create: {
     *     // ... data to create a Bagian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bagian we want to update
     *   }
     * })
     */
    upsert<T extends bagianUpsertArgs>(args: SelectSubset<T, bagianUpsertArgs<ExtArgs>>): Prisma__bagianClient<$Result.GetResult<Prisma.$bagianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bagians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianCountArgs} args - Arguments to filter Bagians to count.
     * @example
     * // Count the number of Bagians
     * const count = await prisma.bagian.count({
     *   where: {
     *     // ... the filter for the Bagians we want to count
     *   }
     * })
    **/
    count<T extends bagianCountArgs>(
      args?: Subset<T, bagianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BagianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bagian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BagianAggregateArgs>(args: Subset<T, BagianAggregateArgs>): Prisma.PrismaPromise<GetBagianAggregateType<T>>

    /**
     * Group by Bagian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bagianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bagianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bagianGroupByArgs['orderBy'] }
        : { orderBy?: bagianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bagianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBagianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bagian model
   */
  readonly fields: bagianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bagian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bagianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bagian model
   */ 
  interface bagianFieldRefs {
    readonly id: FieldRef<"bagian", 'Int'>
    readonly nama: FieldRef<"bagian", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bagian findUnique
   */
  export type bagianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter, which bagian to fetch.
     */
    where: bagianWhereUniqueInput
  }

  /**
   * bagian findUniqueOrThrow
   */
  export type bagianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter, which bagian to fetch.
     */
    where: bagianWhereUniqueInput
  }

  /**
   * bagian findFirst
   */
  export type bagianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter, which bagian to fetch.
     */
    where?: bagianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bagians to fetch.
     */
    orderBy?: bagianOrderByWithRelationInput | bagianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bagians.
     */
    cursor?: bagianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bagians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bagians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bagians.
     */
    distinct?: BagianScalarFieldEnum | BagianScalarFieldEnum[]
  }

  /**
   * bagian findFirstOrThrow
   */
  export type bagianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter, which bagian to fetch.
     */
    where?: bagianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bagians to fetch.
     */
    orderBy?: bagianOrderByWithRelationInput | bagianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bagians.
     */
    cursor?: bagianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bagians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bagians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bagians.
     */
    distinct?: BagianScalarFieldEnum | BagianScalarFieldEnum[]
  }

  /**
   * bagian findMany
   */
  export type bagianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter, which bagians to fetch.
     */
    where?: bagianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bagians to fetch.
     */
    orderBy?: bagianOrderByWithRelationInput | bagianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bagians.
     */
    cursor?: bagianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bagians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bagians.
     */
    skip?: number
    distinct?: BagianScalarFieldEnum | BagianScalarFieldEnum[]
  }

  /**
   * bagian create
   */
  export type bagianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * The data needed to create a bagian.
     */
    data: XOR<bagianCreateInput, bagianUncheckedCreateInput>
  }

  /**
   * bagian createMany
   */
  export type bagianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bagians.
     */
    data: bagianCreateManyInput | bagianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bagian update
   */
  export type bagianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * The data needed to update a bagian.
     */
    data: XOR<bagianUpdateInput, bagianUncheckedUpdateInput>
    /**
     * Choose, which bagian to update.
     */
    where: bagianWhereUniqueInput
  }

  /**
   * bagian updateMany
   */
  export type bagianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bagians.
     */
    data: XOR<bagianUpdateManyMutationInput, bagianUncheckedUpdateManyInput>
    /**
     * Filter which bagians to update
     */
    where?: bagianWhereInput
  }

  /**
   * bagian upsert
   */
  export type bagianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * The filter to search for the bagian to update in case it exists.
     */
    where: bagianWhereUniqueInput
    /**
     * In case the bagian found by the `where` argument doesn't exist, create a new bagian with this data.
     */
    create: XOR<bagianCreateInput, bagianUncheckedCreateInput>
    /**
     * In case the bagian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bagianUpdateInput, bagianUncheckedUpdateInput>
  }

  /**
   * bagian delete
   */
  export type bagianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
    /**
     * Filter which bagian to delete.
     */
    where: bagianWhereUniqueInput
  }

  /**
   * bagian deleteMany
   */
  export type bagianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bagians to delete
     */
    where?: bagianWhereInput
  }

  /**
   * bagian without action
   */
  export type bagianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bagian
     */
    select?: bagianSelect<ExtArgs> | null
  }


  /**
   * Model bank
   */

  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankAvgAggregateOutputType = {
    id: number | null
    saldo: Decimal | null
  }

  export type BankSumAggregateOutputType = {
    id: number | null
    saldo: Decimal | null
  }

  export type BankMinAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    saldo: Decimal | null
  }

  export type BankMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    saldo: Decimal | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    kode: number
    nama: number
    saldo: number
    _all: number
  }


  export type BankAvgAggregateInputType = {
    id?: true
    saldo?: true
  }

  export type BankSumAggregateInputType = {
    id?: true
    saldo?: true
  }

  export type BankMinAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    saldo?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    saldo?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    saldo?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank to aggregate.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type bankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bankWhereInput
    orderBy?: bankOrderByWithAggregationInput | bankOrderByWithAggregationInput[]
    by: BankScalarFieldEnum[] | BankScalarFieldEnum
    having?: bankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _avg?: BankAvgAggregateInputType
    _sum?: BankSumAggregateInputType
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }

  export type BankGroupByOutputType = {
    id: number
    kode: string
    nama: string
    saldo: Decimal
    _count: BankCountAggregateOutputType | null
    _avg: BankAvgAggregateOutputType | null
    _sum: BankSumAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends bankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type bankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    nama?: boolean
    saldo?: boolean
  }, ExtArgs["result"]["bank"]>


  export type bankSelectScalar = {
    id?: boolean
    kode?: boolean
    nama?: boolean
    saldo?: boolean
  }


  export type $bankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      nama: string
      saldo: Prisma.Decimal
    }, ExtArgs["result"]["bank"]>
    composites: {}
  }

  type bankGetPayload<S extends boolean | null | undefined | bankDefaultArgs> = $Result.GetResult<Prisma.$bankPayload, S>

  type bankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface bankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank'], meta: { name: 'bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {bankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bankFindUniqueArgs>(args: SelectSubset<T, bankFindUniqueArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bankFindUniqueOrThrowArgs>(args: SelectSubset<T, bankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bankFindFirstArgs>(args?: SelectSubset<T, bankFindFirstArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bankFindFirstOrThrowArgs>(args?: SelectSubset<T, bankFindFirstOrThrowArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bankFindManyArgs>(args?: SelectSubset<T, bankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bank.
     * @param {bankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
     */
    create<T extends bankCreateArgs>(args: SelectSubset<T, bankCreateArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Banks.
     * @param {bankCreateManyArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const bank = await prisma.bank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bankCreateManyArgs>(args?: SelectSubset<T, bankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {bankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
     */
    delete<T extends bankDeleteArgs>(args: SelectSubset<T, bankDeleteArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bank.
     * @param {bankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bankUpdateArgs>(args: SelectSubset<T, bankUpdateArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Banks.
     * @param {bankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bankDeleteManyArgs>(args?: SelectSubset<T, bankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bankUpdateManyArgs>(args: SelectSubset<T, bankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {bankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
     */
    upsert<T extends bankUpsertArgs>(args: SelectSubset<T, bankUpsertArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends bankCountArgs>(
      args?: Subset<T, bankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bankGroupByArgs['orderBy'] }
        : { orderBy?: bankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank model
   */
  readonly fields: bankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank model
   */ 
  interface bankFieldRefs {
    readonly id: FieldRef<"bank", 'Int'>
    readonly kode: FieldRef<"bank", 'String'>
    readonly nama: FieldRef<"bank", 'String'>
    readonly saldo: FieldRef<"bank", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * bank findUnique
   */
  export type bankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank findUniqueOrThrow
   */
  export type bankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank findFirst
   */
  export type bankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank findFirstOrThrow
   */
  export type bankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank findMany
   */
  export type bankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank create
   */
  export type bankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * The data needed to create a bank.
     */
    data: XOR<bankCreateInput, bankUncheckedCreateInput>
  }

  /**
   * bank createMany
   */
  export type bankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks.
     */
    data: bankCreateManyInput | bankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank update
   */
  export type bankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * The data needed to update a bank.
     */
    data: XOR<bankUpdateInput, bankUncheckedUpdateInput>
    /**
     * Choose, which bank to update.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank updateMany
   */
  export type bankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks.
     */
    data: XOR<bankUpdateManyMutationInput, bankUncheckedUpdateManyInput>
    /**
     * Filter which banks to update
     */
    where?: bankWhereInput
  }

  /**
   * bank upsert
   */
  export type bankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * The filter to search for the bank to update in case it exists.
     */
    where: bankWhereUniqueInput
    /**
     * In case the bank found by the `where` argument doesn't exist, create a new bank with this data.
     */
    create: XOR<bankCreateInput, bankUncheckedCreateInput>
    /**
     * In case the bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bankUpdateInput, bankUncheckedUpdateInput>
  }

  /**
   * bank delete
   */
  export type bankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Filter which bank to delete.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank deleteMany
   */
  export type bankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks to delete
     */
    where?: bankWhereInput
  }

  /**
   * bank without action
   */
  export type bankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
  }


  /**
   * Model bank_mutasi
   */

  export type AggregateBank_mutasi = {
    _count: Bank_mutasiCountAggregateOutputType | null
    _avg: Bank_mutasiAvgAggregateOutputType | null
    _sum: Bank_mutasiSumAggregateOutputType | null
    _min: Bank_mutasiMinAggregateOutputType | null
    _max: Bank_mutasiMaxAggregateOutputType | null
  }

  export type Bank_mutasiAvgAggregateOutputType = {
    id: number | null
    id_bank: number | null
    debet: Decimal | null
    kredit: Decimal | null
    debet2: Decimal | null
    kredit2: Decimal | null
    adm: Decimal | null
    pajak: Decimal | null
    jasa: Decimal | null
  }

  export type Bank_mutasiSumAggregateOutputType = {
    id: number | null
    id_bank: number | null
    debet: Decimal | null
    kredit: Decimal | null
    debet2: Decimal | null
    kredit2: Decimal | null
    adm: Decimal | null
    pajak: Decimal | null
    jasa: Decimal | null
  }

  export type Bank_mutasiMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    id_bank: number | null
    debet: Decimal | null
    kredit: Decimal | null
    debet2: Decimal | null
    kredit2: Decimal | null
    adm: Decimal | null
    pajak: Decimal | null
    jasa: Decimal | null
    keterangan: string | null
  }

  export type Bank_mutasiMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    id_bank: number | null
    debet: Decimal | null
    kredit: Decimal | null
    debet2: Decimal | null
    kredit2: Decimal | null
    adm: Decimal | null
    pajak: Decimal | null
    jasa: Decimal | null
    keterangan: string | null
  }

  export type Bank_mutasiCountAggregateOutputType = {
    id: number
    tanggal: number
    id_bank: number
    debet: number
    kredit: number
    debet2: number
    kredit2: number
    adm: number
    pajak: number
    jasa: number
    keterangan: number
    _all: number
  }


  export type Bank_mutasiAvgAggregateInputType = {
    id?: true
    id_bank?: true
    debet?: true
    kredit?: true
    debet2?: true
    kredit2?: true
    adm?: true
    pajak?: true
    jasa?: true
  }

  export type Bank_mutasiSumAggregateInputType = {
    id?: true
    id_bank?: true
    debet?: true
    kredit?: true
    debet2?: true
    kredit2?: true
    adm?: true
    pajak?: true
    jasa?: true
  }

  export type Bank_mutasiMinAggregateInputType = {
    id?: true
    tanggal?: true
    id_bank?: true
    debet?: true
    kredit?: true
    debet2?: true
    kredit2?: true
    adm?: true
    pajak?: true
    jasa?: true
    keterangan?: true
  }

  export type Bank_mutasiMaxAggregateInputType = {
    id?: true
    tanggal?: true
    id_bank?: true
    debet?: true
    kredit?: true
    debet2?: true
    kredit2?: true
    adm?: true
    pajak?: true
    jasa?: true
    keterangan?: true
  }

  export type Bank_mutasiCountAggregateInputType = {
    id?: true
    tanggal?: true
    id_bank?: true
    debet?: true
    kredit?: true
    debet2?: true
    kredit2?: true
    adm?: true
    pajak?: true
    jasa?: true
    keterangan?: true
    _all?: true
  }

  export type Bank_mutasiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_mutasi to aggregate.
     */
    where?: bank_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_mutasis to fetch.
     */
    orderBy?: bank_mutasiOrderByWithRelationInput | bank_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bank_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bank_mutasis
    **/
    _count?: true | Bank_mutasiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bank_mutasiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bank_mutasiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bank_mutasiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bank_mutasiMaxAggregateInputType
  }

  export type GetBank_mutasiAggregateType<T extends Bank_mutasiAggregateArgs> = {
        [P in keyof T & keyof AggregateBank_mutasi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank_mutasi[P]>
      : GetScalarType<T[P], AggregateBank_mutasi[P]>
  }




  export type bank_mutasiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bank_mutasiWhereInput
    orderBy?: bank_mutasiOrderByWithAggregationInput | bank_mutasiOrderByWithAggregationInput[]
    by: Bank_mutasiScalarFieldEnum[] | Bank_mutasiScalarFieldEnum
    having?: bank_mutasiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bank_mutasiCountAggregateInputType | true
    _avg?: Bank_mutasiAvgAggregateInputType
    _sum?: Bank_mutasiSumAggregateInputType
    _min?: Bank_mutasiMinAggregateInputType
    _max?: Bank_mutasiMaxAggregateInputType
  }

  export type Bank_mutasiGroupByOutputType = {
    id: number
    tanggal: Date
    id_bank: number
    debet: Decimal
    kredit: Decimal
    debet2: Decimal
    kredit2: Decimal
    adm: Decimal
    pajak: Decimal
    jasa: Decimal
    keterangan: string
    _count: Bank_mutasiCountAggregateOutputType | null
    _avg: Bank_mutasiAvgAggregateOutputType | null
    _sum: Bank_mutasiSumAggregateOutputType | null
    _min: Bank_mutasiMinAggregateOutputType | null
    _max: Bank_mutasiMaxAggregateOutputType | null
  }

  type GetBank_mutasiGroupByPayload<T extends bank_mutasiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bank_mutasiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bank_mutasiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bank_mutasiGroupByOutputType[P]>
            : GetScalarType<T[P], Bank_mutasiGroupByOutputType[P]>
        }
      >
    >


  export type bank_mutasiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    id_bank?: boolean
    debet?: boolean
    kredit?: boolean
    debet2?: boolean
    kredit2?: boolean
    adm?: boolean
    pajak?: boolean
    jasa?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["bank_mutasi"]>


  export type bank_mutasiSelectScalar = {
    id?: boolean
    tanggal?: boolean
    id_bank?: boolean
    debet?: boolean
    kredit?: boolean
    debet2?: boolean
    kredit2?: boolean
    adm?: boolean
    pajak?: boolean
    jasa?: boolean
    keterangan?: boolean
  }


  export type $bank_mutasiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank_mutasi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      id_bank: number
      debet: Prisma.Decimal
      kredit: Prisma.Decimal
      debet2: Prisma.Decimal
      kredit2: Prisma.Decimal
      adm: Prisma.Decimal
      pajak: Prisma.Decimal
      jasa: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["bank_mutasi"]>
    composites: {}
  }

  type bank_mutasiGetPayload<S extends boolean | null | undefined | bank_mutasiDefaultArgs> = $Result.GetResult<Prisma.$bank_mutasiPayload, S>

  type bank_mutasiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bank_mutasiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Bank_mutasiCountAggregateInputType | true
    }

  export interface bank_mutasiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank_mutasi'], meta: { name: 'bank_mutasi' } }
    /**
     * Find zero or one Bank_mutasi that matches the filter.
     * @param {bank_mutasiFindUniqueArgs} args - Arguments to find a Bank_mutasi
     * @example
     * // Get one Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bank_mutasiFindUniqueArgs>(args: SelectSubset<T, bank_mutasiFindUniqueArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bank_mutasi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bank_mutasiFindUniqueOrThrowArgs} args - Arguments to find a Bank_mutasi
     * @example
     * // Get one Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bank_mutasiFindUniqueOrThrowArgs>(args: SelectSubset<T, bank_mutasiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bank_mutasi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiFindFirstArgs} args - Arguments to find a Bank_mutasi
     * @example
     * // Get one Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bank_mutasiFindFirstArgs>(args?: SelectSubset<T, bank_mutasiFindFirstArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bank_mutasi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiFindFirstOrThrowArgs} args - Arguments to find a Bank_mutasi
     * @example
     * // Get one Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bank_mutasiFindFirstOrThrowArgs>(args?: SelectSubset<T, bank_mutasiFindFirstOrThrowArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bank_mutasis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bank_mutasis
     * const bank_mutasis = await prisma.bank_mutasi.findMany()
     * 
     * // Get first 10 Bank_mutasis
     * const bank_mutasis = await prisma.bank_mutasi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bank_mutasiWithIdOnly = await prisma.bank_mutasi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bank_mutasiFindManyArgs>(args?: SelectSubset<T, bank_mutasiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bank_mutasi.
     * @param {bank_mutasiCreateArgs} args - Arguments to create a Bank_mutasi.
     * @example
     * // Create one Bank_mutasi
     * const Bank_mutasi = await prisma.bank_mutasi.create({
     *   data: {
     *     // ... data to create a Bank_mutasi
     *   }
     * })
     * 
     */
    create<T extends bank_mutasiCreateArgs>(args: SelectSubset<T, bank_mutasiCreateArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bank_mutasis.
     * @param {bank_mutasiCreateManyArgs} args - Arguments to create many Bank_mutasis.
     * @example
     * // Create many Bank_mutasis
     * const bank_mutasi = await prisma.bank_mutasi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bank_mutasiCreateManyArgs>(args?: SelectSubset<T, bank_mutasiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank_mutasi.
     * @param {bank_mutasiDeleteArgs} args - Arguments to delete one Bank_mutasi.
     * @example
     * // Delete one Bank_mutasi
     * const Bank_mutasi = await prisma.bank_mutasi.delete({
     *   where: {
     *     // ... filter to delete one Bank_mutasi
     *   }
     * })
     * 
     */
    delete<T extends bank_mutasiDeleteArgs>(args: SelectSubset<T, bank_mutasiDeleteArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bank_mutasi.
     * @param {bank_mutasiUpdateArgs} args - Arguments to update one Bank_mutasi.
     * @example
     * // Update one Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bank_mutasiUpdateArgs>(args: SelectSubset<T, bank_mutasiUpdateArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bank_mutasis.
     * @param {bank_mutasiDeleteManyArgs} args - Arguments to filter Bank_mutasis to delete.
     * @example
     * // Delete a few Bank_mutasis
     * const { count } = await prisma.bank_mutasi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bank_mutasiDeleteManyArgs>(args?: SelectSubset<T, bank_mutasiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bank_mutasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bank_mutasis
     * const bank_mutasi = await prisma.bank_mutasi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bank_mutasiUpdateManyArgs>(args: SelectSubset<T, bank_mutasiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank_mutasi.
     * @param {bank_mutasiUpsertArgs} args - Arguments to update or create a Bank_mutasi.
     * @example
     * // Update or create a Bank_mutasi
     * const bank_mutasi = await prisma.bank_mutasi.upsert({
     *   create: {
     *     // ... data to create a Bank_mutasi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank_mutasi we want to update
     *   }
     * })
     */
    upsert<T extends bank_mutasiUpsertArgs>(args: SelectSubset<T, bank_mutasiUpsertArgs<ExtArgs>>): Prisma__bank_mutasiClient<$Result.GetResult<Prisma.$bank_mutasiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bank_mutasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiCountArgs} args - Arguments to filter Bank_mutasis to count.
     * @example
     * // Count the number of Bank_mutasis
     * const count = await prisma.bank_mutasi.count({
     *   where: {
     *     // ... the filter for the Bank_mutasis we want to count
     *   }
     * })
    **/
    count<T extends bank_mutasiCountArgs>(
      args?: Subset<T, bank_mutasiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bank_mutasiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank_mutasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bank_mutasiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bank_mutasiAggregateArgs>(args: Subset<T, Bank_mutasiAggregateArgs>): Prisma.PrismaPromise<GetBank_mutasiAggregateType<T>>

    /**
     * Group by Bank_mutasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bank_mutasiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bank_mutasiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bank_mutasiGroupByArgs['orderBy'] }
        : { orderBy?: bank_mutasiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bank_mutasiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBank_mutasiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank_mutasi model
   */
  readonly fields: bank_mutasiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank_mutasi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bank_mutasiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank_mutasi model
   */ 
  interface bank_mutasiFieldRefs {
    readonly id: FieldRef<"bank_mutasi", 'Int'>
    readonly tanggal: FieldRef<"bank_mutasi", 'DateTime'>
    readonly id_bank: FieldRef<"bank_mutasi", 'Int'>
    readonly debet: FieldRef<"bank_mutasi", 'Decimal'>
    readonly kredit: FieldRef<"bank_mutasi", 'Decimal'>
    readonly debet2: FieldRef<"bank_mutasi", 'Decimal'>
    readonly kredit2: FieldRef<"bank_mutasi", 'Decimal'>
    readonly adm: FieldRef<"bank_mutasi", 'Decimal'>
    readonly pajak: FieldRef<"bank_mutasi", 'Decimal'>
    readonly jasa: FieldRef<"bank_mutasi", 'Decimal'>
    readonly keterangan: FieldRef<"bank_mutasi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bank_mutasi findUnique
   */
  export type bank_mutasiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which bank_mutasi to fetch.
     */
    where: bank_mutasiWhereUniqueInput
  }

  /**
   * bank_mutasi findUniqueOrThrow
   */
  export type bank_mutasiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which bank_mutasi to fetch.
     */
    where: bank_mutasiWhereUniqueInput
  }

  /**
   * bank_mutasi findFirst
   */
  export type bank_mutasiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which bank_mutasi to fetch.
     */
    where?: bank_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_mutasis to fetch.
     */
    orderBy?: bank_mutasiOrderByWithRelationInput | bank_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_mutasis.
     */
    cursor?: bank_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_mutasis.
     */
    distinct?: Bank_mutasiScalarFieldEnum | Bank_mutasiScalarFieldEnum[]
  }

  /**
   * bank_mutasi findFirstOrThrow
   */
  export type bank_mutasiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which bank_mutasi to fetch.
     */
    where?: bank_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_mutasis to fetch.
     */
    orderBy?: bank_mutasiOrderByWithRelationInput | bank_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bank_mutasis.
     */
    cursor?: bank_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bank_mutasis.
     */
    distinct?: Bank_mutasiScalarFieldEnum | Bank_mutasiScalarFieldEnum[]
  }

  /**
   * bank_mutasi findMany
   */
  export type bank_mutasiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which bank_mutasis to fetch.
     */
    where?: bank_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bank_mutasis to fetch.
     */
    orderBy?: bank_mutasiOrderByWithRelationInput | bank_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bank_mutasis.
     */
    cursor?: bank_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bank_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bank_mutasis.
     */
    skip?: number
    distinct?: Bank_mutasiScalarFieldEnum | Bank_mutasiScalarFieldEnum[]
  }

  /**
   * bank_mutasi create
   */
  export type bank_mutasiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * The data needed to create a bank_mutasi.
     */
    data: XOR<bank_mutasiCreateInput, bank_mutasiUncheckedCreateInput>
  }

  /**
   * bank_mutasi createMany
   */
  export type bank_mutasiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bank_mutasis.
     */
    data: bank_mutasiCreateManyInput | bank_mutasiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank_mutasi update
   */
  export type bank_mutasiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * The data needed to update a bank_mutasi.
     */
    data: XOR<bank_mutasiUpdateInput, bank_mutasiUncheckedUpdateInput>
    /**
     * Choose, which bank_mutasi to update.
     */
    where: bank_mutasiWhereUniqueInput
  }

  /**
   * bank_mutasi updateMany
   */
  export type bank_mutasiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bank_mutasis.
     */
    data: XOR<bank_mutasiUpdateManyMutationInput, bank_mutasiUncheckedUpdateManyInput>
    /**
     * Filter which bank_mutasis to update
     */
    where?: bank_mutasiWhereInput
  }

  /**
   * bank_mutasi upsert
   */
  export type bank_mutasiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * The filter to search for the bank_mutasi to update in case it exists.
     */
    where: bank_mutasiWhereUniqueInput
    /**
     * In case the bank_mutasi found by the `where` argument doesn't exist, create a new bank_mutasi with this data.
     */
    create: XOR<bank_mutasiCreateInput, bank_mutasiUncheckedCreateInput>
    /**
     * In case the bank_mutasi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bank_mutasiUpdateInput, bank_mutasiUncheckedUpdateInput>
  }

  /**
   * bank_mutasi delete
   */
  export type bank_mutasiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
    /**
     * Filter which bank_mutasi to delete.
     */
    where: bank_mutasiWhereUniqueInput
  }

  /**
   * bank_mutasi deleteMany
   */
  export type bank_mutasiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank_mutasis to delete
     */
    where?: bank_mutasiWhereInput
  }

  /**
   * bank_mutasi without action
   */
  export type bank_mutasiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank_mutasi
     */
    select?: bank_mutasiSelect<ExtArgs> | null
  }


  /**
   * Model bayar
   */

  export type AggregateBayar = {
    _count: BayarCountAggregateOutputType | null
    _avg: BayarAvgAggregateOutputType | null
    _sum: BayarSumAggregateOutputType | null
    _min: BayarMinAggregateOutputType | null
    _max: BayarMaxAggregateOutputType | null
  }

  export type BayarAvgAggregateOutputType = {
    id: number | null
  }

  export type BayarSumAggregateOutputType = {
    id: number | null
  }

  export type BayarMinAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type BayarMaxAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type BayarCountAggregateOutputType = {
    id: number
    nama: number
    _all: number
  }


  export type BayarAvgAggregateInputType = {
    id?: true
  }

  export type BayarSumAggregateInputType = {
    id?: true
  }

  export type BayarMinAggregateInputType = {
    id?: true
    nama?: true
  }

  export type BayarMaxAggregateInputType = {
    id?: true
    nama?: true
  }

  export type BayarCountAggregateInputType = {
    id?: true
    nama?: true
    _all?: true
  }

  export type BayarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bayar to aggregate.
     */
    where?: bayarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bayars to fetch.
     */
    orderBy?: bayarOrderByWithRelationInput | bayarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bayarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bayars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bayars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bayars
    **/
    _count?: true | BayarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BayarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BayarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BayarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BayarMaxAggregateInputType
  }

  export type GetBayarAggregateType<T extends BayarAggregateArgs> = {
        [P in keyof T & keyof AggregateBayar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBayar[P]>
      : GetScalarType<T[P], AggregateBayar[P]>
  }




  export type bayarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bayarWhereInput
    orderBy?: bayarOrderByWithAggregationInput | bayarOrderByWithAggregationInput[]
    by: BayarScalarFieldEnum[] | BayarScalarFieldEnum
    having?: bayarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BayarCountAggregateInputType | true
    _avg?: BayarAvgAggregateInputType
    _sum?: BayarSumAggregateInputType
    _min?: BayarMinAggregateInputType
    _max?: BayarMaxAggregateInputType
  }

  export type BayarGroupByOutputType = {
    id: number
    nama: string
    _count: BayarCountAggregateOutputType | null
    _avg: BayarAvgAggregateOutputType | null
    _sum: BayarSumAggregateOutputType | null
    _min: BayarMinAggregateOutputType | null
    _max: BayarMaxAggregateOutputType | null
  }

  type GetBayarGroupByPayload<T extends bayarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BayarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BayarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BayarGroupByOutputType[P]>
            : GetScalarType<T[P], BayarGroupByOutputType[P]>
        }
      >
    >


  export type bayarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
  }, ExtArgs["result"]["bayar"]>


  export type bayarSelectScalar = {
    id?: boolean
    nama?: boolean
  }


  export type $bayarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bayar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
    }, ExtArgs["result"]["bayar"]>
    composites: {}
  }

  type bayarGetPayload<S extends boolean | null | undefined | bayarDefaultArgs> = $Result.GetResult<Prisma.$bayarPayload, S>

  type bayarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bayarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BayarCountAggregateInputType | true
    }

  export interface bayarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bayar'], meta: { name: 'bayar' } }
    /**
     * Find zero or one Bayar that matches the filter.
     * @param {bayarFindUniqueArgs} args - Arguments to find a Bayar
     * @example
     * // Get one Bayar
     * const bayar = await prisma.bayar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bayarFindUniqueArgs>(args: SelectSubset<T, bayarFindUniqueArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bayar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {bayarFindUniqueOrThrowArgs} args - Arguments to find a Bayar
     * @example
     * // Get one Bayar
     * const bayar = await prisma.bayar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bayarFindUniqueOrThrowArgs>(args: SelectSubset<T, bayarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bayar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarFindFirstArgs} args - Arguments to find a Bayar
     * @example
     * // Get one Bayar
     * const bayar = await prisma.bayar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bayarFindFirstArgs>(args?: SelectSubset<T, bayarFindFirstArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bayar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarFindFirstOrThrowArgs} args - Arguments to find a Bayar
     * @example
     * // Get one Bayar
     * const bayar = await prisma.bayar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bayarFindFirstOrThrowArgs>(args?: SelectSubset<T, bayarFindFirstOrThrowArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bayars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bayars
     * const bayars = await prisma.bayar.findMany()
     * 
     * // Get first 10 Bayars
     * const bayars = await prisma.bayar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bayarWithIdOnly = await prisma.bayar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bayarFindManyArgs>(args?: SelectSubset<T, bayarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bayar.
     * @param {bayarCreateArgs} args - Arguments to create a Bayar.
     * @example
     * // Create one Bayar
     * const Bayar = await prisma.bayar.create({
     *   data: {
     *     // ... data to create a Bayar
     *   }
     * })
     * 
     */
    create<T extends bayarCreateArgs>(args: SelectSubset<T, bayarCreateArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bayars.
     * @param {bayarCreateManyArgs} args - Arguments to create many Bayars.
     * @example
     * // Create many Bayars
     * const bayar = await prisma.bayar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bayarCreateManyArgs>(args?: SelectSubset<T, bayarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bayar.
     * @param {bayarDeleteArgs} args - Arguments to delete one Bayar.
     * @example
     * // Delete one Bayar
     * const Bayar = await prisma.bayar.delete({
     *   where: {
     *     // ... filter to delete one Bayar
     *   }
     * })
     * 
     */
    delete<T extends bayarDeleteArgs>(args: SelectSubset<T, bayarDeleteArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bayar.
     * @param {bayarUpdateArgs} args - Arguments to update one Bayar.
     * @example
     * // Update one Bayar
     * const bayar = await prisma.bayar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bayarUpdateArgs>(args: SelectSubset<T, bayarUpdateArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bayars.
     * @param {bayarDeleteManyArgs} args - Arguments to filter Bayars to delete.
     * @example
     * // Delete a few Bayars
     * const { count } = await prisma.bayar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bayarDeleteManyArgs>(args?: SelectSubset<T, bayarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bayars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bayars
     * const bayar = await prisma.bayar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bayarUpdateManyArgs>(args: SelectSubset<T, bayarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bayar.
     * @param {bayarUpsertArgs} args - Arguments to update or create a Bayar.
     * @example
     * // Update or create a Bayar
     * const bayar = await prisma.bayar.upsert({
     *   create: {
     *     // ... data to create a Bayar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bayar we want to update
     *   }
     * })
     */
    upsert<T extends bayarUpsertArgs>(args: SelectSubset<T, bayarUpsertArgs<ExtArgs>>): Prisma__bayarClient<$Result.GetResult<Prisma.$bayarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bayars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarCountArgs} args - Arguments to filter Bayars to count.
     * @example
     * // Count the number of Bayars
     * const count = await prisma.bayar.count({
     *   where: {
     *     // ... the filter for the Bayars we want to count
     *   }
     * })
    **/
    count<T extends bayarCountArgs>(
      args?: Subset<T, bayarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BayarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bayar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BayarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BayarAggregateArgs>(args: Subset<T, BayarAggregateArgs>): Prisma.PrismaPromise<GetBayarAggregateType<T>>

    /**
     * Group by Bayar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bayarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bayarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bayarGroupByArgs['orderBy'] }
        : { orderBy?: bayarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bayarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBayarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bayar model
   */
  readonly fields: bayarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bayar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bayarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bayar model
   */ 
  interface bayarFieldRefs {
    readonly id: FieldRef<"bayar", 'Int'>
    readonly nama: FieldRef<"bayar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bayar findUnique
   */
  export type bayarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter, which bayar to fetch.
     */
    where: bayarWhereUniqueInput
  }

  /**
   * bayar findUniqueOrThrow
   */
  export type bayarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter, which bayar to fetch.
     */
    where: bayarWhereUniqueInput
  }

  /**
   * bayar findFirst
   */
  export type bayarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter, which bayar to fetch.
     */
    where?: bayarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bayars to fetch.
     */
    orderBy?: bayarOrderByWithRelationInput | bayarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bayars.
     */
    cursor?: bayarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bayars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bayars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bayars.
     */
    distinct?: BayarScalarFieldEnum | BayarScalarFieldEnum[]
  }

  /**
   * bayar findFirstOrThrow
   */
  export type bayarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter, which bayar to fetch.
     */
    where?: bayarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bayars to fetch.
     */
    orderBy?: bayarOrderByWithRelationInput | bayarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bayars.
     */
    cursor?: bayarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bayars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bayars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bayars.
     */
    distinct?: BayarScalarFieldEnum | BayarScalarFieldEnum[]
  }

  /**
   * bayar findMany
   */
  export type bayarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter, which bayars to fetch.
     */
    where?: bayarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bayars to fetch.
     */
    orderBy?: bayarOrderByWithRelationInput | bayarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bayars.
     */
    cursor?: bayarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bayars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bayars.
     */
    skip?: number
    distinct?: BayarScalarFieldEnum | BayarScalarFieldEnum[]
  }

  /**
   * bayar create
   */
  export type bayarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * The data needed to create a bayar.
     */
    data: XOR<bayarCreateInput, bayarUncheckedCreateInput>
  }

  /**
   * bayar createMany
   */
  export type bayarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bayars.
     */
    data: bayarCreateManyInput | bayarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bayar update
   */
  export type bayarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * The data needed to update a bayar.
     */
    data: XOR<bayarUpdateInput, bayarUncheckedUpdateInput>
    /**
     * Choose, which bayar to update.
     */
    where: bayarWhereUniqueInput
  }

  /**
   * bayar updateMany
   */
  export type bayarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bayars.
     */
    data: XOR<bayarUpdateManyMutationInput, bayarUncheckedUpdateManyInput>
    /**
     * Filter which bayars to update
     */
    where?: bayarWhereInput
  }

  /**
   * bayar upsert
   */
  export type bayarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * The filter to search for the bayar to update in case it exists.
     */
    where: bayarWhereUniqueInput
    /**
     * In case the bayar found by the `where` argument doesn't exist, create a new bayar with this data.
     */
    create: XOR<bayarCreateInput, bayarUncheckedCreateInput>
    /**
     * In case the bayar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bayarUpdateInput, bayarUncheckedUpdateInput>
  }

  /**
   * bayar delete
   */
  export type bayarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
    /**
     * Filter which bayar to delete.
     */
    where: bayarWhereUniqueInput
  }

  /**
   * bayar deleteMany
   */
  export type bayarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bayars to delete
     */
    where?: bayarWhereInput
  }

  /**
   * bayar without action
   */
  export type bayarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bayar
     */
    select?: bayarSelect<ExtArgs> | null
  }


  /**
   * Model beban_operasional
   */

  export type AggregateBeban_operasional = {
    _count: Beban_operasionalCountAggregateOutputType | null
    _avg: Beban_operasionalAvgAggregateOutputType | null
    _sum: Beban_operasionalSumAggregateOutputType | null
    _min: Beban_operasionalMinAggregateOutputType | null
    _max: Beban_operasionalMaxAggregateOutputType | null
  }

  export type Beban_operasionalAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
  }

  export type Beban_operasionalSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
  }

  export type Beban_operasionalMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    keterangan: string | null
    jumlah: number | null
  }

  export type Beban_operasionalMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    keterangan: string | null
    jumlah: number | null
  }

  export type Beban_operasionalCountAggregateOutputType = {
    id: number
    tanggal: number
    keterangan: number
    jumlah: number
    _all: number
  }


  export type Beban_operasionalAvgAggregateInputType = {
    id?: true
    jumlah?: true
  }

  export type Beban_operasionalSumAggregateInputType = {
    id?: true
    jumlah?: true
  }

  export type Beban_operasionalMinAggregateInputType = {
    id?: true
    tanggal?: true
    keterangan?: true
    jumlah?: true
  }

  export type Beban_operasionalMaxAggregateInputType = {
    id?: true
    tanggal?: true
    keterangan?: true
    jumlah?: true
  }

  export type Beban_operasionalCountAggregateInputType = {
    id?: true
    tanggal?: true
    keterangan?: true
    jumlah?: true
    _all?: true
  }

  export type Beban_operasionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beban_operasional to aggregate.
     */
    where?: beban_operasionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beban_operasionals to fetch.
     */
    orderBy?: beban_operasionalOrderByWithRelationInput | beban_operasionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: beban_operasionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beban_operasionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beban_operasionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beban_operasionals
    **/
    _count?: true | Beban_operasionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Beban_operasionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Beban_operasionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Beban_operasionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Beban_operasionalMaxAggregateInputType
  }

  export type GetBeban_operasionalAggregateType<T extends Beban_operasionalAggregateArgs> = {
        [P in keyof T & keyof AggregateBeban_operasional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeban_operasional[P]>
      : GetScalarType<T[P], AggregateBeban_operasional[P]>
  }




  export type beban_operasionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beban_operasionalWhereInput
    orderBy?: beban_operasionalOrderByWithAggregationInput | beban_operasionalOrderByWithAggregationInput[]
    by: Beban_operasionalScalarFieldEnum[] | Beban_operasionalScalarFieldEnum
    having?: beban_operasionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Beban_operasionalCountAggregateInputType | true
    _avg?: Beban_operasionalAvgAggregateInputType
    _sum?: Beban_operasionalSumAggregateInputType
    _min?: Beban_operasionalMinAggregateInputType
    _max?: Beban_operasionalMaxAggregateInputType
  }

  export type Beban_operasionalGroupByOutputType = {
    id: number
    tanggal: Date | null
    keterangan: string
    jumlah: number
    _count: Beban_operasionalCountAggregateOutputType | null
    _avg: Beban_operasionalAvgAggregateOutputType | null
    _sum: Beban_operasionalSumAggregateOutputType | null
    _min: Beban_operasionalMinAggregateOutputType | null
    _max: Beban_operasionalMaxAggregateOutputType | null
  }

  type GetBeban_operasionalGroupByPayload<T extends beban_operasionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Beban_operasionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Beban_operasionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Beban_operasionalGroupByOutputType[P]>
            : GetScalarType<T[P], Beban_operasionalGroupByOutputType[P]>
        }
      >
    >


  export type beban_operasionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    keterangan?: boolean
    jumlah?: boolean
  }, ExtArgs["result"]["beban_operasional"]>


  export type beban_operasionalSelectScalar = {
    id?: boolean
    tanggal?: boolean
    keterangan?: boolean
    jumlah?: boolean
  }


  export type $beban_operasionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "beban_operasional"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date | null
      keterangan: string
      jumlah: number
    }, ExtArgs["result"]["beban_operasional"]>
    composites: {}
  }

  type beban_operasionalGetPayload<S extends boolean | null | undefined | beban_operasionalDefaultArgs> = $Result.GetResult<Prisma.$beban_operasionalPayload, S>

  type beban_operasionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<beban_operasionalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Beban_operasionalCountAggregateInputType | true
    }

  export interface beban_operasionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['beban_operasional'], meta: { name: 'beban_operasional' } }
    /**
     * Find zero or one Beban_operasional that matches the filter.
     * @param {beban_operasionalFindUniqueArgs} args - Arguments to find a Beban_operasional
     * @example
     * // Get one Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends beban_operasionalFindUniqueArgs>(args: SelectSubset<T, beban_operasionalFindUniqueArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Beban_operasional that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {beban_operasionalFindUniqueOrThrowArgs} args - Arguments to find a Beban_operasional
     * @example
     * // Get one Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends beban_operasionalFindUniqueOrThrowArgs>(args: SelectSubset<T, beban_operasionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Beban_operasional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalFindFirstArgs} args - Arguments to find a Beban_operasional
     * @example
     * // Get one Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends beban_operasionalFindFirstArgs>(args?: SelectSubset<T, beban_operasionalFindFirstArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Beban_operasional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalFindFirstOrThrowArgs} args - Arguments to find a Beban_operasional
     * @example
     * // Get one Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends beban_operasionalFindFirstOrThrowArgs>(args?: SelectSubset<T, beban_operasionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beban_operasionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beban_operasionals
     * const beban_operasionals = await prisma.beban_operasional.findMany()
     * 
     * // Get first 10 Beban_operasionals
     * const beban_operasionals = await prisma.beban_operasional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beban_operasionalWithIdOnly = await prisma.beban_operasional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends beban_operasionalFindManyArgs>(args?: SelectSubset<T, beban_operasionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Beban_operasional.
     * @param {beban_operasionalCreateArgs} args - Arguments to create a Beban_operasional.
     * @example
     * // Create one Beban_operasional
     * const Beban_operasional = await prisma.beban_operasional.create({
     *   data: {
     *     // ... data to create a Beban_operasional
     *   }
     * })
     * 
     */
    create<T extends beban_operasionalCreateArgs>(args: SelectSubset<T, beban_operasionalCreateArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beban_operasionals.
     * @param {beban_operasionalCreateManyArgs} args - Arguments to create many Beban_operasionals.
     * @example
     * // Create many Beban_operasionals
     * const beban_operasional = await prisma.beban_operasional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends beban_operasionalCreateManyArgs>(args?: SelectSubset<T, beban_operasionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Beban_operasional.
     * @param {beban_operasionalDeleteArgs} args - Arguments to delete one Beban_operasional.
     * @example
     * // Delete one Beban_operasional
     * const Beban_operasional = await prisma.beban_operasional.delete({
     *   where: {
     *     // ... filter to delete one Beban_operasional
     *   }
     * })
     * 
     */
    delete<T extends beban_operasionalDeleteArgs>(args: SelectSubset<T, beban_operasionalDeleteArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Beban_operasional.
     * @param {beban_operasionalUpdateArgs} args - Arguments to update one Beban_operasional.
     * @example
     * // Update one Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends beban_operasionalUpdateArgs>(args: SelectSubset<T, beban_operasionalUpdateArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beban_operasionals.
     * @param {beban_operasionalDeleteManyArgs} args - Arguments to filter Beban_operasionals to delete.
     * @example
     * // Delete a few Beban_operasionals
     * const { count } = await prisma.beban_operasional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends beban_operasionalDeleteManyArgs>(args?: SelectSubset<T, beban_operasionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beban_operasionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beban_operasionals
     * const beban_operasional = await prisma.beban_operasional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends beban_operasionalUpdateManyArgs>(args: SelectSubset<T, beban_operasionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Beban_operasional.
     * @param {beban_operasionalUpsertArgs} args - Arguments to update or create a Beban_operasional.
     * @example
     * // Update or create a Beban_operasional
     * const beban_operasional = await prisma.beban_operasional.upsert({
     *   create: {
     *     // ... data to create a Beban_operasional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Beban_operasional we want to update
     *   }
     * })
     */
    upsert<T extends beban_operasionalUpsertArgs>(args: SelectSubset<T, beban_operasionalUpsertArgs<ExtArgs>>): Prisma__beban_operasionalClient<$Result.GetResult<Prisma.$beban_operasionalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Beban_operasionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalCountArgs} args - Arguments to filter Beban_operasionals to count.
     * @example
     * // Count the number of Beban_operasionals
     * const count = await prisma.beban_operasional.count({
     *   where: {
     *     // ... the filter for the Beban_operasionals we want to count
     *   }
     * })
    **/
    count<T extends beban_operasionalCountArgs>(
      args?: Subset<T, beban_operasionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Beban_operasionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Beban_operasional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Beban_operasionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Beban_operasionalAggregateArgs>(args: Subset<T, Beban_operasionalAggregateArgs>): Prisma.PrismaPromise<GetBeban_operasionalAggregateType<T>>

    /**
     * Group by Beban_operasional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beban_operasionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends beban_operasionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: beban_operasionalGroupByArgs['orderBy'] }
        : { orderBy?: beban_operasionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, beban_operasionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeban_operasionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the beban_operasional model
   */
  readonly fields: beban_operasionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for beban_operasional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__beban_operasionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the beban_operasional model
   */ 
  interface beban_operasionalFieldRefs {
    readonly id: FieldRef<"beban_operasional", 'Int'>
    readonly tanggal: FieldRef<"beban_operasional", 'DateTime'>
    readonly keterangan: FieldRef<"beban_operasional", 'String'>
    readonly jumlah: FieldRef<"beban_operasional", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * beban_operasional findUnique
   */
  export type beban_operasionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter, which beban_operasional to fetch.
     */
    where: beban_operasionalWhereUniqueInput
  }

  /**
   * beban_operasional findUniqueOrThrow
   */
  export type beban_operasionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter, which beban_operasional to fetch.
     */
    where: beban_operasionalWhereUniqueInput
  }

  /**
   * beban_operasional findFirst
   */
  export type beban_operasionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter, which beban_operasional to fetch.
     */
    where?: beban_operasionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beban_operasionals to fetch.
     */
    orderBy?: beban_operasionalOrderByWithRelationInput | beban_operasionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beban_operasionals.
     */
    cursor?: beban_operasionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beban_operasionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beban_operasionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beban_operasionals.
     */
    distinct?: Beban_operasionalScalarFieldEnum | Beban_operasionalScalarFieldEnum[]
  }

  /**
   * beban_operasional findFirstOrThrow
   */
  export type beban_operasionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter, which beban_operasional to fetch.
     */
    where?: beban_operasionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beban_operasionals to fetch.
     */
    orderBy?: beban_operasionalOrderByWithRelationInput | beban_operasionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beban_operasionals.
     */
    cursor?: beban_operasionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beban_operasionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beban_operasionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beban_operasionals.
     */
    distinct?: Beban_operasionalScalarFieldEnum | Beban_operasionalScalarFieldEnum[]
  }

  /**
   * beban_operasional findMany
   */
  export type beban_operasionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter, which beban_operasionals to fetch.
     */
    where?: beban_operasionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beban_operasionals to fetch.
     */
    orderBy?: beban_operasionalOrderByWithRelationInput | beban_operasionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beban_operasionals.
     */
    cursor?: beban_operasionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beban_operasionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beban_operasionals.
     */
    skip?: number
    distinct?: Beban_operasionalScalarFieldEnum | Beban_operasionalScalarFieldEnum[]
  }

  /**
   * beban_operasional create
   */
  export type beban_operasionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * The data needed to create a beban_operasional.
     */
    data: XOR<beban_operasionalCreateInput, beban_operasionalUncheckedCreateInput>
  }

  /**
   * beban_operasional createMany
   */
  export type beban_operasionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many beban_operasionals.
     */
    data: beban_operasionalCreateManyInput | beban_operasionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * beban_operasional update
   */
  export type beban_operasionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * The data needed to update a beban_operasional.
     */
    data: XOR<beban_operasionalUpdateInput, beban_operasionalUncheckedUpdateInput>
    /**
     * Choose, which beban_operasional to update.
     */
    where: beban_operasionalWhereUniqueInput
  }

  /**
   * beban_operasional updateMany
   */
  export type beban_operasionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update beban_operasionals.
     */
    data: XOR<beban_operasionalUpdateManyMutationInput, beban_operasionalUncheckedUpdateManyInput>
    /**
     * Filter which beban_operasionals to update
     */
    where?: beban_operasionalWhereInput
  }

  /**
   * beban_operasional upsert
   */
  export type beban_operasionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * The filter to search for the beban_operasional to update in case it exists.
     */
    where: beban_operasionalWhereUniqueInput
    /**
     * In case the beban_operasional found by the `where` argument doesn't exist, create a new beban_operasional with this data.
     */
    create: XOR<beban_operasionalCreateInput, beban_operasionalUncheckedCreateInput>
    /**
     * In case the beban_operasional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<beban_operasionalUpdateInput, beban_operasionalUncheckedUpdateInput>
  }

  /**
   * beban_operasional delete
   */
  export type beban_operasionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
    /**
     * Filter which beban_operasional to delete.
     */
    where: beban_operasionalWhereUniqueInput
  }

  /**
   * beban_operasional deleteMany
   */
  export type beban_operasionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beban_operasionals to delete
     */
    where?: beban_operasionalWhereInput
  }

  /**
   * beban_operasional without action
   */
  export type beban_operasionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beban_operasional
     */
    select?: beban_operasionalSelect<ExtArgs> | null
  }


  /**
   * Model cash_in_out
   */

  export type AggregateCash_in_out = {
    _count: Cash_in_outCountAggregateOutputType | null
    _avg: Cash_in_outAvgAggregateOutputType | null
    _sum: Cash_in_outSumAggregateOutputType | null
    _min: Cash_in_outMinAggregateOutputType | null
    _max: Cash_in_outMaxAggregateOutputType | null
  }

  export type Cash_in_outAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    detail: number | null
    input: Decimal | null
    output: Decimal | null
  }

  export type Cash_in_outSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    detail: number | null
    input: Decimal | null
    output: Decimal | null
  }

  export type Cash_in_outMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jenis: number | null
    detail: number | null
    input: Decimal | null
    output: Decimal | null
    keterangan: string | null
  }

  export type Cash_in_outMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jenis: number | null
    detail: number | null
    input: Decimal | null
    output: Decimal | null
    keterangan: string | null
  }

  export type Cash_in_outCountAggregateOutputType = {
    id: number
    tanggal: number
    jenis: number
    detail: number
    input: number
    output: number
    keterangan: number
    _all: number
  }


  export type Cash_in_outAvgAggregateInputType = {
    id?: true
    jenis?: true
    detail?: true
    input?: true
    output?: true
  }

  export type Cash_in_outSumAggregateInputType = {
    id?: true
    jenis?: true
    detail?: true
    input?: true
    output?: true
  }

  export type Cash_in_outMinAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    detail?: true
    input?: true
    output?: true
    keterangan?: true
  }

  export type Cash_in_outMaxAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    detail?: true
    input?: true
    output?: true
    keterangan?: true
  }

  export type Cash_in_outCountAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    detail?: true
    input?: true
    output?: true
    keterangan?: true
    _all?: true
  }

  export type Cash_in_outAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_in_out to aggregate.
     */
    where?: cash_in_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_in_outs to fetch.
     */
    orderBy?: cash_in_outOrderByWithRelationInput | cash_in_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cash_in_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_in_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_in_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cash_in_outs
    **/
    _count?: true | Cash_in_outCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cash_in_outAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cash_in_outSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cash_in_outMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cash_in_outMaxAggregateInputType
  }

  export type GetCash_in_outAggregateType<T extends Cash_in_outAggregateArgs> = {
        [P in keyof T & keyof AggregateCash_in_out]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCash_in_out[P]>
      : GetScalarType<T[P], AggregateCash_in_out[P]>
  }




  export type cash_in_outGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cash_in_outWhereInput
    orderBy?: cash_in_outOrderByWithAggregationInput | cash_in_outOrderByWithAggregationInput[]
    by: Cash_in_outScalarFieldEnum[] | Cash_in_outScalarFieldEnum
    having?: cash_in_outScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cash_in_outCountAggregateInputType | true
    _avg?: Cash_in_outAvgAggregateInputType
    _sum?: Cash_in_outSumAggregateInputType
    _min?: Cash_in_outMinAggregateInputType
    _max?: Cash_in_outMaxAggregateInputType
  }

  export type Cash_in_outGroupByOutputType = {
    id: number
    tanggal: Date
    jenis: number
    detail: number
    input: Decimal
    output: Decimal
    keterangan: string
    _count: Cash_in_outCountAggregateOutputType | null
    _avg: Cash_in_outAvgAggregateOutputType | null
    _sum: Cash_in_outSumAggregateOutputType | null
    _min: Cash_in_outMinAggregateOutputType | null
    _max: Cash_in_outMaxAggregateOutputType | null
  }

  type GetCash_in_outGroupByPayload<T extends cash_in_outGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cash_in_outGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cash_in_outGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cash_in_outGroupByOutputType[P]>
            : GetScalarType<T[P], Cash_in_outGroupByOutputType[P]>
        }
      >
    >


  export type cash_in_outSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    jenis?: boolean
    detail?: boolean
    input?: boolean
    output?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["cash_in_out"]>


  export type cash_in_outSelectScalar = {
    id?: boolean
    tanggal?: boolean
    jenis?: boolean
    detail?: boolean
    input?: boolean
    output?: boolean
    keterangan?: boolean
  }


  export type $cash_in_outPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cash_in_out"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      jenis: number
      detail: number
      input: Prisma.Decimal
      output: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["cash_in_out"]>
    composites: {}
  }

  type cash_in_outGetPayload<S extends boolean | null | undefined | cash_in_outDefaultArgs> = $Result.GetResult<Prisma.$cash_in_outPayload, S>

  type cash_in_outCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cash_in_outFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cash_in_outCountAggregateInputType | true
    }

  export interface cash_in_outDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cash_in_out'], meta: { name: 'cash_in_out' } }
    /**
     * Find zero or one Cash_in_out that matches the filter.
     * @param {cash_in_outFindUniqueArgs} args - Arguments to find a Cash_in_out
     * @example
     * // Get one Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cash_in_outFindUniqueArgs>(args: SelectSubset<T, cash_in_outFindUniqueArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cash_in_out that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cash_in_outFindUniqueOrThrowArgs} args - Arguments to find a Cash_in_out
     * @example
     * // Get one Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cash_in_outFindUniqueOrThrowArgs>(args: SelectSubset<T, cash_in_outFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cash_in_out that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outFindFirstArgs} args - Arguments to find a Cash_in_out
     * @example
     * // Get one Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cash_in_outFindFirstArgs>(args?: SelectSubset<T, cash_in_outFindFirstArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cash_in_out that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outFindFirstOrThrowArgs} args - Arguments to find a Cash_in_out
     * @example
     * // Get one Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cash_in_outFindFirstOrThrowArgs>(args?: SelectSubset<T, cash_in_outFindFirstOrThrowArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cash_in_outs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cash_in_outs
     * const cash_in_outs = await prisma.cash_in_out.findMany()
     * 
     * // Get first 10 Cash_in_outs
     * const cash_in_outs = await prisma.cash_in_out.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cash_in_outWithIdOnly = await prisma.cash_in_out.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cash_in_outFindManyArgs>(args?: SelectSubset<T, cash_in_outFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cash_in_out.
     * @param {cash_in_outCreateArgs} args - Arguments to create a Cash_in_out.
     * @example
     * // Create one Cash_in_out
     * const Cash_in_out = await prisma.cash_in_out.create({
     *   data: {
     *     // ... data to create a Cash_in_out
     *   }
     * })
     * 
     */
    create<T extends cash_in_outCreateArgs>(args: SelectSubset<T, cash_in_outCreateArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cash_in_outs.
     * @param {cash_in_outCreateManyArgs} args - Arguments to create many Cash_in_outs.
     * @example
     * // Create many Cash_in_outs
     * const cash_in_out = await prisma.cash_in_out.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cash_in_outCreateManyArgs>(args?: SelectSubset<T, cash_in_outCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cash_in_out.
     * @param {cash_in_outDeleteArgs} args - Arguments to delete one Cash_in_out.
     * @example
     * // Delete one Cash_in_out
     * const Cash_in_out = await prisma.cash_in_out.delete({
     *   where: {
     *     // ... filter to delete one Cash_in_out
     *   }
     * })
     * 
     */
    delete<T extends cash_in_outDeleteArgs>(args: SelectSubset<T, cash_in_outDeleteArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cash_in_out.
     * @param {cash_in_outUpdateArgs} args - Arguments to update one Cash_in_out.
     * @example
     * // Update one Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cash_in_outUpdateArgs>(args: SelectSubset<T, cash_in_outUpdateArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cash_in_outs.
     * @param {cash_in_outDeleteManyArgs} args - Arguments to filter Cash_in_outs to delete.
     * @example
     * // Delete a few Cash_in_outs
     * const { count } = await prisma.cash_in_out.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cash_in_outDeleteManyArgs>(args?: SelectSubset<T, cash_in_outDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cash_in_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cash_in_outs
     * const cash_in_out = await prisma.cash_in_out.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cash_in_outUpdateManyArgs>(args: SelectSubset<T, cash_in_outUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cash_in_out.
     * @param {cash_in_outUpsertArgs} args - Arguments to update or create a Cash_in_out.
     * @example
     * // Update or create a Cash_in_out
     * const cash_in_out = await prisma.cash_in_out.upsert({
     *   create: {
     *     // ... data to create a Cash_in_out
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cash_in_out we want to update
     *   }
     * })
     */
    upsert<T extends cash_in_outUpsertArgs>(args: SelectSubset<T, cash_in_outUpsertArgs<ExtArgs>>): Prisma__cash_in_outClient<$Result.GetResult<Prisma.$cash_in_outPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cash_in_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outCountArgs} args - Arguments to filter Cash_in_outs to count.
     * @example
     * // Count the number of Cash_in_outs
     * const count = await prisma.cash_in_out.count({
     *   where: {
     *     // ... the filter for the Cash_in_outs we want to count
     *   }
     * })
    **/
    count<T extends cash_in_outCountArgs>(
      args?: Subset<T, cash_in_outCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cash_in_outCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cash_in_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cash_in_outAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cash_in_outAggregateArgs>(args: Subset<T, Cash_in_outAggregateArgs>): Prisma.PrismaPromise<GetCash_in_outAggregateType<T>>

    /**
     * Group by Cash_in_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_in_outGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cash_in_outGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cash_in_outGroupByArgs['orderBy'] }
        : { orderBy?: cash_in_outGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cash_in_outGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCash_in_outGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cash_in_out model
   */
  readonly fields: cash_in_outFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cash_in_out.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cash_in_outClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cash_in_out model
   */ 
  interface cash_in_outFieldRefs {
    readonly id: FieldRef<"cash_in_out", 'Int'>
    readonly tanggal: FieldRef<"cash_in_out", 'DateTime'>
    readonly jenis: FieldRef<"cash_in_out", 'Int'>
    readonly detail: FieldRef<"cash_in_out", 'Int'>
    readonly input: FieldRef<"cash_in_out", 'Decimal'>
    readonly output: FieldRef<"cash_in_out", 'Decimal'>
    readonly keterangan: FieldRef<"cash_in_out", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cash_in_out findUnique
   */
  export type cash_in_outFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter, which cash_in_out to fetch.
     */
    where: cash_in_outWhereUniqueInput
  }

  /**
   * cash_in_out findUniqueOrThrow
   */
  export type cash_in_outFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter, which cash_in_out to fetch.
     */
    where: cash_in_outWhereUniqueInput
  }

  /**
   * cash_in_out findFirst
   */
  export type cash_in_outFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter, which cash_in_out to fetch.
     */
    where?: cash_in_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_in_outs to fetch.
     */
    orderBy?: cash_in_outOrderByWithRelationInput | cash_in_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_in_outs.
     */
    cursor?: cash_in_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_in_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_in_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_in_outs.
     */
    distinct?: Cash_in_outScalarFieldEnum | Cash_in_outScalarFieldEnum[]
  }

  /**
   * cash_in_out findFirstOrThrow
   */
  export type cash_in_outFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter, which cash_in_out to fetch.
     */
    where?: cash_in_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_in_outs to fetch.
     */
    orderBy?: cash_in_outOrderByWithRelationInput | cash_in_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_in_outs.
     */
    cursor?: cash_in_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_in_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_in_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_in_outs.
     */
    distinct?: Cash_in_outScalarFieldEnum | Cash_in_outScalarFieldEnum[]
  }

  /**
   * cash_in_out findMany
   */
  export type cash_in_outFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter, which cash_in_outs to fetch.
     */
    where?: cash_in_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_in_outs to fetch.
     */
    orderBy?: cash_in_outOrderByWithRelationInput | cash_in_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cash_in_outs.
     */
    cursor?: cash_in_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_in_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_in_outs.
     */
    skip?: number
    distinct?: Cash_in_outScalarFieldEnum | Cash_in_outScalarFieldEnum[]
  }

  /**
   * cash_in_out create
   */
  export type cash_in_outCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * The data needed to create a cash_in_out.
     */
    data: XOR<cash_in_outCreateInput, cash_in_outUncheckedCreateInput>
  }

  /**
   * cash_in_out createMany
   */
  export type cash_in_outCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cash_in_outs.
     */
    data: cash_in_outCreateManyInput | cash_in_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cash_in_out update
   */
  export type cash_in_outUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * The data needed to update a cash_in_out.
     */
    data: XOR<cash_in_outUpdateInput, cash_in_outUncheckedUpdateInput>
    /**
     * Choose, which cash_in_out to update.
     */
    where: cash_in_outWhereUniqueInput
  }

  /**
   * cash_in_out updateMany
   */
  export type cash_in_outUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cash_in_outs.
     */
    data: XOR<cash_in_outUpdateManyMutationInput, cash_in_outUncheckedUpdateManyInput>
    /**
     * Filter which cash_in_outs to update
     */
    where?: cash_in_outWhereInput
  }

  /**
   * cash_in_out upsert
   */
  export type cash_in_outUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * The filter to search for the cash_in_out to update in case it exists.
     */
    where: cash_in_outWhereUniqueInput
    /**
     * In case the cash_in_out found by the `where` argument doesn't exist, create a new cash_in_out with this data.
     */
    create: XOR<cash_in_outCreateInput, cash_in_outUncheckedCreateInput>
    /**
     * In case the cash_in_out was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cash_in_outUpdateInput, cash_in_outUncheckedUpdateInput>
  }

  /**
   * cash_in_out delete
   */
  export type cash_in_outDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
    /**
     * Filter which cash_in_out to delete.
     */
    where: cash_in_outWhereUniqueInput
  }

  /**
   * cash_in_out deleteMany
   */
  export type cash_in_outDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_in_outs to delete
     */
    where?: cash_in_outWhereInput
  }

  /**
   * cash_in_out without action
   */
  export type cash_in_outDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_in_out
     */
    select?: cash_in_outSelect<ExtArgs> | null
  }


  /**
   * Model cash_jenis
   */

  export type AggregateCash_jenis = {
    _count: Cash_jenisCountAggregateOutputType | null
    _avg: Cash_jenisAvgAggregateOutputType | null
    _sum: Cash_jenisSumAggregateOutputType | null
    _min: Cash_jenisMinAggregateOutputType | null
    _max: Cash_jenisMaxAggregateOutputType | null
  }

  export type Cash_jenisAvgAggregateOutputType = {
    id: number | null
    parent: number | null
    nilai: number | null
  }

  export type Cash_jenisSumAggregateOutputType = {
    id: number | null
    parent: number | null
    nilai: number | null
  }

  export type Cash_jenisMinAggregateOutputType = {
    id: number | null
    parent: number | null
    nama: string | null
    nilai: number | null
  }

  export type Cash_jenisMaxAggregateOutputType = {
    id: number | null
    parent: number | null
    nama: string | null
    nilai: number | null
  }

  export type Cash_jenisCountAggregateOutputType = {
    id: number
    parent: number
    nama: number
    nilai: number
    _all: number
  }


  export type Cash_jenisAvgAggregateInputType = {
    id?: true
    parent?: true
    nilai?: true
  }

  export type Cash_jenisSumAggregateInputType = {
    id?: true
    parent?: true
    nilai?: true
  }

  export type Cash_jenisMinAggregateInputType = {
    id?: true
    parent?: true
    nama?: true
    nilai?: true
  }

  export type Cash_jenisMaxAggregateInputType = {
    id?: true
    parent?: true
    nama?: true
    nilai?: true
  }

  export type Cash_jenisCountAggregateInputType = {
    id?: true
    parent?: true
    nama?: true
    nilai?: true
    _all?: true
  }

  export type Cash_jenisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_jenis to aggregate.
     */
    where?: cash_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_jenis to fetch.
     */
    orderBy?: cash_jenisOrderByWithRelationInput | cash_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cash_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cash_jenis
    **/
    _count?: true | Cash_jenisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cash_jenisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cash_jenisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cash_jenisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cash_jenisMaxAggregateInputType
  }

  export type GetCash_jenisAggregateType<T extends Cash_jenisAggregateArgs> = {
        [P in keyof T & keyof AggregateCash_jenis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCash_jenis[P]>
      : GetScalarType<T[P], AggregateCash_jenis[P]>
  }




  export type cash_jenisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cash_jenisWhereInput
    orderBy?: cash_jenisOrderByWithAggregationInput | cash_jenisOrderByWithAggregationInput[]
    by: Cash_jenisScalarFieldEnum[] | Cash_jenisScalarFieldEnum
    having?: cash_jenisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cash_jenisCountAggregateInputType | true
    _avg?: Cash_jenisAvgAggregateInputType
    _sum?: Cash_jenisSumAggregateInputType
    _min?: Cash_jenisMinAggregateInputType
    _max?: Cash_jenisMaxAggregateInputType
  }

  export type Cash_jenisGroupByOutputType = {
    id: number
    parent: number
    nama: string
    nilai: number
    _count: Cash_jenisCountAggregateOutputType | null
    _avg: Cash_jenisAvgAggregateOutputType | null
    _sum: Cash_jenisSumAggregateOutputType | null
    _min: Cash_jenisMinAggregateOutputType | null
    _max: Cash_jenisMaxAggregateOutputType | null
  }

  type GetCash_jenisGroupByPayload<T extends cash_jenisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cash_jenisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cash_jenisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cash_jenisGroupByOutputType[P]>
            : GetScalarType<T[P], Cash_jenisGroupByOutputType[P]>
        }
      >
    >


  export type cash_jenisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent?: boolean
    nama?: boolean
    nilai?: boolean
  }, ExtArgs["result"]["cash_jenis"]>


  export type cash_jenisSelectScalar = {
    id?: boolean
    parent?: boolean
    nama?: boolean
    nilai?: boolean
  }


  export type $cash_jenisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cash_jenis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parent: number
      nama: string
      nilai: number
    }, ExtArgs["result"]["cash_jenis"]>
    composites: {}
  }

  type cash_jenisGetPayload<S extends boolean | null | undefined | cash_jenisDefaultArgs> = $Result.GetResult<Prisma.$cash_jenisPayload, S>

  type cash_jenisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cash_jenisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Cash_jenisCountAggregateInputType | true
    }

  export interface cash_jenisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cash_jenis'], meta: { name: 'cash_jenis' } }
    /**
     * Find zero or one Cash_jenis that matches the filter.
     * @param {cash_jenisFindUniqueArgs} args - Arguments to find a Cash_jenis
     * @example
     * // Get one Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cash_jenisFindUniqueArgs>(args: SelectSubset<T, cash_jenisFindUniqueArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cash_jenis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cash_jenisFindUniqueOrThrowArgs} args - Arguments to find a Cash_jenis
     * @example
     * // Get one Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cash_jenisFindUniqueOrThrowArgs>(args: SelectSubset<T, cash_jenisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cash_jenis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisFindFirstArgs} args - Arguments to find a Cash_jenis
     * @example
     * // Get one Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cash_jenisFindFirstArgs>(args?: SelectSubset<T, cash_jenisFindFirstArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cash_jenis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisFindFirstOrThrowArgs} args - Arguments to find a Cash_jenis
     * @example
     * // Get one Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cash_jenisFindFirstOrThrowArgs>(args?: SelectSubset<T, cash_jenisFindFirstOrThrowArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cash_jenis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findMany()
     * 
     * // Get first 10 Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cash_jenisWithIdOnly = await prisma.cash_jenis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cash_jenisFindManyArgs>(args?: SelectSubset<T, cash_jenisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cash_jenis.
     * @param {cash_jenisCreateArgs} args - Arguments to create a Cash_jenis.
     * @example
     * // Create one Cash_jenis
     * const Cash_jenis = await prisma.cash_jenis.create({
     *   data: {
     *     // ... data to create a Cash_jenis
     *   }
     * })
     * 
     */
    create<T extends cash_jenisCreateArgs>(args: SelectSubset<T, cash_jenisCreateArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cash_jenis.
     * @param {cash_jenisCreateManyArgs} args - Arguments to create many Cash_jenis.
     * @example
     * // Create many Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cash_jenisCreateManyArgs>(args?: SelectSubset<T, cash_jenisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cash_jenis.
     * @param {cash_jenisDeleteArgs} args - Arguments to delete one Cash_jenis.
     * @example
     * // Delete one Cash_jenis
     * const Cash_jenis = await prisma.cash_jenis.delete({
     *   where: {
     *     // ... filter to delete one Cash_jenis
     *   }
     * })
     * 
     */
    delete<T extends cash_jenisDeleteArgs>(args: SelectSubset<T, cash_jenisDeleteArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cash_jenis.
     * @param {cash_jenisUpdateArgs} args - Arguments to update one Cash_jenis.
     * @example
     * // Update one Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cash_jenisUpdateArgs>(args: SelectSubset<T, cash_jenisUpdateArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cash_jenis.
     * @param {cash_jenisDeleteManyArgs} args - Arguments to filter Cash_jenis to delete.
     * @example
     * // Delete a few Cash_jenis
     * const { count } = await prisma.cash_jenis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cash_jenisDeleteManyArgs>(args?: SelectSubset<T, cash_jenisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cash_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cash_jenisUpdateManyArgs>(args: SelectSubset<T, cash_jenisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cash_jenis.
     * @param {cash_jenisUpsertArgs} args - Arguments to update or create a Cash_jenis.
     * @example
     * // Update or create a Cash_jenis
     * const cash_jenis = await prisma.cash_jenis.upsert({
     *   create: {
     *     // ... data to create a Cash_jenis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cash_jenis we want to update
     *   }
     * })
     */
    upsert<T extends cash_jenisUpsertArgs>(args: SelectSubset<T, cash_jenisUpsertArgs<ExtArgs>>): Prisma__cash_jenisClient<$Result.GetResult<Prisma.$cash_jenisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cash_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisCountArgs} args - Arguments to filter Cash_jenis to count.
     * @example
     * // Count the number of Cash_jenis
     * const count = await prisma.cash_jenis.count({
     *   where: {
     *     // ... the filter for the Cash_jenis we want to count
     *   }
     * })
    **/
    count<T extends cash_jenisCountArgs>(
      args?: Subset<T, cash_jenisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cash_jenisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cash_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cash_jenisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cash_jenisAggregateArgs>(args: Subset<T, Cash_jenisAggregateArgs>): Prisma.PrismaPromise<GetCash_jenisAggregateType<T>>

    /**
     * Group by Cash_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cash_jenisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cash_jenisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cash_jenisGroupByArgs['orderBy'] }
        : { orderBy?: cash_jenisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cash_jenisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCash_jenisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cash_jenis model
   */
  readonly fields: cash_jenisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cash_jenis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cash_jenisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cash_jenis model
   */ 
  interface cash_jenisFieldRefs {
    readonly id: FieldRef<"cash_jenis", 'Int'>
    readonly parent: FieldRef<"cash_jenis", 'Int'>
    readonly nama: FieldRef<"cash_jenis", 'String'>
    readonly nilai: FieldRef<"cash_jenis", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cash_jenis findUnique
   */
  export type cash_jenisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter, which cash_jenis to fetch.
     */
    where: cash_jenisWhereUniqueInput
  }

  /**
   * cash_jenis findUniqueOrThrow
   */
  export type cash_jenisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter, which cash_jenis to fetch.
     */
    where: cash_jenisWhereUniqueInput
  }

  /**
   * cash_jenis findFirst
   */
  export type cash_jenisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter, which cash_jenis to fetch.
     */
    where?: cash_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_jenis to fetch.
     */
    orderBy?: cash_jenisOrderByWithRelationInput | cash_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_jenis.
     */
    cursor?: cash_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_jenis.
     */
    distinct?: Cash_jenisScalarFieldEnum | Cash_jenisScalarFieldEnum[]
  }

  /**
   * cash_jenis findFirstOrThrow
   */
  export type cash_jenisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter, which cash_jenis to fetch.
     */
    where?: cash_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_jenis to fetch.
     */
    orderBy?: cash_jenisOrderByWithRelationInput | cash_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cash_jenis.
     */
    cursor?: cash_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cash_jenis.
     */
    distinct?: Cash_jenisScalarFieldEnum | Cash_jenisScalarFieldEnum[]
  }

  /**
   * cash_jenis findMany
   */
  export type cash_jenisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter, which cash_jenis to fetch.
     */
    where?: cash_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cash_jenis to fetch.
     */
    orderBy?: cash_jenisOrderByWithRelationInput | cash_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cash_jenis.
     */
    cursor?: cash_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cash_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cash_jenis.
     */
    skip?: number
    distinct?: Cash_jenisScalarFieldEnum | Cash_jenisScalarFieldEnum[]
  }

  /**
   * cash_jenis create
   */
  export type cash_jenisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * The data needed to create a cash_jenis.
     */
    data: XOR<cash_jenisCreateInput, cash_jenisUncheckedCreateInput>
  }

  /**
   * cash_jenis createMany
   */
  export type cash_jenisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cash_jenis.
     */
    data: cash_jenisCreateManyInput | cash_jenisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cash_jenis update
   */
  export type cash_jenisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * The data needed to update a cash_jenis.
     */
    data: XOR<cash_jenisUpdateInput, cash_jenisUncheckedUpdateInput>
    /**
     * Choose, which cash_jenis to update.
     */
    where: cash_jenisWhereUniqueInput
  }

  /**
   * cash_jenis updateMany
   */
  export type cash_jenisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cash_jenis.
     */
    data: XOR<cash_jenisUpdateManyMutationInput, cash_jenisUncheckedUpdateManyInput>
    /**
     * Filter which cash_jenis to update
     */
    where?: cash_jenisWhereInput
  }

  /**
   * cash_jenis upsert
   */
  export type cash_jenisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * The filter to search for the cash_jenis to update in case it exists.
     */
    where: cash_jenisWhereUniqueInput
    /**
     * In case the cash_jenis found by the `where` argument doesn't exist, create a new cash_jenis with this data.
     */
    create: XOR<cash_jenisCreateInput, cash_jenisUncheckedCreateInput>
    /**
     * In case the cash_jenis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cash_jenisUpdateInput, cash_jenisUncheckedUpdateInput>
  }

  /**
   * cash_jenis delete
   */
  export type cash_jenisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
    /**
     * Filter which cash_jenis to delete.
     */
    where: cash_jenisWhereUniqueInput
  }

  /**
   * cash_jenis deleteMany
   */
  export type cash_jenisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cash_jenis to delete
     */
    where?: cash_jenisWhereInput
  }

  /**
   * cash_jenis without action
   */
  export type cash_jenisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cash_jenis
     */
    select?: cash_jenisSelect<ExtArgs> | null
  }


  /**
   * Model config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigAvgAggregateOutputType = {
    id: number | null
    bulat: number | null
    versi: number | null
    shortcut: number | null
  }

  export type ConfigSumAggregateOutputType = {
    id: number | null
    bulat: number | null
    versi: number | null
    shortcut: number | null
  }

  export type ConfigMinAggregateOutputType = {
    id: number | null
    nama: string | null
    alamat: string | null
    telp: string | null
    bulat: number | null
    versi: number | null
    shortcut: number | null
    modified: Date | null
  }

  export type ConfigMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    alamat: string | null
    telp: string | null
    bulat: number | null
    versi: number | null
    shortcut: number | null
    modified: Date | null
  }

  export type ConfigCountAggregateOutputType = {
    id: number
    nama: number
    alamat: number
    telp: number
    bulat: number
    versi: number
    shortcut: number
    modified: number
    _all: number
  }


  export type ConfigAvgAggregateInputType = {
    id?: true
    bulat?: true
    versi?: true
    shortcut?: true
  }

  export type ConfigSumAggregateInputType = {
    id?: true
    bulat?: true
    versi?: true
    shortcut?: true
  }

  export type ConfigMinAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    telp?: true
    bulat?: true
    versi?: true
    shortcut?: true
    modified?: true
  }

  export type ConfigMaxAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    telp?: true
    bulat?: true
    versi?: true
    shortcut?: true
    modified?: true
  }

  export type ConfigCountAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    telp?: true
    bulat?: true
    versi?: true
    shortcut?: true
    modified?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which config to aggregate.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configWhereInput
    orderBy?: configOrderByWithAggregationInput | configOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _avg?: ConfigAvgAggregateInputType
    _sum?: ConfigSumAggregateInputType
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    id: number
    nama: string
    alamat: string
    telp: string
    bulat: number
    versi: number
    shortcut: number
    modified: Date | null
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    alamat?: boolean
    telp?: boolean
    bulat?: boolean
    versi?: boolean
    shortcut?: boolean
    modified?: boolean
  }, ExtArgs["result"]["config"]>


  export type configSelectScalar = {
    id?: boolean
    nama?: boolean
    alamat?: boolean
    telp?: boolean
    bulat?: boolean
    versi?: boolean
    shortcut?: boolean
    modified?: boolean
  }


  export type $configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      alamat: string
      telp: string
      bulat: number
      versi: number
      shortcut: number
      modified: Date | null
    }, ExtArgs["result"]["config"]>
    composites: {}
  }

  type configGetPayload<S extends boolean | null | undefined | configDefaultArgs> = $Result.GetResult<Prisma.$configPayload, S>

  type configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['config'], meta: { name: 'config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {configFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configFindUniqueArgs>(args: SelectSubset<T, configFindUniqueArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {configFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configFindUniqueOrThrowArgs>(args: SelectSubset<T, configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configFindFirstArgs>(args?: SelectSubset<T, configFindFirstArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configFindFirstOrThrowArgs>(args?: SelectSubset<T, configFindFirstOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configWithIdOnly = await prisma.config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configFindManyArgs>(args?: SelectSubset<T, configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Config.
     * @param {configCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
     */
    create<T extends configCreateArgs>(args: SelectSubset<T, configCreateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Configs.
     * @param {configCreateManyArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configCreateManyArgs>(args?: SelectSubset<T, configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Config.
     * @param {configDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
     */
    delete<T extends configDeleteArgs>(args: SelectSubset<T, configDeleteArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Config.
     * @param {configUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configUpdateArgs>(args: SelectSubset<T, configUpdateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Configs.
     * @param {configDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configDeleteManyArgs>(args?: SelectSubset<T, configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configUpdateManyArgs>(args: SelectSubset<T, configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Config.
     * @param {configUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
     */
    upsert<T extends configUpsertArgs>(args: SelectSubset<T, configUpsertArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends configCountArgs>(
      args?: Subset<T, configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configGroupByArgs['orderBy'] }
        : { orderBy?: configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the config model
   */
  readonly fields: configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the config model
   */ 
  interface configFieldRefs {
    readonly id: FieldRef<"config", 'Int'>
    readonly nama: FieldRef<"config", 'String'>
    readonly alamat: FieldRef<"config", 'String'>
    readonly telp: FieldRef<"config", 'String'>
    readonly bulat: FieldRef<"config", 'Int'>
    readonly versi: FieldRef<"config", 'Int'>
    readonly shortcut: FieldRef<"config", 'Int'>
    readonly modified: FieldRef<"config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * config findUnique
   */
  export type configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findUniqueOrThrow
   */
  export type configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findFirst
   */
  export type configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findFirstOrThrow
   */
  export type configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findMany
   */
  export type configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter, which configs to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config create
   */
  export type configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The data needed to create a config.
     */
    data: XOR<configCreateInput, configUncheckedCreateInput>
  }

  /**
   * config createMany
   */
  export type configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * config update
   */
  export type configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The data needed to update a config.
     */
    data: XOR<configUpdateInput, configUncheckedUpdateInput>
    /**
     * Choose, which config to update.
     */
    where: configWhereUniqueInput
  }

  /**
   * config updateMany
   */
  export type configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
  }

  /**
   * config upsert
   */
  export type configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * The filter to search for the config to update in case it exists.
     */
    where: configWhereUniqueInput
    /**
     * In case the config found by the `where` argument doesn't exist, create a new config with this data.
     */
    create: XOR<configCreateInput, configUncheckedCreateInput>
    /**
     * In case the config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configUpdateInput, configUncheckedUpdateInput>
  }

  /**
   * config delete
   */
  export type configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Filter which config to delete.
     */
    where: configWhereUniqueInput
  }

  /**
   * config deleteMany
   */
  export type configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs to delete
     */
    where?: configWhereInput
  }

  /**
   * config without action
   */
  export type configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
  }


  /**
   * Model dana
   */

  export type AggregateDana = {
    _count: DanaCountAggregateOutputType | null
    _avg: DanaAvgAggregateOutputType | null
    _sum: DanaSumAggregateOutputType | null
    _min: DanaMinAggregateOutputType | null
    _max: DanaMaxAggregateOutputType | null
  }

  export type DanaAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    jumlah: Decimal | null
  }

  export type DanaSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    jumlah: Decimal | null
  }

  export type DanaMinAggregateOutputType = {
    id: number | null
    jenis: number | null
    kode: string | null
    nama: string | null
    jumlah: Decimal | null
  }

  export type DanaMaxAggregateOutputType = {
    id: number | null
    jenis: number | null
    kode: string | null
    nama: string | null
    jumlah: Decimal | null
  }

  export type DanaCountAggregateOutputType = {
    id: number
    jenis: number
    kode: number
    nama: number
    jumlah: number
    _all: number
  }


  export type DanaAvgAggregateInputType = {
    id?: true
    jenis?: true
    jumlah?: true
  }

  export type DanaSumAggregateInputType = {
    id?: true
    jenis?: true
    jumlah?: true
  }

  export type DanaMinAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    jumlah?: true
  }

  export type DanaMaxAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    jumlah?: true
  }

  export type DanaCountAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    jumlah?: true
    _all?: true
  }

  export type DanaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dana to aggregate.
     */
    where?: danaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of danas to fetch.
     */
    orderBy?: danaOrderByWithRelationInput | danaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: danaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` danas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` danas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned danas
    **/
    _count?: true | DanaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DanaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DanaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DanaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DanaMaxAggregateInputType
  }

  export type GetDanaAggregateType<T extends DanaAggregateArgs> = {
        [P in keyof T & keyof AggregateDana]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDana[P]>
      : GetScalarType<T[P], AggregateDana[P]>
  }




  export type danaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: danaWhereInput
    orderBy?: danaOrderByWithAggregationInput | danaOrderByWithAggregationInput[]
    by: DanaScalarFieldEnum[] | DanaScalarFieldEnum
    having?: danaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DanaCountAggregateInputType | true
    _avg?: DanaAvgAggregateInputType
    _sum?: DanaSumAggregateInputType
    _min?: DanaMinAggregateInputType
    _max?: DanaMaxAggregateInputType
  }

  export type DanaGroupByOutputType = {
    id: number
    jenis: number
    kode: string
    nama: string
    jumlah: Decimal
    _count: DanaCountAggregateOutputType | null
    _avg: DanaAvgAggregateOutputType | null
    _sum: DanaSumAggregateOutputType | null
    _min: DanaMinAggregateOutputType | null
    _max: DanaMaxAggregateOutputType | null
  }

  type GetDanaGroupByPayload<T extends danaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DanaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DanaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DanaGroupByOutputType[P]>
            : GetScalarType<T[P], DanaGroupByOutputType[P]>
        }
      >
    >


  export type danaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jenis?: boolean
    kode?: boolean
    nama?: boolean
    jumlah?: boolean
  }, ExtArgs["result"]["dana"]>


  export type danaSelectScalar = {
    id?: boolean
    jenis?: boolean
    kode?: boolean
    nama?: boolean
    jumlah?: boolean
  }


  export type $danaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dana"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jenis: number
      kode: string
      nama: string
      jumlah: Prisma.Decimal
    }, ExtArgs["result"]["dana"]>
    composites: {}
  }

  type danaGetPayload<S extends boolean | null | undefined | danaDefaultArgs> = $Result.GetResult<Prisma.$danaPayload, S>

  type danaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<danaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DanaCountAggregateInputType | true
    }

  export interface danaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dana'], meta: { name: 'dana' } }
    /**
     * Find zero or one Dana that matches the filter.
     * @param {danaFindUniqueArgs} args - Arguments to find a Dana
     * @example
     * // Get one Dana
     * const dana = await prisma.dana.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends danaFindUniqueArgs>(args: SelectSubset<T, danaFindUniqueArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dana that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {danaFindUniqueOrThrowArgs} args - Arguments to find a Dana
     * @example
     * // Get one Dana
     * const dana = await prisma.dana.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends danaFindUniqueOrThrowArgs>(args: SelectSubset<T, danaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dana that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaFindFirstArgs} args - Arguments to find a Dana
     * @example
     * // Get one Dana
     * const dana = await prisma.dana.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends danaFindFirstArgs>(args?: SelectSubset<T, danaFindFirstArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dana that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaFindFirstOrThrowArgs} args - Arguments to find a Dana
     * @example
     * // Get one Dana
     * const dana = await prisma.dana.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends danaFindFirstOrThrowArgs>(args?: SelectSubset<T, danaFindFirstOrThrowArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Danas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Danas
     * const danas = await prisma.dana.findMany()
     * 
     * // Get first 10 Danas
     * const danas = await prisma.dana.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const danaWithIdOnly = await prisma.dana.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends danaFindManyArgs>(args?: SelectSubset<T, danaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dana.
     * @param {danaCreateArgs} args - Arguments to create a Dana.
     * @example
     * // Create one Dana
     * const Dana = await prisma.dana.create({
     *   data: {
     *     // ... data to create a Dana
     *   }
     * })
     * 
     */
    create<T extends danaCreateArgs>(args: SelectSubset<T, danaCreateArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Danas.
     * @param {danaCreateManyArgs} args - Arguments to create many Danas.
     * @example
     * // Create many Danas
     * const dana = await prisma.dana.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends danaCreateManyArgs>(args?: SelectSubset<T, danaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dana.
     * @param {danaDeleteArgs} args - Arguments to delete one Dana.
     * @example
     * // Delete one Dana
     * const Dana = await prisma.dana.delete({
     *   where: {
     *     // ... filter to delete one Dana
     *   }
     * })
     * 
     */
    delete<T extends danaDeleteArgs>(args: SelectSubset<T, danaDeleteArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dana.
     * @param {danaUpdateArgs} args - Arguments to update one Dana.
     * @example
     * // Update one Dana
     * const dana = await prisma.dana.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends danaUpdateArgs>(args: SelectSubset<T, danaUpdateArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Danas.
     * @param {danaDeleteManyArgs} args - Arguments to filter Danas to delete.
     * @example
     * // Delete a few Danas
     * const { count } = await prisma.dana.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends danaDeleteManyArgs>(args?: SelectSubset<T, danaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Danas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Danas
     * const dana = await prisma.dana.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends danaUpdateManyArgs>(args: SelectSubset<T, danaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dana.
     * @param {danaUpsertArgs} args - Arguments to update or create a Dana.
     * @example
     * // Update or create a Dana
     * const dana = await prisma.dana.upsert({
     *   create: {
     *     // ... data to create a Dana
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dana we want to update
     *   }
     * })
     */
    upsert<T extends danaUpsertArgs>(args: SelectSubset<T, danaUpsertArgs<ExtArgs>>): Prisma__danaClient<$Result.GetResult<Prisma.$danaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Danas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaCountArgs} args - Arguments to filter Danas to count.
     * @example
     * // Count the number of Danas
     * const count = await prisma.dana.count({
     *   where: {
     *     // ... the filter for the Danas we want to count
     *   }
     * })
    **/
    count<T extends danaCountArgs>(
      args?: Subset<T, danaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DanaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dana.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DanaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DanaAggregateArgs>(args: Subset<T, DanaAggregateArgs>): Prisma.PrismaPromise<GetDanaAggregateType<T>>

    /**
     * Group by Dana.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {danaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends danaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: danaGroupByArgs['orderBy'] }
        : { orderBy?: danaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, danaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDanaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dana model
   */
  readonly fields: danaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dana.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__danaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dana model
   */ 
  interface danaFieldRefs {
    readonly id: FieldRef<"dana", 'Int'>
    readonly jenis: FieldRef<"dana", 'Int'>
    readonly kode: FieldRef<"dana", 'String'>
    readonly nama: FieldRef<"dana", 'String'>
    readonly jumlah: FieldRef<"dana", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * dana findUnique
   */
  export type danaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter, which dana to fetch.
     */
    where: danaWhereUniqueInput
  }

  /**
   * dana findUniqueOrThrow
   */
  export type danaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter, which dana to fetch.
     */
    where: danaWhereUniqueInput
  }

  /**
   * dana findFirst
   */
  export type danaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter, which dana to fetch.
     */
    where?: danaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of danas to fetch.
     */
    orderBy?: danaOrderByWithRelationInput | danaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for danas.
     */
    cursor?: danaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` danas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` danas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of danas.
     */
    distinct?: DanaScalarFieldEnum | DanaScalarFieldEnum[]
  }

  /**
   * dana findFirstOrThrow
   */
  export type danaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter, which dana to fetch.
     */
    where?: danaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of danas to fetch.
     */
    orderBy?: danaOrderByWithRelationInput | danaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for danas.
     */
    cursor?: danaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` danas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` danas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of danas.
     */
    distinct?: DanaScalarFieldEnum | DanaScalarFieldEnum[]
  }

  /**
   * dana findMany
   */
  export type danaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter, which danas to fetch.
     */
    where?: danaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of danas to fetch.
     */
    orderBy?: danaOrderByWithRelationInput | danaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing danas.
     */
    cursor?: danaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` danas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` danas.
     */
    skip?: number
    distinct?: DanaScalarFieldEnum | DanaScalarFieldEnum[]
  }

  /**
   * dana create
   */
  export type danaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * The data needed to create a dana.
     */
    data: XOR<danaCreateInput, danaUncheckedCreateInput>
  }

  /**
   * dana createMany
   */
  export type danaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many danas.
     */
    data: danaCreateManyInput | danaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dana update
   */
  export type danaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * The data needed to update a dana.
     */
    data: XOR<danaUpdateInput, danaUncheckedUpdateInput>
    /**
     * Choose, which dana to update.
     */
    where: danaWhereUniqueInput
  }

  /**
   * dana updateMany
   */
  export type danaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update danas.
     */
    data: XOR<danaUpdateManyMutationInput, danaUncheckedUpdateManyInput>
    /**
     * Filter which danas to update
     */
    where?: danaWhereInput
  }

  /**
   * dana upsert
   */
  export type danaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * The filter to search for the dana to update in case it exists.
     */
    where: danaWhereUniqueInput
    /**
     * In case the dana found by the `where` argument doesn't exist, create a new dana with this data.
     */
    create: XOR<danaCreateInput, danaUncheckedCreateInput>
    /**
     * In case the dana was found with the provided `where` argument, update it with this data.
     */
    update: XOR<danaUpdateInput, danaUncheckedUpdateInput>
  }

  /**
   * dana delete
   */
  export type danaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
    /**
     * Filter which dana to delete.
     */
    where: danaWhereUniqueInput
  }

  /**
   * dana deleteMany
   */
  export type danaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which danas to delete
     */
    where?: danaWhereInput
  }

  /**
   * dana without action
   */
  export type danaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana
     */
    select?: danaSelect<ExtArgs> | null
  }


  /**
   * Model dana_test
   */

  export type AggregateDana_test = {
    _count: Dana_testCountAggregateOutputType | null
    _avg: Dana_testAvgAggregateOutputType | null
    _sum: Dana_testSumAggregateOutputType | null
    _min: Dana_testMinAggregateOutputType | null
    _max: Dana_testMaxAggregateOutputType | null
  }

  export type Dana_testAvgAggregateOutputType = {
    id: number | null
    nilai: Decimal | null
    nilai2: Decimal | null
  }

  export type Dana_testSumAggregateOutputType = {
    id: number | null
    nilai: Decimal | null
    nilai2: Decimal | null
  }

  export type Dana_testMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    nilai: Decimal | null
    nilai2: Decimal | null
  }

  export type Dana_testMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    nilai: Decimal | null
    nilai2: Decimal | null
  }

  export type Dana_testCountAggregateOutputType = {
    id: number
    tanggal: number
    nilai: number
    nilai2: number
    _all: number
  }


  export type Dana_testAvgAggregateInputType = {
    id?: true
    nilai?: true
    nilai2?: true
  }

  export type Dana_testSumAggregateInputType = {
    id?: true
    nilai?: true
    nilai2?: true
  }

  export type Dana_testMinAggregateInputType = {
    id?: true
    tanggal?: true
    nilai?: true
    nilai2?: true
  }

  export type Dana_testMaxAggregateInputType = {
    id?: true
    tanggal?: true
    nilai?: true
    nilai2?: true
  }

  export type Dana_testCountAggregateInputType = {
    id?: true
    tanggal?: true
    nilai?: true
    nilai2?: true
    _all?: true
  }

  export type Dana_testAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dana_test to aggregate.
     */
    where?: dana_testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dana_tests to fetch.
     */
    orderBy?: dana_testOrderByWithRelationInput | dana_testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dana_testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dana_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dana_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dana_tests
    **/
    _count?: true | Dana_testCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dana_testAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dana_testSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dana_testMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dana_testMaxAggregateInputType
  }

  export type GetDana_testAggregateType<T extends Dana_testAggregateArgs> = {
        [P in keyof T & keyof AggregateDana_test]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDana_test[P]>
      : GetScalarType<T[P], AggregateDana_test[P]>
  }




  export type dana_testGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dana_testWhereInput
    orderBy?: dana_testOrderByWithAggregationInput | dana_testOrderByWithAggregationInput[]
    by: Dana_testScalarFieldEnum[] | Dana_testScalarFieldEnum
    having?: dana_testScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dana_testCountAggregateInputType | true
    _avg?: Dana_testAvgAggregateInputType
    _sum?: Dana_testSumAggregateInputType
    _min?: Dana_testMinAggregateInputType
    _max?: Dana_testMaxAggregateInputType
  }

  export type Dana_testGroupByOutputType = {
    id: number
    tanggal: Date
    nilai: Decimal
    nilai2: Decimal
    _count: Dana_testCountAggregateOutputType | null
    _avg: Dana_testAvgAggregateOutputType | null
    _sum: Dana_testSumAggregateOutputType | null
    _min: Dana_testMinAggregateOutputType | null
    _max: Dana_testMaxAggregateOutputType | null
  }

  type GetDana_testGroupByPayload<T extends dana_testGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dana_testGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dana_testGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dana_testGroupByOutputType[P]>
            : GetScalarType<T[P], Dana_testGroupByOutputType[P]>
        }
      >
    >


  export type dana_testSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    nilai?: boolean
    nilai2?: boolean
  }, ExtArgs["result"]["dana_test"]>


  export type dana_testSelectScalar = {
    id?: boolean
    tanggal?: boolean
    nilai?: boolean
    nilai2?: boolean
  }


  export type $dana_testPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dana_test"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      nilai: Prisma.Decimal
      nilai2: Prisma.Decimal
    }, ExtArgs["result"]["dana_test"]>
    composites: {}
  }

  type dana_testGetPayload<S extends boolean | null | undefined | dana_testDefaultArgs> = $Result.GetResult<Prisma.$dana_testPayload, S>

  type dana_testCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dana_testFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Dana_testCountAggregateInputType | true
    }

  export interface dana_testDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dana_test'], meta: { name: 'dana_test' } }
    /**
     * Find zero or one Dana_test that matches the filter.
     * @param {dana_testFindUniqueArgs} args - Arguments to find a Dana_test
     * @example
     * // Get one Dana_test
     * const dana_test = await prisma.dana_test.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dana_testFindUniqueArgs>(args: SelectSubset<T, dana_testFindUniqueArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dana_test that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dana_testFindUniqueOrThrowArgs} args - Arguments to find a Dana_test
     * @example
     * // Get one Dana_test
     * const dana_test = await prisma.dana_test.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dana_testFindUniqueOrThrowArgs>(args: SelectSubset<T, dana_testFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dana_test that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testFindFirstArgs} args - Arguments to find a Dana_test
     * @example
     * // Get one Dana_test
     * const dana_test = await prisma.dana_test.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dana_testFindFirstArgs>(args?: SelectSubset<T, dana_testFindFirstArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dana_test that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testFindFirstOrThrowArgs} args - Arguments to find a Dana_test
     * @example
     * // Get one Dana_test
     * const dana_test = await prisma.dana_test.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dana_testFindFirstOrThrowArgs>(args?: SelectSubset<T, dana_testFindFirstOrThrowArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dana_tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dana_tests
     * const dana_tests = await prisma.dana_test.findMany()
     * 
     * // Get first 10 Dana_tests
     * const dana_tests = await prisma.dana_test.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dana_testWithIdOnly = await prisma.dana_test.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dana_testFindManyArgs>(args?: SelectSubset<T, dana_testFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dana_test.
     * @param {dana_testCreateArgs} args - Arguments to create a Dana_test.
     * @example
     * // Create one Dana_test
     * const Dana_test = await prisma.dana_test.create({
     *   data: {
     *     // ... data to create a Dana_test
     *   }
     * })
     * 
     */
    create<T extends dana_testCreateArgs>(args: SelectSubset<T, dana_testCreateArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dana_tests.
     * @param {dana_testCreateManyArgs} args - Arguments to create many Dana_tests.
     * @example
     * // Create many Dana_tests
     * const dana_test = await prisma.dana_test.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dana_testCreateManyArgs>(args?: SelectSubset<T, dana_testCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dana_test.
     * @param {dana_testDeleteArgs} args - Arguments to delete one Dana_test.
     * @example
     * // Delete one Dana_test
     * const Dana_test = await prisma.dana_test.delete({
     *   where: {
     *     // ... filter to delete one Dana_test
     *   }
     * })
     * 
     */
    delete<T extends dana_testDeleteArgs>(args: SelectSubset<T, dana_testDeleteArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dana_test.
     * @param {dana_testUpdateArgs} args - Arguments to update one Dana_test.
     * @example
     * // Update one Dana_test
     * const dana_test = await prisma.dana_test.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dana_testUpdateArgs>(args: SelectSubset<T, dana_testUpdateArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dana_tests.
     * @param {dana_testDeleteManyArgs} args - Arguments to filter Dana_tests to delete.
     * @example
     * // Delete a few Dana_tests
     * const { count } = await prisma.dana_test.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dana_testDeleteManyArgs>(args?: SelectSubset<T, dana_testDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dana_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dana_tests
     * const dana_test = await prisma.dana_test.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dana_testUpdateManyArgs>(args: SelectSubset<T, dana_testUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dana_test.
     * @param {dana_testUpsertArgs} args - Arguments to update or create a Dana_test.
     * @example
     * // Update or create a Dana_test
     * const dana_test = await prisma.dana_test.upsert({
     *   create: {
     *     // ... data to create a Dana_test
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dana_test we want to update
     *   }
     * })
     */
    upsert<T extends dana_testUpsertArgs>(args: SelectSubset<T, dana_testUpsertArgs<ExtArgs>>): Prisma__dana_testClient<$Result.GetResult<Prisma.$dana_testPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dana_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testCountArgs} args - Arguments to filter Dana_tests to count.
     * @example
     * // Count the number of Dana_tests
     * const count = await prisma.dana_test.count({
     *   where: {
     *     // ... the filter for the Dana_tests we want to count
     *   }
     * })
    **/
    count<T extends dana_testCountArgs>(
      args?: Subset<T, dana_testCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dana_testCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dana_test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dana_testAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dana_testAggregateArgs>(args: Subset<T, Dana_testAggregateArgs>): Prisma.PrismaPromise<GetDana_testAggregateType<T>>

    /**
     * Group by Dana_test.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dana_testGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dana_testGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dana_testGroupByArgs['orderBy'] }
        : { orderBy?: dana_testGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dana_testGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDana_testGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dana_test model
   */
  readonly fields: dana_testFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dana_test.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dana_testClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dana_test model
   */ 
  interface dana_testFieldRefs {
    readonly id: FieldRef<"dana_test", 'Int'>
    readonly tanggal: FieldRef<"dana_test", 'DateTime'>
    readonly nilai: FieldRef<"dana_test", 'Decimal'>
    readonly nilai2: FieldRef<"dana_test", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * dana_test findUnique
   */
  export type dana_testFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter, which dana_test to fetch.
     */
    where: dana_testWhereUniqueInput
  }

  /**
   * dana_test findUniqueOrThrow
   */
  export type dana_testFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter, which dana_test to fetch.
     */
    where: dana_testWhereUniqueInput
  }

  /**
   * dana_test findFirst
   */
  export type dana_testFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter, which dana_test to fetch.
     */
    where?: dana_testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dana_tests to fetch.
     */
    orderBy?: dana_testOrderByWithRelationInput | dana_testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dana_tests.
     */
    cursor?: dana_testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dana_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dana_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dana_tests.
     */
    distinct?: Dana_testScalarFieldEnum | Dana_testScalarFieldEnum[]
  }

  /**
   * dana_test findFirstOrThrow
   */
  export type dana_testFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter, which dana_test to fetch.
     */
    where?: dana_testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dana_tests to fetch.
     */
    orderBy?: dana_testOrderByWithRelationInput | dana_testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dana_tests.
     */
    cursor?: dana_testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dana_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dana_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dana_tests.
     */
    distinct?: Dana_testScalarFieldEnum | Dana_testScalarFieldEnum[]
  }

  /**
   * dana_test findMany
   */
  export type dana_testFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter, which dana_tests to fetch.
     */
    where?: dana_testWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dana_tests to fetch.
     */
    orderBy?: dana_testOrderByWithRelationInput | dana_testOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dana_tests.
     */
    cursor?: dana_testWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dana_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dana_tests.
     */
    skip?: number
    distinct?: Dana_testScalarFieldEnum | Dana_testScalarFieldEnum[]
  }

  /**
   * dana_test create
   */
  export type dana_testCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * The data needed to create a dana_test.
     */
    data: XOR<dana_testCreateInput, dana_testUncheckedCreateInput>
  }

  /**
   * dana_test createMany
   */
  export type dana_testCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dana_tests.
     */
    data: dana_testCreateManyInput | dana_testCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dana_test update
   */
  export type dana_testUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * The data needed to update a dana_test.
     */
    data: XOR<dana_testUpdateInput, dana_testUncheckedUpdateInput>
    /**
     * Choose, which dana_test to update.
     */
    where: dana_testWhereUniqueInput
  }

  /**
   * dana_test updateMany
   */
  export type dana_testUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dana_tests.
     */
    data: XOR<dana_testUpdateManyMutationInput, dana_testUncheckedUpdateManyInput>
    /**
     * Filter which dana_tests to update
     */
    where?: dana_testWhereInput
  }

  /**
   * dana_test upsert
   */
  export type dana_testUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * The filter to search for the dana_test to update in case it exists.
     */
    where: dana_testWhereUniqueInput
    /**
     * In case the dana_test found by the `where` argument doesn't exist, create a new dana_test with this data.
     */
    create: XOR<dana_testCreateInput, dana_testUncheckedCreateInput>
    /**
     * In case the dana_test was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dana_testUpdateInput, dana_testUncheckedUpdateInput>
  }

  /**
   * dana_test delete
   */
  export type dana_testDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
    /**
     * Filter which dana_test to delete.
     */
    where: dana_testWhereUniqueInput
  }

  /**
   * dana_test deleteMany
   */
  export type dana_testDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dana_tests to delete
     */
    where?: dana_testWhereInput
  }

  /**
   * dana_test without action
   */
  export type dana_testDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dana_test
     */
    select?: dana_testSelect<ExtArgs> | null
  }


  /**
   * Model divisi
   */

  export type AggregateDivisi = {
    _count: DivisiCountAggregateOutputType | null
    _avg: DivisiAvgAggregateOutputType | null
    _sum: DivisiSumAggregateOutputType | null
    _min: DivisiMinAggregateOutputType | null
    _max: DivisiMaxAggregateOutputType | null
  }

  export type DivisiAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
  }

  export type DivisiSumAggregateOutputType = {
    id: number | null
    jenis: number | null
  }

  export type DivisiMinAggregateOutputType = {
    id: number | null
    jenis: number | null
    kode: string | null
    nama: string | null
    created: Date | null
    modified: Date | null
  }

  export type DivisiMaxAggregateOutputType = {
    id: number | null
    jenis: number | null
    kode: string | null
    nama: string | null
    created: Date | null
    modified: Date | null
  }

  export type DivisiCountAggregateOutputType = {
    id: number
    jenis: number
    kode: number
    nama: number
    created: number
    modified: number
    _all: number
  }


  export type DivisiAvgAggregateInputType = {
    id?: true
    jenis?: true
  }

  export type DivisiSumAggregateInputType = {
    id?: true
    jenis?: true
  }

  export type DivisiMinAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    created?: true
    modified?: true
  }

  export type DivisiMaxAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    created?: true
    modified?: true
  }

  export type DivisiCountAggregateInputType = {
    id?: true
    jenis?: true
    kode?: true
    nama?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type DivisiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which divisi to aggregate.
     */
    where?: divisiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisis to fetch.
     */
    orderBy?: divisiOrderByWithRelationInput | divisiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: divisiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned divisis
    **/
    _count?: true | DivisiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DivisiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DivisiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DivisiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DivisiMaxAggregateInputType
  }

  export type GetDivisiAggregateType<T extends DivisiAggregateArgs> = {
        [P in keyof T & keyof AggregateDivisi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDivisi[P]>
      : GetScalarType<T[P], AggregateDivisi[P]>
  }




  export type divisiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: divisiWhereInput
    orderBy?: divisiOrderByWithAggregationInput | divisiOrderByWithAggregationInput[]
    by: DivisiScalarFieldEnum[] | DivisiScalarFieldEnum
    having?: divisiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DivisiCountAggregateInputType | true
    _avg?: DivisiAvgAggregateInputType
    _sum?: DivisiSumAggregateInputType
    _min?: DivisiMinAggregateInputType
    _max?: DivisiMaxAggregateInputType
  }

  export type DivisiGroupByOutputType = {
    id: number
    jenis: number
    kode: string
    nama: string
    created: Date
    modified: Date
    _count: DivisiCountAggregateOutputType | null
    _avg: DivisiAvgAggregateOutputType | null
    _sum: DivisiSumAggregateOutputType | null
    _min: DivisiMinAggregateOutputType | null
    _max: DivisiMaxAggregateOutputType | null
  }

  type GetDivisiGroupByPayload<T extends divisiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DivisiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DivisiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DivisiGroupByOutputType[P]>
            : GetScalarType<T[P], DivisiGroupByOutputType[P]>
        }
      >
    >


  export type divisiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jenis?: boolean
    kode?: boolean
    nama?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["divisi"]>


  export type divisiSelectScalar = {
    id?: boolean
    jenis?: boolean
    kode?: boolean
    nama?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $divisiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "divisi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jenis: number
      kode: string
      nama: string
      created: Date
      modified: Date
    }, ExtArgs["result"]["divisi"]>
    composites: {}
  }

  type divisiGetPayload<S extends boolean | null | undefined | divisiDefaultArgs> = $Result.GetResult<Prisma.$divisiPayload, S>

  type divisiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<divisiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DivisiCountAggregateInputType | true
    }

  export interface divisiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['divisi'], meta: { name: 'divisi' } }
    /**
     * Find zero or one Divisi that matches the filter.
     * @param {divisiFindUniqueArgs} args - Arguments to find a Divisi
     * @example
     * // Get one Divisi
     * const divisi = await prisma.divisi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends divisiFindUniqueArgs>(args: SelectSubset<T, divisiFindUniqueArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Divisi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {divisiFindUniqueOrThrowArgs} args - Arguments to find a Divisi
     * @example
     * // Get one Divisi
     * const divisi = await prisma.divisi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends divisiFindUniqueOrThrowArgs>(args: SelectSubset<T, divisiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Divisi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiFindFirstArgs} args - Arguments to find a Divisi
     * @example
     * // Get one Divisi
     * const divisi = await prisma.divisi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends divisiFindFirstArgs>(args?: SelectSubset<T, divisiFindFirstArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Divisi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiFindFirstOrThrowArgs} args - Arguments to find a Divisi
     * @example
     * // Get one Divisi
     * const divisi = await prisma.divisi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends divisiFindFirstOrThrowArgs>(args?: SelectSubset<T, divisiFindFirstOrThrowArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Divisis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Divisis
     * const divisis = await prisma.divisi.findMany()
     * 
     * // Get first 10 Divisis
     * const divisis = await prisma.divisi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const divisiWithIdOnly = await prisma.divisi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends divisiFindManyArgs>(args?: SelectSubset<T, divisiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Divisi.
     * @param {divisiCreateArgs} args - Arguments to create a Divisi.
     * @example
     * // Create one Divisi
     * const Divisi = await prisma.divisi.create({
     *   data: {
     *     // ... data to create a Divisi
     *   }
     * })
     * 
     */
    create<T extends divisiCreateArgs>(args: SelectSubset<T, divisiCreateArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Divisis.
     * @param {divisiCreateManyArgs} args - Arguments to create many Divisis.
     * @example
     * // Create many Divisis
     * const divisi = await prisma.divisi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends divisiCreateManyArgs>(args?: SelectSubset<T, divisiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Divisi.
     * @param {divisiDeleteArgs} args - Arguments to delete one Divisi.
     * @example
     * // Delete one Divisi
     * const Divisi = await prisma.divisi.delete({
     *   where: {
     *     // ... filter to delete one Divisi
     *   }
     * })
     * 
     */
    delete<T extends divisiDeleteArgs>(args: SelectSubset<T, divisiDeleteArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Divisi.
     * @param {divisiUpdateArgs} args - Arguments to update one Divisi.
     * @example
     * // Update one Divisi
     * const divisi = await prisma.divisi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends divisiUpdateArgs>(args: SelectSubset<T, divisiUpdateArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Divisis.
     * @param {divisiDeleteManyArgs} args - Arguments to filter Divisis to delete.
     * @example
     * // Delete a few Divisis
     * const { count } = await prisma.divisi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends divisiDeleteManyArgs>(args?: SelectSubset<T, divisiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Divisis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Divisis
     * const divisi = await prisma.divisi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends divisiUpdateManyArgs>(args: SelectSubset<T, divisiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Divisi.
     * @param {divisiUpsertArgs} args - Arguments to update or create a Divisi.
     * @example
     * // Update or create a Divisi
     * const divisi = await prisma.divisi.upsert({
     *   create: {
     *     // ... data to create a Divisi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Divisi we want to update
     *   }
     * })
     */
    upsert<T extends divisiUpsertArgs>(args: SelectSubset<T, divisiUpsertArgs<ExtArgs>>): Prisma__divisiClient<$Result.GetResult<Prisma.$divisiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Divisis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiCountArgs} args - Arguments to filter Divisis to count.
     * @example
     * // Count the number of Divisis
     * const count = await prisma.divisi.count({
     *   where: {
     *     // ... the filter for the Divisis we want to count
     *   }
     * })
    **/
    count<T extends divisiCountArgs>(
      args?: Subset<T, divisiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DivisiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Divisi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DivisiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DivisiAggregateArgs>(args: Subset<T, DivisiAggregateArgs>): Prisma.PrismaPromise<GetDivisiAggregateType<T>>

    /**
     * Group by Divisi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {divisiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends divisiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: divisiGroupByArgs['orderBy'] }
        : { orderBy?: divisiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, divisiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDivisiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the divisi model
   */
  readonly fields: divisiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for divisi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__divisiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the divisi model
   */ 
  interface divisiFieldRefs {
    readonly id: FieldRef<"divisi", 'Int'>
    readonly jenis: FieldRef<"divisi", 'Int'>
    readonly kode: FieldRef<"divisi", 'String'>
    readonly nama: FieldRef<"divisi", 'String'>
    readonly created: FieldRef<"divisi", 'DateTime'>
    readonly modified: FieldRef<"divisi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * divisi findUnique
   */
  export type divisiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter, which divisi to fetch.
     */
    where: divisiWhereUniqueInput
  }

  /**
   * divisi findUniqueOrThrow
   */
  export type divisiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter, which divisi to fetch.
     */
    where: divisiWhereUniqueInput
  }

  /**
   * divisi findFirst
   */
  export type divisiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter, which divisi to fetch.
     */
    where?: divisiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisis to fetch.
     */
    orderBy?: divisiOrderByWithRelationInput | divisiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisis.
     */
    cursor?: divisiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisis.
     */
    distinct?: DivisiScalarFieldEnum | DivisiScalarFieldEnum[]
  }

  /**
   * divisi findFirstOrThrow
   */
  export type divisiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter, which divisi to fetch.
     */
    where?: divisiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisis to fetch.
     */
    orderBy?: divisiOrderByWithRelationInput | divisiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for divisis.
     */
    cursor?: divisiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of divisis.
     */
    distinct?: DivisiScalarFieldEnum | DivisiScalarFieldEnum[]
  }

  /**
   * divisi findMany
   */
  export type divisiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter, which divisis to fetch.
     */
    where?: divisiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of divisis to fetch.
     */
    orderBy?: divisiOrderByWithRelationInput | divisiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing divisis.
     */
    cursor?: divisiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` divisis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` divisis.
     */
    skip?: number
    distinct?: DivisiScalarFieldEnum | DivisiScalarFieldEnum[]
  }

  /**
   * divisi create
   */
  export type divisiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * The data needed to create a divisi.
     */
    data: XOR<divisiCreateInput, divisiUncheckedCreateInput>
  }

  /**
   * divisi createMany
   */
  export type divisiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many divisis.
     */
    data: divisiCreateManyInput | divisiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * divisi update
   */
  export type divisiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * The data needed to update a divisi.
     */
    data: XOR<divisiUpdateInput, divisiUncheckedUpdateInput>
    /**
     * Choose, which divisi to update.
     */
    where: divisiWhereUniqueInput
  }

  /**
   * divisi updateMany
   */
  export type divisiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update divisis.
     */
    data: XOR<divisiUpdateManyMutationInput, divisiUncheckedUpdateManyInput>
    /**
     * Filter which divisis to update
     */
    where?: divisiWhereInput
  }

  /**
   * divisi upsert
   */
  export type divisiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * The filter to search for the divisi to update in case it exists.
     */
    where: divisiWhereUniqueInput
    /**
     * In case the divisi found by the `where` argument doesn't exist, create a new divisi with this data.
     */
    create: XOR<divisiCreateInput, divisiUncheckedCreateInput>
    /**
     * In case the divisi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<divisiUpdateInput, divisiUncheckedUpdateInput>
  }

  /**
   * divisi delete
   */
  export type divisiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
    /**
     * Filter which divisi to delete.
     */
    where: divisiWhereUniqueInput
  }

  /**
   * divisi deleteMany
   */
  export type divisiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which divisis to delete
     */
    where?: divisiWhereInput
  }

  /**
   * divisi without action
   */
  export type divisiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the divisi
     */
    select?: divisiSelect<ExtArgs> | null
  }


  /**
   * Model estimasi
   */

  export type AggregateEstimasi = {
    _count: EstimasiCountAggregateOutputType | null
    _avg: EstimasiAvgAggregateOutputType | null
    _sum: EstimasiSumAggregateOutputType | null
    _min: EstimasiMinAggregateOutputType | null
    _max: EstimasiMaxAggregateOutputType | null
  }

  export type EstimasiAvgAggregateOutputType = {
    id: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    admin: number | null
  }

  export type EstimasiSumAggregateOutputType = {
    id: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    admin: number | null
  }

  export type EstimasiMinAggregateOutputType = {
    id: number | null
    kode: string | null
    tanggal: Date | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    keterangan: string | null
    admin: number | null
    created: Date | null
    modified: Date | null
  }

  export type EstimasiMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    tanggal: Date | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    keterangan: string | null
    admin: number | null
    created: Date | null
    modified: Date | null
  }

  export type EstimasiCountAggregateOutputType = {
    id: number
    kode: number
    tanggal: number
    jumlah: number
    produk: number
    total_beli: number
    total_jual: number
    keterangan: number
    admin: number
    created: number
    modified: number
    _all: number
  }


  export type EstimasiAvgAggregateInputType = {
    id?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    admin?: true
  }

  export type EstimasiSumAggregateInputType = {
    id?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    admin?: true
  }

  export type EstimasiMinAggregateInputType = {
    id?: true
    kode?: true
    tanggal?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    keterangan?: true
    admin?: true
    created?: true
    modified?: true
  }

  export type EstimasiMaxAggregateInputType = {
    id?: true
    kode?: true
    tanggal?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    keterangan?: true
    admin?: true
    created?: true
    modified?: true
  }

  export type EstimasiCountAggregateInputType = {
    id?: true
    kode?: true
    tanggal?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    keterangan?: true
    admin?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type EstimasiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimasi to aggregate.
     */
    where?: estimasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasis to fetch.
     */
    orderBy?: estimasiOrderByWithRelationInput | estimasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimasis
    **/
    _count?: true | EstimasiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstimasiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstimasiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstimasiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstimasiMaxAggregateInputType
  }

  export type GetEstimasiAggregateType<T extends EstimasiAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimasi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimasi[P]>
      : GetScalarType<T[P], AggregateEstimasi[P]>
  }




  export type estimasiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimasiWhereInput
    orderBy?: estimasiOrderByWithAggregationInput | estimasiOrderByWithAggregationInput[]
    by: EstimasiScalarFieldEnum[] | EstimasiScalarFieldEnum
    having?: estimasiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstimasiCountAggregateInputType | true
    _avg?: EstimasiAvgAggregateInputType
    _sum?: EstimasiSumAggregateInputType
    _min?: EstimasiMinAggregateInputType
    _max?: EstimasiMaxAggregateInputType
  }

  export type EstimasiGroupByOutputType = {
    id: number
    kode: string
    tanggal: Date | null
    jumlah: number
    produk: number
    total_beli: Decimal
    total_jual: Decimal
    keterangan: string
    admin: number
    created: Date | null
    modified: Date | null
    _count: EstimasiCountAggregateOutputType | null
    _avg: EstimasiAvgAggregateOutputType | null
    _sum: EstimasiSumAggregateOutputType | null
    _min: EstimasiMinAggregateOutputType | null
    _max: EstimasiMaxAggregateOutputType | null
  }

  type GetEstimasiGroupByPayload<T extends estimasiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstimasiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstimasiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstimasiGroupByOutputType[P]>
            : GetScalarType<T[P], EstimasiGroupByOutputType[P]>
        }
      >
    >


  export type estimasiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    tanggal?: boolean
    jumlah?: boolean
    produk?: boolean
    total_beli?: boolean
    total_jual?: boolean
    keterangan?: boolean
    admin?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["estimasi"]>


  export type estimasiSelectScalar = {
    id?: boolean
    kode?: boolean
    tanggal?: boolean
    jumlah?: boolean
    produk?: boolean
    total_beli?: boolean
    total_jual?: boolean
    keterangan?: boolean
    admin?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $estimasiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimasi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      tanggal: Date | null
      jumlah: number
      produk: number
      total_beli: Prisma.Decimal
      total_jual: Prisma.Decimal
      keterangan: string
      admin: number
      created: Date | null
      modified: Date | null
    }, ExtArgs["result"]["estimasi"]>
    composites: {}
  }

  type estimasiGetPayload<S extends boolean | null | undefined | estimasiDefaultArgs> = $Result.GetResult<Prisma.$estimasiPayload, S>

  type estimasiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<estimasiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EstimasiCountAggregateInputType | true
    }

  export interface estimasiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimasi'], meta: { name: 'estimasi' } }
    /**
     * Find zero or one Estimasi that matches the filter.
     * @param {estimasiFindUniqueArgs} args - Arguments to find a Estimasi
     * @example
     * // Get one Estimasi
     * const estimasi = await prisma.estimasi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimasiFindUniqueArgs>(args: SelectSubset<T, estimasiFindUniqueArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estimasi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {estimasiFindUniqueOrThrowArgs} args - Arguments to find a Estimasi
     * @example
     * // Get one Estimasi
     * const estimasi = await prisma.estimasi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimasiFindUniqueOrThrowArgs>(args: SelectSubset<T, estimasiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estimasi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiFindFirstArgs} args - Arguments to find a Estimasi
     * @example
     * // Get one Estimasi
     * const estimasi = await prisma.estimasi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimasiFindFirstArgs>(args?: SelectSubset<T, estimasiFindFirstArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estimasi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiFindFirstOrThrowArgs} args - Arguments to find a Estimasi
     * @example
     * // Get one Estimasi
     * const estimasi = await prisma.estimasi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimasiFindFirstOrThrowArgs>(args?: SelectSubset<T, estimasiFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estimasis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimasis
     * const estimasis = await prisma.estimasi.findMany()
     * 
     * // Get first 10 Estimasis
     * const estimasis = await prisma.estimasi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimasiWithIdOnly = await prisma.estimasi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimasiFindManyArgs>(args?: SelectSubset<T, estimasiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estimasi.
     * @param {estimasiCreateArgs} args - Arguments to create a Estimasi.
     * @example
     * // Create one Estimasi
     * const Estimasi = await prisma.estimasi.create({
     *   data: {
     *     // ... data to create a Estimasi
     *   }
     * })
     * 
     */
    create<T extends estimasiCreateArgs>(args: SelectSubset<T, estimasiCreateArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estimasis.
     * @param {estimasiCreateManyArgs} args - Arguments to create many Estimasis.
     * @example
     * // Create many Estimasis
     * const estimasi = await prisma.estimasi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimasiCreateManyArgs>(args?: SelectSubset<T, estimasiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estimasi.
     * @param {estimasiDeleteArgs} args - Arguments to delete one Estimasi.
     * @example
     * // Delete one Estimasi
     * const Estimasi = await prisma.estimasi.delete({
     *   where: {
     *     // ... filter to delete one Estimasi
     *   }
     * })
     * 
     */
    delete<T extends estimasiDeleteArgs>(args: SelectSubset<T, estimasiDeleteArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estimasi.
     * @param {estimasiUpdateArgs} args - Arguments to update one Estimasi.
     * @example
     * // Update one Estimasi
     * const estimasi = await prisma.estimasi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimasiUpdateArgs>(args: SelectSubset<T, estimasiUpdateArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estimasis.
     * @param {estimasiDeleteManyArgs} args - Arguments to filter Estimasis to delete.
     * @example
     * // Delete a few Estimasis
     * const { count } = await prisma.estimasi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimasiDeleteManyArgs>(args?: SelectSubset<T, estimasiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimasis
     * const estimasi = await prisma.estimasi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimasiUpdateManyArgs>(args: SelectSubset<T, estimasiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estimasi.
     * @param {estimasiUpsertArgs} args - Arguments to update or create a Estimasi.
     * @example
     * // Update or create a Estimasi
     * const estimasi = await prisma.estimasi.upsert({
     *   create: {
     *     // ... data to create a Estimasi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimasi we want to update
     *   }
     * })
     */
    upsert<T extends estimasiUpsertArgs>(args: SelectSubset<T, estimasiUpsertArgs<ExtArgs>>): Prisma__estimasiClient<$Result.GetResult<Prisma.$estimasiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estimasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiCountArgs} args - Arguments to filter Estimasis to count.
     * @example
     * // Count the number of Estimasis
     * const count = await prisma.estimasi.count({
     *   where: {
     *     // ... the filter for the Estimasis we want to count
     *   }
     * })
    **/
    count<T extends estimasiCountArgs>(
      args?: Subset<T, estimasiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstimasiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstimasiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstimasiAggregateArgs>(args: Subset<T, EstimasiAggregateArgs>): Prisma.PrismaPromise<GetEstimasiAggregateType<T>>

    /**
     * Group by Estimasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimasiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimasiGroupByArgs['orderBy'] }
        : { orderBy?: estimasiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimasiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimasiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimasi model
   */
  readonly fields: estimasiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimasi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimasiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimasi model
   */ 
  interface estimasiFieldRefs {
    readonly id: FieldRef<"estimasi", 'Int'>
    readonly kode: FieldRef<"estimasi", 'String'>
    readonly tanggal: FieldRef<"estimasi", 'DateTime'>
    readonly jumlah: FieldRef<"estimasi", 'Float'>
    readonly produk: FieldRef<"estimasi", 'Int'>
    readonly total_beli: FieldRef<"estimasi", 'Decimal'>
    readonly total_jual: FieldRef<"estimasi", 'Decimal'>
    readonly keterangan: FieldRef<"estimasi", 'String'>
    readonly admin: FieldRef<"estimasi", 'Int'>
    readonly created: FieldRef<"estimasi", 'DateTime'>
    readonly modified: FieldRef<"estimasi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * estimasi findUnique
   */
  export type estimasiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter, which estimasi to fetch.
     */
    where: estimasiWhereUniqueInput
  }

  /**
   * estimasi findUniqueOrThrow
   */
  export type estimasiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter, which estimasi to fetch.
     */
    where: estimasiWhereUniqueInput
  }

  /**
   * estimasi findFirst
   */
  export type estimasiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter, which estimasi to fetch.
     */
    where?: estimasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasis to fetch.
     */
    orderBy?: estimasiOrderByWithRelationInput | estimasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimasis.
     */
    cursor?: estimasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimasis.
     */
    distinct?: EstimasiScalarFieldEnum | EstimasiScalarFieldEnum[]
  }

  /**
   * estimasi findFirstOrThrow
   */
  export type estimasiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter, which estimasi to fetch.
     */
    where?: estimasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasis to fetch.
     */
    orderBy?: estimasiOrderByWithRelationInput | estimasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimasis.
     */
    cursor?: estimasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimasis.
     */
    distinct?: EstimasiScalarFieldEnum | EstimasiScalarFieldEnum[]
  }

  /**
   * estimasi findMany
   */
  export type estimasiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter, which estimasis to fetch.
     */
    where?: estimasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasis to fetch.
     */
    orderBy?: estimasiOrderByWithRelationInput | estimasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimasis.
     */
    cursor?: estimasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasis.
     */
    skip?: number
    distinct?: EstimasiScalarFieldEnum | EstimasiScalarFieldEnum[]
  }

  /**
   * estimasi create
   */
  export type estimasiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * The data needed to create a estimasi.
     */
    data: XOR<estimasiCreateInput, estimasiUncheckedCreateInput>
  }

  /**
   * estimasi createMany
   */
  export type estimasiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimasis.
     */
    data: estimasiCreateManyInput | estimasiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimasi update
   */
  export type estimasiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * The data needed to update a estimasi.
     */
    data: XOR<estimasiUpdateInput, estimasiUncheckedUpdateInput>
    /**
     * Choose, which estimasi to update.
     */
    where: estimasiWhereUniqueInput
  }

  /**
   * estimasi updateMany
   */
  export type estimasiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimasis.
     */
    data: XOR<estimasiUpdateManyMutationInput, estimasiUncheckedUpdateManyInput>
    /**
     * Filter which estimasis to update
     */
    where?: estimasiWhereInput
  }

  /**
   * estimasi upsert
   */
  export type estimasiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * The filter to search for the estimasi to update in case it exists.
     */
    where: estimasiWhereUniqueInput
    /**
     * In case the estimasi found by the `where` argument doesn't exist, create a new estimasi with this data.
     */
    create: XOR<estimasiCreateInput, estimasiUncheckedCreateInput>
    /**
     * In case the estimasi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimasiUpdateInput, estimasiUncheckedUpdateInput>
  }

  /**
   * estimasi delete
   */
  export type estimasiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
    /**
     * Filter which estimasi to delete.
     */
    where: estimasiWhereUniqueInput
  }

  /**
   * estimasi deleteMany
   */
  export type estimasiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimasis to delete
     */
    where?: estimasiWhereInput
  }

  /**
   * estimasi without action
   */
  export type estimasiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi
     */
    select?: estimasiSelect<ExtArgs> | null
  }


  /**
   * Model estimasi_item
   */

  export type AggregateEstimasi_item = {
    _count: Estimasi_itemCountAggregateOutputType | null
    _avg: Estimasi_itemAvgAggregateOutputType | null
    _sum: Estimasi_itemSumAggregateOutputType | null
    _min: Estimasi_itemMinAggregateOutputType | null
    _max: Estimasi_itemMaxAggregateOutputType | null
  }

  export type Estimasi_itemAvgAggregateOutputType = {
    id: number | null
    id_estimasi: number | null
    id_produk: number | null
    id_supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
  }

  export type Estimasi_itemSumAggregateOutputType = {
    id: number | null
    id_estimasi: number | null
    id_produk: number | null
    id_supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
  }

  export type Estimasi_itemMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    id_estimasi: number | null
    id_produk: number | null
    id_supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
  }

  export type Estimasi_itemMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    id_estimasi: number | null
    id_produk: number | null
    id_supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
  }

  export type Estimasi_itemCountAggregateOutputType = {
    id: number
    tanggal: number
    id_estimasi: number
    id_produk: number
    id_supplier: number
    harga_beli: number
    harga_jual: number
    jumlah: number
    _all: number
  }


  export type Estimasi_itemAvgAggregateInputType = {
    id?: true
    id_estimasi?: true
    id_produk?: true
    id_supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
  }

  export type Estimasi_itemSumAggregateInputType = {
    id?: true
    id_estimasi?: true
    id_produk?: true
    id_supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
  }

  export type Estimasi_itemMinAggregateInputType = {
    id?: true
    tanggal?: true
    id_estimasi?: true
    id_produk?: true
    id_supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
  }

  export type Estimasi_itemMaxAggregateInputType = {
    id?: true
    tanggal?: true
    id_estimasi?: true
    id_produk?: true
    id_supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
  }

  export type Estimasi_itemCountAggregateInputType = {
    id?: true
    tanggal?: true
    id_estimasi?: true
    id_produk?: true
    id_supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    _all?: true
  }

  export type Estimasi_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimasi_item to aggregate.
     */
    where?: estimasi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasi_items to fetch.
     */
    orderBy?: estimasi_itemOrderByWithRelationInput | estimasi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estimasi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estimasi_items
    **/
    _count?: true | Estimasi_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Estimasi_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Estimasi_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Estimasi_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Estimasi_itemMaxAggregateInputType
  }

  export type GetEstimasi_itemAggregateType<T extends Estimasi_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateEstimasi_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstimasi_item[P]>
      : GetScalarType<T[P], AggregateEstimasi_item[P]>
  }




  export type estimasi_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estimasi_itemWhereInput
    orderBy?: estimasi_itemOrderByWithAggregationInput | estimasi_itemOrderByWithAggregationInput[]
    by: Estimasi_itemScalarFieldEnum[] | Estimasi_itemScalarFieldEnum
    having?: estimasi_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Estimasi_itemCountAggregateInputType | true
    _avg?: Estimasi_itemAvgAggregateInputType
    _sum?: Estimasi_itemSumAggregateInputType
    _min?: Estimasi_itemMinAggregateInputType
    _max?: Estimasi_itemMaxAggregateInputType
  }

  export type Estimasi_itemGroupByOutputType = {
    id: number
    tanggal: Date | null
    id_estimasi: number
    id_produk: number
    id_supplier: number
    harga_beli: Decimal
    harga_jual: Decimal
    jumlah: number
    _count: Estimasi_itemCountAggregateOutputType | null
    _avg: Estimasi_itemAvgAggregateOutputType | null
    _sum: Estimasi_itemSumAggregateOutputType | null
    _min: Estimasi_itemMinAggregateOutputType | null
    _max: Estimasi_itemMaxAggregateOutputType | null
  }

  type GetEstimasi_itemGroupByPayload<T extends estimasi_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Estimasi_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Estimasi_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Estimasi_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Estimasi_itemGroupByOutputType[P]>
        }
      >
    >


  export type estimasi_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    id_estimasi?: boolean
    id_produk?: boolean
    id_supplier?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
  }, ExtArgs["result"]["estimasi_item"]>


  export type estimasi_itemSelectScalar = {
    id?: boolean
    tanggal?: boolean
    id_estimasi?: boolean
    id_produk?: boolean
    id_supplier?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
  }


  export type $estimasi_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estimasi_item"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date | null
      id_estimasi: number
      id_produk: number
      id_supplier: number
      harga_beli: Prisma.Decimal
      harga_jual: Prisma.Decimal
      jumlah: number
    }, ExtArgs["result"]["estimasi_item"]>
    composites: {}
  }

  type estimasi_itemGetPayload<S extends boolean | null | undefined | estimasi_itemDefaultArgs> = $Result.GetResult<Prisma.$estimasi_itemPayload, S>

  type estimasi_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<estimasi_itemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Estimasi_itemCountAggregateInputType | true
    }

  export interface estimasi_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estimasi_item'], meta: { name: 'estimasi_item' } }
    /**
     * Find zero or one Estimasi_item that matches the filter.
     * @param {estimasi_itemFindUniqueArgs} args - Arguments to find a Estimasi_item
     * @example
     * // Get one Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estimasi_itemFindUniqueArgs>(args: SelectSubset<T, estimasi_itemFindUniqueArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Estimasi_item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {estimasi_itemFindUniqueOrThrowArgs} args - Arguments to find a Estimasi_item
     * @example
     * // Get one Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estimasi_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, estimasi_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Estimasi_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemFindFirstArgs} args - Arguments to find a Estimasi_item
     * @example
     * // Get one Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estimasi_itemFindFirstArgs>(args?: SelectSubset<T, estimasi_itemFindFirstArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Estimasi_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemFindFirstOrThrowArgs} args - Arguments to find a Estimasi_item
     * @example
     * // Get one Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estimasi_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, estimasi_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Estimasi_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estimasi_items
     * const estimasi_items = await prisma.estimasi_item.findMany()
     * 
     * // Get first 10 Estimasi_items
     * const estimasi_items = await prisma.estimasi_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estimasi_itemWithIdOnly = await prisma.estimasi_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estimasi_itemFindManyArgs>(args?: SelectSubset<T, estimasi_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Estimasi_item.
     * @param {estimasi_itemCreateArgs} args - Arguments to create a Estimasi_item.
     * @example
     * // Create one Estimasi_item
     * const Estimasi_item = await prisma.estimasi_item.create({
     *   data: {
     *     // ... data to create a Estimasi_item
     *   }
     * })
     * 
     */
    create<T extends estimasi_itemCreateArgs>(args: SelectSubset<T, estimasi_itemCreateArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Estimasi_items.
     * @param {estimasi_itemCreateManyArgs} args - Arguments to create many Estimasi_items.
     * @example
     * // Create many Estimasi_items
     * const estimasi_item = await prisma.estimasi_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estimasi_itemCreateManyArgs>(args?: SelectSubset<T, estimasi_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Estimasi_item.
     * @param {estimasi_itemDeleteArgs} args - Arguments to delete one Estimasi_item.
     * @example
     * // Delete one Estimasi_item
     * const Estimasi_item = await prisma.estimasi_item.delete({
     *   where: {
     *     // ... filter to delete one Estimasi_item
     *   }
     * })
     * 
     */
    delete<T extends estimasi_itemDeleteArgs>(args: SelectSubset<T, estimasi_itemDeleteArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Estimasi_item.
     * @param {estimasi_itemUpdateArgs} args - Arguments to update one Estimasi_item.
     * @example
     * // Update one Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estimasi_itemUpdateArgs>(args: SelectSubset<T, estimasi_itemUpdateArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Estimasi_items.
     * @param {estimasi_itemDeleteManyArgs} args - Arguments to filter Estimasi_items to delete.
     * @example
     * // Delete a few Estimasi_items
     * const { count } = await prisma.estimasi_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estimasi_itemDeleteManyArgs>(args?: SelectSubset<T, estimasi_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estimasi_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estimasi_items
     * const estimasi_item = await prisma.estimasi_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estimasi_itemUpdateManyArgs>(args: SelectSubset<T, estimasi_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Estimasi_item.
     * @param {estimasi_itemUpsertArgs} args - Arguments to update or create a Estimasi_item.
     * @example
     * // Update or create a Estimasi_item
     * const estimasi_item = await prisma.estimasi_item.upsert({
     *   create: {
     *     // ... data to create a Estimasi_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estimasi_item we want to update
     *   }
     * })
     */
    upsert<T extends estimasi_itemUpsertArgs>(args: SelectSubset<T, estimasi_itemUpsertArgs<ExtArgs>>): Prisma__estimasi_itemClient<$Result.GetResult<Prisma.$estimasi_itemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Estimasi_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemCountArgs} args - Arguments to filter Estimasi_items to count.
     * @example
     * // Count the number of Estimasi_items
     * const count = await prisma.estimasi_item.count({
     *   where: {
     *     // ... the filter for the Estimasi_items we want to count
     *   }
     * })
    **/
    count<T extends estimasi_itemCountArgs>(
      args?: Subset<T, estimasi_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Estimasi_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estimasi_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Estimasi_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Estimasi_itemAggregateArgs>(args: Subset<T, Estimasi_itemAggregateArgs>): Prisma.PrismaPromise<GetEstimasi_itemAggregateType<T>>

    /**
     * Group by Estimasi_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estimasi_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estimasi_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estimasi_itemGroupByArgs['orderBy'] }
        : { orderBy?: estimasi_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estimasi_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstimasi_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estimasi_item model
   */
  readonly fields: estimasi_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estimasi_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estimasi_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estimasi_item model
   */ 
  interface estimasi_itemFieldRefs {
    readonly id: FieldRef<"estimasi_item", 'Int'>
    readonly tanggal: FieldRef<"estimasi_item", 'DateTime'>
    readonly id_estimasi: FieldRef<"estimasi_item", 'Int'>
    readonly id_produk: FieldRef<"estimasi_item", 'Int'>
    readonly id_supplier: FieldRef<"estimasi_item", 'Int'>
    readonly harga_beli: FieldRef<"estimasi_item", 'Decimal'>
    readonly harga_jual: FieldRef<"estimasi_item", 'Decimal'>
    readonly jumlah: FieldRef<"estimasi_item", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * estimasi_item findUnique
   */
  export type estimasi_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter, which estimasi_item to fetch.
     */
    where: estimasi_itemWhereUniqueInput
  }

  /**
   * estimasi_item findUniqueOrThrow
   */
  export type estimasi_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter, which estimasi_item to fetch.
     */
    where: estimasi_itemWhereUniqueInput
  }

  /**
   * estimasi_item findFirst
   */
  export type estimasi_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter, which estimasi_item to fetch.
     */
    where?: estimasi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasi_items to fetch.
     */
    orderBy?: estimasi_itemOrderByWithRelationInput | estimasi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimasi_items.
     */
    cursor?: estimasi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimasi_items.
     */
    distinct?: Estimasi_itemScalarFieldEnum | Estimasi_itemScalarFieldEnum[]
  }

  /**
   * estimasi_item findFirstOrThrow
   */
  export type estimasi_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter, which estimasi_item to fetch.
     */
    where?: estimasi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasi_items to fetch.
     */
    orderBy?: estimasi_itemOrderByWithRelationInput | estimasi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estimasi_items.
     */
    cursor?: estimasi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estimasi_items.
     */
    distinct?: Estimasi_itemScalarFieldEnum | Estimasi_itemScalarFieldEnum[]
  }

  /**
   * estimasi_item findMany
   */
  export type estimasi_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter, which estimasi_items to fetch.
     */
    where?: estimasi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estimasi_items to fetch.
     */
    orderBy?: estimasi_itemOrderByWithRelationInput | estimasi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estimasi_items.
     */
    cursor?: estimasi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estimasi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estimasi_items.
     */
    skip?: number
    distinct?: Estimasi_itemScalarFieldEnum | Estimasi_itemScalarFieldEnum[]
  }

  /**
   * estimasi_item create
   */
  export type estimasi_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * The data needed to create a estimasi_item.
     */
    data: XOR<estimasi_itemCreateInput, estimasi_itemUncheckedCreateInput>
  }

  /**
   * estimasi_item createMany
   */
  export type estimasi_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estimasi_items.
     */
    data: estimasi_itemCreateManyInput | estimasi_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estimasi_item update
   */
  export type estimasi_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * The data needed to update a estimasi_item.
     */
    data: XOR<estimasi_itemUpdateInput, estimasi_itemUncheckedUpdateInput>
    /**
     * Choose, which estimasi_item to update.
     */
    where: estimasi_itemWhereUniqueInput
  }

  /**
   * estimasi_item updateMany
   */
  export type estimasi_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estimasi_items.
     */
    data: XOR<estimasi_itemUpdateManyMutationInput, estimasi_itemUncheckedUpdateManyInput>
    /**
     * Filter which estimasi_items to update
     */
    where?: estimasi_itemWhereInput
  }

  /**
   * estimasi_item upsert
   */
  export type estimasi_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * The filter to search for the estimasi_item to update in case it exists.
     */
    where: estimasi_itemWhereUniqueInput
    /**
     * In case the estimasi_item found by the `where` argument doesn't exist, create a new estimasi_item with this data.
     */
    create: XOR<estimasi_itemCreateInput, estimasi_itemUncheckedCreateInput>
    /**
     * In case the estimasi_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estimasi_itemUpdateInput, estimasi_itemUncheckedUpdateInput>
  }

  /**
   * estimasi_item delete
   */
  export type estimasi_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
    /**
     * Filter which estimasi_item to delete.
     */
    where: estimasi_itemWhereUniqueInput
  }

  /**
   * estimasi_item deleteMany
   */
  export type estimasi_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estimasi_items to delete
     */
    where?: estimasi_itemWhereInput
  }

  /**
   * estimasi_item without action
   */
  export type estimasi_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estimasi_item
     */
    select?: estimasi_itemSelect<ExtArgs> | null
  }


  /**
   * Model inventaris
   */

  export type AggregateInventaris = {
    _count: InventarisCountAggregateOutputType | null
    _avg: InventarisAvgAggregateOutputType | null
    _sum: InventarisSumAggregateOutputType | null
    _min: InventarisMinAggregateOutputType | null
    _max: InventarisMaxAggregateOutputType | null
  }

  export type InventarisAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    nilai: Decimal | null
    persen: number | null
    sisa_2023: Decimal | null
  }

  export type InventarisSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    nilai: Decimal | null
    persen: number | null
    sisa_2023: Decimal | null
  }

  export type InventarisMinAggregateOutputType = {
    id: number | null
    jenis: number | null
    nama: string | null
    tanggal: Date | null
    nilai: Decimal | null
    persen: number | null
    sisa_2023: Decimal | null
    created: Date | null
    modified: Date | null
  }

  export type InventarisMaxAggregateOutputType = {
    id: number | null
    jenis: number | null
    nama: string | null
    tanggal: Date | null
    nilai: Decimal | null
    persen: number | null
    sisa_2023: Decimal | null
    created: Date | null
    modified: Date | null
  }

  export type InventarisCountAggregateOutputType = {
    id: number
    jenis: number
    nama: number
    tanggal: number
    nilai: number
    persen: number
    sisa_2023: number
    created: number
    modified: number
    _all: number
  }


  export type InventarisAvgAggregateInputType = {
    id?: true
    jenis?: true
    nilai?: true
    persen?: true
    sisa_2023?: true
  }

  export type InventarisSumAggregateInputType = {
    id?: true
    jenis?: true
    nilai?: true
    persen?: true
    sisa_2023?: true
  }

  export type InventarisMinAggregateInputType = {
    id?: true
    jenis?: true
    nama?: true
    tanggal?: true
    nilai?: true
    persen?: true
    sisa_2023?: true
    created?: true
    modified?: true
  }

  export type InventarisMaxAggregateInputType = {
    id?: true
    jenis?: true
    nama?: true
    tanggal?: true
    nilai?: true
    persen?: true
    sisa_2023?: true
    created?: true
    modified?: true
  }

  export type InventarisCountAggregateInputType = {
    id?: true
    jenis?: true
    nama?: true
    tanggal?: true
    nilai?: true
    persen?: true
    sisa_2023?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type InventarisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventaris to aggregate.
     */
    where?: inventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarises to fetch.
     */
    orderBy?: inventarisOrderByWithRelationInput | inventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventarises
    **/
    _count?: true | InventarisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventarisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventarisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventarisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventarisMaxAggregateInputType
  }

  export type GetInventarisAggregateType<T extends InventarisAggregateArgs> = {
        [P in keyof T & keyof AggregateInventaris]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventaris[P]>
      : GetScalarType<T[P], AggregateInventaris[P]>
  }




  export type inventarisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventarisWhereInput
    orderBy?: inventarisOrderByWithAggregationInput | inventarisOrderByWithAggregationInput[]
    by: InventarisScalarFieldEnum[] | InventarisScalarFieldEnum
    having?: inventarisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventarisCountAggregateInputType | true
    _avg?: InventarisAvgAggregateInputType
    _sum?: InventarisSumAggregateInputType
    _min?: InventarisMinAggregateInputType
    _max?: InventarisMaxAggregateInputType
  }

  export type InventarisGroupByOutputType = {
    id: number
    jenis: number
    nama: string
    tanggal: Date | null
    nilai: Decimal
    persen: number
    sisa_2023: Decimal
    created: Date | null
    modified: Date | null
    _count: InventarisCountAggregateOutputType | null
    _avg: InventarisAvgAggregateOutputType | null
    _sum: InventarisSumAggregateOutputType | null
    _min: InventarisMinAggregateOutputType | null
    _max: InventarisMaxAggregateOutputType | null
  }

  type GetInventarisGroupByPayload<T extends inventarisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventarisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventarisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventarisGroupByOutputType[P]>
            : GetScalarType<T[P], InventarisGroupByOutputType[P]>
        }
      >
    >


  export type inventarisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jenis?: boolean
    nama?: boolean
    tanggal?: boolean
    nilai?: boolean
    persen?: boolean
    sisa_2023?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["inventaris"]>


  export type inventarisSelectScalar = {
    id?: boolean
    jenis?: boolean
    nama?: boolean
    tanggal?: boolean
    nilai?: boolean
    persen?: boolean
    sisa_2023?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $inventarisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventaris"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jenis: number
      nama: string
      tanggal: Date | null
      nilai: Prisma.Decimal
      persen: number
      sisa_2023: Prisma.Decimal
      created: Date | null
      modified: Date | null
    }, ExtArgs["result"]["inventaris"]>
    composites: {}
  }

  type inventarisGetPayload<S extends boolean | null | undefined | inventarisDefaultArgs> = $Result.GetResult<Prisma.$inventarisPayload, S>

  type inventarisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventarisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventarisCountAggregateInputType | true
    }

  export interface inventarisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventaris'], meta: { name: 'inventaris' } }
    /**
     * Find zero or one Inventaris that matches the filter.
     * @param {inventarisFindUniqueArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventarisFindUniqueArgs>(args: SelectSubset<T, inventarisFindUniqueArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventaris that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {inventarisFindUniqueOrThrowArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventarisFindUniqueOrThrowArgs>(args: SelectSubset<T, inventarisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventaris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisFindFirstArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventarisFindFirstArgs>(args?: SelectSubset<T, inventarisFindFirstArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventaris that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisFindFirstOrThrowArgs} args - Arguments to find a Inventaris
     * @example
     * // Get one Inventaris
     * const inventaris = await prisma.inventaris.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventarisFindFirstOrThrowArgs>(args?: SelectSubset<T, inventarisFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventarises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventarises
     * const inventarises = await prisma.inventaris.findMany()
     * 
     * // Get first 10 Inventarises
     * const inventarises = await prisma.inventaris.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventarisWithIdOnly = await prisma.inventaris.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inventarisFindManyArgs>(args?: SelectSubset<T, inventarisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventaris.
     * @param {inventarisCreateArgs} args - Arguments to create a Inventaris.
     * @example
     * // Create one Inventaris
     * const Inventaris = await prisma.inventaris.create({
     *   data: {
     *     // ... data to create a Inventaris
     *   }
     * })
     * 
     */
    create<T extends inventarisCreateArgs>(args: SelectSubset<T, inventarisCreateArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventarises.
     * @param {inventarisCreateManyArgs} args - Arguments to create many Inventarises.
     * @example
     * // Create many Inventarises
     * const inventaris = await prisma.inventaris.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventarisCreateManyArgs>(args?: SelectSubset<T, inventarisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventaris.
     * @param {inventarisDeleteArgs} args - Arguments to delete one Inventaris.
     * @example
     * // Delete one Inventaris
     * const Inventaris = await prisma.inventaris.delete({
     *   where: {
     *     // ... filter to delete one Inventaris
     *   }
     * })
     * 
     */
    delete<T extends inventarisDeleteArgs>(args: SelectSubset<T, inventarisDeleteArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventaris.
     * @param {inventarisUpdateArgs} args - Arguments to update one Inventaris.
     * @example
     * // Update one Inventaris
     * const inventaris = await prisma.inventaris.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventarisUpdateArgs>(args: SelectSubset<T, inventarisUpdateArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventarises.
     * @param {inventarisDeleteManyArgs} args - Arguments to filter Inventarises to delete.
     * @example
     * // Delete a few Inventarises
     * const { count } = await prisma.inventaris.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventarisDeleteManyArgs>(args?: SelectSubset<T, inventarisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventarises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventarises
     * const inventaris = await prisma.inventaris.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventarisUpdateManyArgs>(args: SelectSubset<T, inventarisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventaris.
     * @param {inventarisUpsertArgs} args - Arguments to update or create a Inventaris.
     * @example
     * // Update or create a Inventaris
     * const inventaris = await prisma.inventaris.upsert({
     *   create: {
     *     // ... data to create a Inventaris
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventaris we want to update
     *   }
     * })
     */
    upsert<T extends inventarisUpsertArgs>(args: SelectSubset<T, inventarisUpsertArgs<ExtArgs>>): Prisma__inventarisClient<$Result.GetResult<Prisma.$inventarisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventarises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisCountArgs} args - Arguments to filter Inventarises to count.
     * @example
     * // Count the number of Inventarises
     * const count = await prisma.inventaris.count({
     *   where: {
     *     // ... the filter for the Inventarises we want to count
     *   }
     * })
    **/
    count<T extends inventarisCountArgs>(
      args?: Subset<T, inventarisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventarisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventaris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventarisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventarisAggregateArgs>(args: Subset<T, InventarisAggregateArgs>): Prisma.PrismaPromise<GetInventarisAggregateType<T>>

    /**
     * Group by Inventaris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventarisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventarisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventarisGroupByArgs['orderBy'] }
        : { orderBy?: inventarisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventarisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventarisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventaris model
   */
  readonly fields: inventarisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventaris.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventarisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventaris model
   */ 
  interface inventarisFieldRefs {
    readonly id: FieldRef<"inventaris", 'Int'>
    readonly jenis: FieldRef<"inventaris", 'Int'>
    readonly nama: FieldRef<"inventaris", 'String'>
    readonly tanggal: FieldRef<"inventaris", 'DateTime'>
    readonly nilai: FieldRef<"inventaris", 'Decimal'>
    readonly persen: FieldRef<"inventaris", 'Int'>
    readonly sisa_2023: FieldRef<"inventaris", 'Decimal'>
    readonly created: FieldRef<"inventaris", 'DateTime'>
    readonly modified: FieldRef<"inventaris", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventaris findUnique
   */
  export type inventarisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter, which inventaris to fetch.
     */
    where: inventarisWhereUniqueInput
  }

  /**
   * inventaris findUniqueOrThrow
   */
  export type inventarisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter, which inventaris to fetch.
     */
    where: inventarisWhereUniqueInput
  }

  /**
   * inventaris findFirst
   */
  export type inventarisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter, which inventaris to fetch.
     */
    where?: inventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarises to fetch.
     */
    orderBy?: inventarisOrderByWithRelationInput | inventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventarises.
     */
    cursor?: inventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventarises.
     */
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * inventaris findFirstOrThrow
   */
  export type inventarisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter, which inventaris to fetch.
     */
    where?: inventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarises to fetch.
     */
    orderBy?: inventarisOrderByWithRelationInput | inventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventarises.
     */
    cursor?: inventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventarises.
     */
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * inventaris findMany
   */
  export type inventarisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter, which inventarises to fetch.
     */
    where?: inventarisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventarises to fetch.
     */
    orderBy?: inventarisOrderByWithRelationInput | inventarisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventarises.
     */
    cursor?: inventarisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventarises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventarises.
     */
    skip?: number
    distinct?: InventarisScalarFieldEnum | InventarisScalarFieldEnum[]
  }

  /**
   * inventaris create
   */
  export type inventarisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * The data needed to create a inventaris.
     */
    data: XOR<inventarisCreateInput, inventarisUncheckedCreateInput>
  }

  /**
   * inventaris createMany
   */
  export type inventarisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventarises.
     */
    data: inventarisCreateManyInput | inventarisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventaris update
   */
  export type inventarisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * The data needed to update a inventaris.
     */
    data: XOR<inventarisUpdateInput, inventarisUncheckedUpdateInput>
    /**
     * Choose, which inventaris to update.
     */
    where: inventarisWhereUniqueInput
  }

  /**
   * inventaris updateMany
   */
  export type inventarisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventarises.
     */
    data: XOR<inventarisUpdateManyMutationInput, inventarisUncheckedUpdateManyInput>
    /**
     * Filter which inventarises to update
     */
    where?: inventarisWhereInput
  }

  /**
   * inventaris upsert
   */
  export type inventarisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * The filter to search for the inventaris to update in case it exists.
     */
    where: inventarisWhereUniqueInput
    /**
     * In case the inventaris found by the `where` argument doesn't exist, create a new inventaris with this data.
     */
    create: XOR<inventarisCreateInput, inventarisUncheckedCreateInput>
    /**
     * In case the inventaris was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventarisUpdateInput, inventarisUncheckedUpdateInput>
  }

  /**
   * inventaris delete
   */
  export type inventarisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
    /**
     * Filter which inventaris to delete.
     */
    where: inventarisWhereUniqueInput
  }

  /**
   * inventaris deleteMany
   */
  export type inventarisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventarises to delete
     */
    where?: inventarisWhereInput
  }

  /**
   * inventaris without action
   */
  export type inventarisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventaris
     */
    select?: inventarisSelect<ExtArgs> | null
  }


  /**
   * Model pelunasan_pembelian
   */

  export type AggregatePelunasan_pembelian = {
    _count: Pelunasan_pembelianCountAggregateOutputType | null
    _avg: Pelunasan_pembelianAvgAggregateOutputType | null
    _sum: Pelunasan_pembelianSumAggregateOutputType | null
    _min: Pelunasan_pembelianMinAggregateOutputType | null
    _max: Pelunasan_pembelianMaxAggregateOutputType | null
  }

  export type Pelunasan_pembelianAvgAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    jumlah: Decimal | null
  }

  export type Pelunasan_pembelianSumAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    jumlah: Decimal | null
  }

  export type Pelunasan_pembelianMinAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    tanggal: Date | null
    jumlah: Decimal | null
    keterangan: string | null
  }

  export type Pelunasan_pembelianMaxAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    tanggal: Date | null
    jumlah: Decimal | null
    keterangan: string | null
  }

  export type Pelunasan_pembelianCountAggregateOutputType = {
    id: number
    id_supplier: number
    id_transaksi: number
    tanggal: number
    jumlah: number
    keterangan: number
    _all: number
  }


  export type Pelunasan_pembelianAvgAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    jumlah?: true
  }

  export type Pelunasan_pembelianSumAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    jumlah?: true
  }

  export type Pelunasan_pembelianMinAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    tanggal?: true
    jumlah?: true
    keterangan?: true
  }

  export type Pelunasan_pembelianMaxAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    tanggal?: true
    jumlah?: true
    keterangan?: true
  }

  export type Pelunasan_pembelianCountAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    tanggal?: true
    jumlah?: true
    keterangan?: true
    _all?: true
  }

  export type Pelunasan_pembelianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pelunasan_pembelian to aggregate.
     */
    where?: pelunasan_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pelunasan_pembelians to fetch.
     */
    orderBy?: pelunasan_pembelianOrderByWithRelationInput | pelunasan_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pelunasan_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pelunasan_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pelunasan_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pelunasan_pembelians
    **/
    _count?: true | Pelunasan_pembelianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pelunasan_pembelianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pelunasan_pembelianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pelunasan_pembelianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pelunasan_pembelianMaxAggregateInputType
  }

  export type GetPelunasan_pembelianAggregateType<T extends Pelunasan_pembelianAggregateArgs> = {
        [P in keyof T & keyof AggregatePelunasan_pembelian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePelunasan_pembelian[P]>
      : GetScalarType<T[P], AggregatePelunasan_pembelian[P]>
  }




  export type pelunasan_pembelianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pelunasan_pembelianWhereInput
    orderBy?: pelunasan_pembelianOrderByWithAggregationInput | pelunasan_pembelianOrderByWithAggregationInput[]
    by: Pelunasan_pembelianScalarFieldEnum[] | Pelunasan_pembelianScalarFieldEnum
    having?: pelunasan_pembelianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pelunasan_pembelianCountAggregateInputType | true
    _avg?: Pelunasan_pembelianAvgAggregateInputType
    _sum?: Pelunasan_pembelianSumAggregateInputType
    _min?: Pelunasan_pembelianMinAggregateInputType
    _max?: Pelunasan_pembelianMaxAggregateInputType
  }

  export type Pelunasan_pembelianGroupByOutputType = {
    id: number
    id_supplier: number
    id_transaksi: number
    tanggal: Date | null
    jumlah: Decimal
    keterangan: string
    _count: Pelunasan_pembelianCountAggregateOutputType | null
    _avg: Pelunasan_pembelianAvgAggregateOutputType | null
    _sum: Pelunasan_pembelianSumAggregateOutputType | null
    _min: Pelunasan_pembelianMinAggregateOutputType | null
    _max: Pelunasan_pembelianMaxAggregateOutputType | null
  }

  type GetPelunasan_pembelianGroupByPayload<T extends pelunasan_pembelianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pelunasan_pembelianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pelunasan_pembelianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pelunasan_pembelianGroupByOutputType[P]>
            : GetScalarType<T[P], Pelunasan_pembelianGroupByOutputType[P]>
        }
      >
    >


  export type pelunasan_pembelianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_supplier?: boolean
    id_transaksi?: boolean
    tanggal?: boolean
    jumlah?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["pelunasan_pembelian"]>


  export type pelunasan_pembelianSelectScalar = {
    id?: boolean
    id_supplier?: boolean
    id_transaksi?: boolean
    tanggal?: boolean
    jumlah?: boolean
    keterangan?: boolean
  }


  export type $pelunasan_pembelianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pelunasan_pembelian"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_supplier: number
      id_transaksi: number
      tanggal: Date | null
      jumlah: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["pelunasan_pembelian"]>
    composites: {}
  }

  type pelunasan_pembelianGetPayload<S extends boolean | null | undefined | pelunasan_pembelianDefaultArgs> = $Result.GetResult<Prisma.$pelunasan_pembelianPayload, S>

  type pelunasan_pembelianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pelunasan_pembelianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pelunasan_pembelianCountAggregateInputType | true
    }

  export interface pelunasan_pembelianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pelunasan_pembelian'], meta: { name: 'pelunasan_pembelian' } }
    /**
     * Find zero or one Pelunasan_pembelian that matches the filter.
     * @param {pelunasan_pembelianFindUniqueArgs} args - Arguments to find a Pelunasan_pembelian
     * @example
     * // Get one Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pelunasan_pembelianFindUniqueArgs>(args: SelectSubset<T, pelunasan_pembelianFindUniqueArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pelunasan_pembelian that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pelunasan_pembelianFindUniqueOrThrowArgs} args - Arguments to find a Pelunasan_pembelian
     * @example
     * // Get one Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pelunasan_pembelianFindUniqueOrThrowArgs>(args: SelectSubset<T, pelunasan_pembelianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pelunasan_pembelian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianFindFirstArgs} args - Arguments to find a Pelunasan_pembelian
     * @example
     * // Get one Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pelunasan_pembelianFindFirstArgs>(args?: SelectSubset<T, pelunasan_pembelianFindFirstArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pelunasan_pembelian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianFindFirstOrThrowArgs} args - Arguments to find a Pelunasan_pembelian
     * @example
     * // Get one Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pelunasan_pembelianFindFirstOrThrowArgs>(args?: SelectSubset<T, pelunasan_pembelianFindFirstOrThrowArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pelunasan_pembelians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pelunasan_pembelians
     * const pelunasan_pembelians = await prisma.pelunasan_pembelian.findMany()
     * 
     * // Get first 10 Pelunasan_pembelians
     * const pelunasan_pembelians = await prisma.pelunasan_pembelian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pelunasan_pembelianWithIdOnly = await prisma.pelunasan_pembelian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pelunasan_pembelianFindManyArgs>(args?: SelectSubset<T, pelunasan_pembelianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pelunasan_pembelian.
     * @param {pelunasan_pembelianCreateArgs} args - Arguments to create a Pelunasan_pembelian.
     * @example
     * // Create one Pelunasan_pembelian
     * const Pelunasan_pembelian = await prisma.pelunasan_pembelian.create({
     *   data: {
     *     // ... data to create a Pelunasan_pembelian
     *   }
     * })
     * 
     */
    create<T extends pelunasan_pembelianCreateArgs>(args: SelectSubset<T, pelunasan_pembelianCreateArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pelunasan_pembelians.
     * @param {pelunasan_pembelianCreateManyArgs} args - Arguments to create many Pelunasan_pembelians.
     * @example
     * // Create many Pelunasan_pembelians
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pelunasan_pembelianCreateManyArgs>(args?: SelectSubset<T, pelunasan_pembelianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pelunasan_pembelian.
     * @param {pelunasan_pembelianDeleteArgs} args - Arguments to delete one Pelunasan_pembelian.
     * @example
     * // Delete one Pelunasan_pembelian
     * const Pelunasan_pembelian = await prisma.pelunasan_pembelian.delete({
     *   where: {
     *     // ... filter to delete one Pelunasan_pembelian
     *   }
     * })
     * 
     */
    delete<T extends pelunasan_pembelianDeleteArgs>(args: SelectSubset<T, pelunasan_pembelianDeleteArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pelunasan_pembelian.
     * @param {pelunasan_pembelianUpdateArgs} args - Arguments to update one Pelunasan_pembelian.
     * @example
     * // Update one Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pelunasan_pembelianUpdateArgs>(args: SelectSubset<T, pelunasan_pembelianUpdateArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pelunasan_pembelians.
     * @param {pelunasan_pembelianDeleteManyArgs} args - Arguments to filter Pelunasan_pembelians to delete.
     * @example
     * // Delete a few Pelunasan_pembelians
     * const { count } = await prisma.pelunasan_pembelian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pelunasan_pembelianDeleteManyArgs>(args?: SelectSubset<T, pelunasan_pembelianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pelunasan_pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pelunasan_pembelians
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pelunasan_pembelianUpdateManyArgs>(args: SelectSubset<T, pelunasan_pembelianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pelunasan_pembelian.
     * @param {pelunasan_pembelianUpsertArgs} args - Arguments to update or create a Pelunasan_pembelian.
     * @example
     * // Update or create a Pelunasan_pembelian
     * const pelunasan_pembelian = await prisma.pelunasan_pembelian.upsert({
     *   create: {
     *     // ... data to create a Pelunasan_pembelian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pelunasan_pembelian we want to update
     *   }
     * })
     */
    upsert<T extends pelunasan_pembelianUpsertArgs>(args: SelectSubset<T, pelunasan_pembelianUpsertArgs<ExtArgs>>): Prisma__pelunasan_pembelianClient<$Result.GetResult<Prisma.$pelunasan_pembelianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pelunasan_pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianCountArgs} args - Arguments to filter Pelunasan_pembelians to count.
     * @example
     * // Count the number of Pelunasan_pembelians
     * const count = await prisma.pelunasan_pembelian.count({
     *   where: {
     *     // ... the filter for the Pelunasan_pembelians we want to count
     *   }
     * })
    **/
    count<T extends pelunasan_pembelianCountArgs>(
      args?: Subset<T, pelunasan_pembelianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pelunasan_pembelianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pelunasan_pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pelunasan_pembelianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pelunasan_pembelianAggregateArgs>(args: Subset<T, Pelunasan_pembelianAggregateArgs>): Prisma.PrismaPromise<GetPelunasan_pembelianAggregateType<T>>

    /**
     * Group by Pelunasan_pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pelunasan_pembelianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pelunasan_pembelianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pelunasan_pembelianGroupByArgs['orderBy'] }
        : { orderBy?: pelunasan_pembelianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pelunasan_pembelianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPelunasan_pembelianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pelunasan_pembelian model
   */
  readonly fields: pelunasan_pembelianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pelunasan_pembelian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pelunasan_pembelianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pelunasan_pembelian model
   */ 
  interface pelunasan_pembelianFieldRefs {
    readonly id: FieldRef<"pelunasan_pembelian", 'Int'>
    readonly id_supplier: FieldRef<"pelunasan_pembelian", 'Int'>
    readonly id_transaksi: FieldRef<"pelunasan_pembelian", 'Int'>
    readonly tanggal: FieldRef<"pelunasan_pembelian", 'DateTime'>
    readonly jumlah: FieldRef<"pelunasan_pembelian", 'Decimal'>
    readonly keterangan: FieldRef<"pelunasan_pembelian", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pelunasan_pembelian findUnique
   */
  export type pelunasan_pembelianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter, which pelunasan_pembelian to fetch.
     */
    where: pelunasan_pembelianWhereUniqueInput
  }

  /**
   * pelunasan_pembelian findUniqueOrThrow
   */
  export type pelunasan_pembelianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter, which pelunasan_pembelian to fetch.
     */
    where: pelunasan_pembelianWhereUniqueInput
  }

  /**
   * pelunasan_pembelian findFirst
   */
  export type pelunasan_pembelianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter, which pelunasan_pembelian to fetch.
     */
    where?: pelunasan_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pelunasan_pembelians to fetch.
     */
    orderBy?: pelunasan_pembelianOrderByWithRelationInput | pelunasan_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pelunasan_pembelians.
     */
    cursor?: pelunasan_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pelunasan_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pelunasan_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pelunasan_pembelians.
     */
    distinct?: Pelunasan_pembelianScalarFieldEnum | Pelunasan_pembelianScalarFieldEnum[]
  }

  /**
   * pelunasan_pembelian findFirstOrThrow
   */
  export type pelunasan_pembelianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter, which pelunasan_pembelian to fetch.
     */
    where?: pelunasan_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pelunasan_pembelians to fetch.
     */
    orderBy?: pelunasan_pembelianOrderByWithRelationInput | pelunasan_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pelunasan_pembelians.
     */
    cursor?: pelunasan_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pelunasan_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pelunasan_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pelunasan_pembelians.
     */
    distinct?: Pelunasan_pembelianScalarFieldEnum | Pelunasan_pembelianScalarFieldEnum[]
  }

  /**
   * pelunasan_pembelian findMany
   */
  export type pelunasan_pembelianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter, which pelunasan_pembelians to fetch.
     */
    where?: pelunasan_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pelunasan_pembelians to fetch.
     */
    orderBy?: pelunasan_pembelianOrderByWithRelationInput | pelunasan_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pelunasan_pembelians.
     */
    cursor?: pelunasan_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pelunasan_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pelunasan_pembelians.
     */
    skip?: number
    distinct?: Pelunasan_pembelianScalarFieldEnum | Pelunasan_pembelianScalarFieldEnum[]
  }

  /**
   * pelunasan_pembelian create
   */
  export type pelunasan_pembelianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * The data needed to create a pelunasan_pembelian.
     */
    data: XOR<pelunasan_pembelianCreateInput, pelunasan_pembelianUncheckedCreateInput>
  }

  /**
   * pelunasan_pembelian createMany
   */
  export type pelunasan_pembelianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pelunasan_pembelians.
     */
    data: pelunasan_pembelianCreateManyInput | pelunasan_pembelianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pelunasan_pembelian update
   */
  export type pelunasan_pembelianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * The data needed to update a pelunasan_pembelian.
     */
    data: XOR<pelunasan_pembelianUpdateInput, pelunasan_pembelianUncheckedUpdateInput>
    /**
     * Choose, which pelunasan_pembelian to update.
     */
    where: pelunasan_pembelianWhereUniqueInput
  }

  /**
   * pelunasan_pembelian updateMany
   */
  export type pelunasan_pembelianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pelunasan_pembelians.
     */
    data: XOR<pelunasan_pembelianUpdateManyMutationInput, pelunasan_pembelianUncheckedUpdateManyInput>
    /**
     * Filter which pelunasan_pembelians to update
     */
    where?: pelunasan_pembelianWhereInput
  }

  /**
   * pelunasan_pembelian upsert
   */
  export type pelunasan_pembelianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * The filter to search for the pelunasan_pembelian to update in case it exists.
     */
    where: pelunasan_pembelianWhereUniqueInput
    /**
     * In case the pelunasan_pembelian found by the `where` argument doesn't exist, create a new pelunasan_pembelian with this data.
     */
    create: XOR<pelunasan_pembelianCreateInput, pelunasan_pembelianUncheckedCreateInput>
    /**
     * In case the pelunasan_pembelian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pelunasan_pembelianUpdateInput, pelunasan_pembelianUncheckedUpdateInput>
  }

  /**
   * pelunasan_pembelian delete
   */
  export type pelunasan_pembelianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
    /**
     * Filter which pelunasan_pembelian to delete.
     */
    where: pelunasan_pembelianWhereUniqueInput
  }

  /**
   * pelunasan_pembelian deleteMany
   */
  export type pelunasan_pembelianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pelunasan_pembelians to delete
     */
    where?: pelunasan_pembelianWhereInput
  }

  /**
   * pelunasan_pembelian without action
   */
  export type pelunasan_pembelianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pelunasan_pembelian
     */
    select?: pelunasan_pembelianSelect<ExtArgs> | null
  }


  /**
   * Model pemusnahan
   */

  export type AggregatePemusnahan = {
    _count: PemusnahanCountAggregateOutputType | null
    _avg: PemusnahanAvgAggregateOutputType | null
    _sum: PemusnahanSumAggregateOutputType | null
    _min: PemusnahanMinAggregateOutputType | null
    _max: PemusnahanMaxAggregateOutputType | null
  }

  export type PemusnahanAvgAggregateOutputType = {
    id: number | null
    jumlah: Decimal | null
    jumlah_fix: Decimal | null
    jangka: number | null
  }

  export type PemusnahanSumAggregateOutputType = {
    id: number | null
    jumlah: Decimal | null
    jumlah_fix: Decimal | null
    jangka: number | null
  }

  export type PemusnahanMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jumlah: Decimal | null
    jumlah_fix: Decimal | null
    jangka: number | null
    keterangan: string | null
  }

  export type PemusnahanMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jumlah: Decimal | null
    jumlah_fix: Decimal | null
    jangka: number | null
    keterangan: string | null
  }

  export type PemusnahanCountAggregateOutputType = {
    id: number
    tanggal: number
    jumlah: number
    jumlah_fix: number
    jangka: number
    keterangan: number
    _all: number
  }


  export type PemusnahanAvgAggregateInputType = {
    id?: true
    jumlah?: true
    jumlah_fix?: true
    jangka?: true
  }

  export type PemusnahanSumAggregateInputType = {
    id?: true
    jumlah?: true
    jumlah_fix?: true
    jangka?: true
  }

  export type PemusnahanMinAggregateInputType = {
    id?: true
    tanggal?: true
    jumlah?: true
    jumlah_fix?: true
    jangka?: true
    keterangan?: true
  }

  export type PemusnahanMaxAggregateInputType = {
    id?: true
    tanggal?: true
    jumlah?: true
    jumlah_fix?: true
    jangka?: true
    keterangan?: true
  }

  export type PemusnahanCountAggregateInputType = {
    id?: true
    tanggal?: true
    jumlah?: true
    jumlah_fix?: true
    jangka?: true
    keterangan?: true
    _all?: true
  }

  export type PemusnahanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pemusnahan to aggregate.
     */
    where?: pemusnahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemusnahans to fetch.
     */
    orderBy?: pemusnahanOrderByWithRelationInput | pemusnahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pemusnahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemusnahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemusnahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pemusnahans
    **/
    _count?: true | PemusnahanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PemusnahanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PemusnahanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PemusnahanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PemusnahanMaxAggregateInputType
  }

  export type GetPemusnahanAggregateType<T extends PemusnahanAggregateArgs> = {
        [P in keyof T & keyof AggregatePemusnahan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePemusnahan[P]>
      : GetScalarType<T[P], AggregatePemusnahan[P]>
  }




  export type pemusnahanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pemusnahanWhereInput
    orderBy?: pemusnahanOrderByWithAggregationInput | pemusnahanOrderByWithAggregationInput[]
    by: PemusnahanScalarFieldEnum[] | PemusnahanScalarFieldEnum
    having?: pemusnahanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PemusnahanCountAggregateInputType | true
    _avg?: PemusnahanAvgAggregateInputType
    _sum?: PemusnahanSumAggregateInputType
    _min?: PemusnahanMinAggregateInputType
    _max?: PemusnahanMaxAggregateInputType
  }

  export type PemusnahanGroupByOutputType = {
    id: number
    tanggal: Date
    jumlah: Decimal
    jumlah_fix: Decimal
    jangka: number
    keterangan: string
    _count: PemusnahanCountAggregateOutputType | null
    _avg: PemusnahanAvgAggregateOutputType | null
    _sum: PemusnahanSumAggregateOutputType | null
    _min: PemusnahanMinAggregateOutputType | null
    _max: PemusnahanMaxAggregateOutputType | null
  }

  type GetPemusnahanGroupByPayload<T extends pemusnahanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PemusnahanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PemusnahanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PemusnahanGroupByOutputType[P]>
            : GetScalarType<T[P], PemusnahanGroupByOutputType[P]>
        }
      >
    >


  export type pemusnahanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    jumlah?: boolean
    jumlah_fix?: boolean
    jangka?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["pemusnahan"]>


  export type pemusnahanSelectScalar = {
    id?: boolean
    tanggal?: boolean
    jumlah?: boolean
    jumlah_fix?: boolean
    jangka?: boolean
    keterangan?: boolean
  }


  export type $pemusnahanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pemusnahan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      jumlah: Prisma.Decimal
      jumlah_fix: Prisma.Decimal
      jangka: number
      keterangan: string
    }, ExtArgs["result"]["pemusnahan"]>
    composites: {}
  }

  type pemusnahanGetPayload<S extends boolean | null | undefined | pemusnahanDefaultArgs> = $Result.GetResult<Prisma.$pemusnahanPayload, S>

  type pemusnahanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pemusnahanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PemusnahanCountAggregateInputType | true
    }

  export interface pemusnahanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pemusnahan'], meta: { name: 'pemusnahan' } }
    /**
     * Find zero or one Pemusnahan that matches the filter.
     * @param {pemusnahanFindUniqueArgs} args - Arguments to find a Pemusnahan
     * @example
     * // Get one Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pemusnahanFindUniqueArgs>(args: SelectSubset<T, pemusnahanFindUniqueArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pemusnahan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pemusnahanFindUniqueOrThrowArgs} args - Arguments to find a Pemusnahan
     * @example
     * // Get one Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pemusnahanFindUniqueOrThrowArgs>(args: SelectSubset<T, pemusnahanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pemusnahan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanFindFirstArgs} args - Arguments to find a Pemusnahan
     * @example
     * // Get one Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pemusnahanFindFirstArgs>(args?: SelectSubset<T, pemusnahanFindFirstArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pemusnahan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanFindFirstOrThrowArgs} args - Arguments to find a Pemusnahan
     * @example
     * // Get one Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pemusnahanFindFirstOrThrowArgs>(args?: SelectSubset<T, pemusnahanFindFirstOrThrowArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pemusnahans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pemusnahans
     * const pemusnahans = await prisma.pemusnahan.findMany()
     * 
     * // Get first 10 Pemusnahans
     * const pemusnahans = await prisma.pemusnahan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pemusnahanWithIdOnly = await prisma.pemusnahan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pemusnahanFindManyArgs>(args?: SelectSubset<T, pemusnahanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pemusnahan.
     * @param {pemusnahanCreateArgs} args - Arguments to create a Pemusnahan.
     * @example
     * // Create one Pemusnahan
     * const Pemusnahan = await prisma.pemusnahan.create({
     *   data: {
     *     // ... data to create a Pemusnahan
     *   }
     * })
     * 
     */
    create<T extends pemusnahanCreateArgs>(args: SelectSubset<T, pemusnahanCreateArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pemusnahans.
     * @param {pemusnahanCreateManyArgs} args - Arguments to create many Pemusnahans.
     * @example
     * // Create many Pemusnahans
     * const pemusnahan = await prisma.pemusnahan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pemusnahanCreateManyArgs>(args?: SelectSubset<T, pemusnahanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pemusnahan.
     * @param {pemusnahanDeleteArgs} args - Arguments to delete one Pemusnahan.
     * @example
     * // Delete one Pemusnahan
     * const Pemusnahan = await prisma.pemusnahan.delete({
     *   where: {
     *     // ... filter to delete one Pemusnahan
     *   }
     * })
     * 
     */
    delete<T extends pemusnahanDeleteArgs>(args: SelectSubset<T, pemusnahanDeleteArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pemusnahan.
     * @param {pemusnahanUpdateArgs} args - Arguments to update one Pemusnahan.
     * @example
     * // Update one Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pemusnahanUpdateArgs>(args: SelectSubset<T, pemusnahanUpdateArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pemusnahans.
     * @param {pemusnahanDeleteManyArgs} args - Arguments to filter Pemusnahans to delete.
     * @example
     * // Delete a few Pemusnahans
     * const { count } = await prisma.pemusnahan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pemusnahanDeleteManyArgs>(args?: SelectSubset<T, pemusnahanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pemusnahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pemusnahans
     * const pemusnahan = await prisma.pemusnahan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pemusnahanUpdateManyArgs>(args: SelectSubset<T, pemusnahanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pemusnahan.
     * @param {pemusnahanUpsertArgs} args - Arguments to update or create a Pemusnahan.
     * @example
     * // Update or create a Pemusnahan
     * const pemusnahan = await prisma.pemusnahan.upsert({
     *   create: {
     *     // ... data to create a Pemusnahan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pemusnahan we want to update
     *   }
     * })
     */
    upsert<T extends pemusnahanUpsertArgs>(args: SelectSubset<T, pemusnahanUpsertArgs<ExtArgs>>): Prisma__pemusnahanClient<$Result.GetResult<Prisma.$pemusnahanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pemusnahans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanCountArgs} args - Arguments to filter Pemusnahans to count.
     * @example
     * // Count the number of Pemusnahans
     * const count = await prisma.pemusnahan.count({
     *   where: {
     *     // ... the filter for the Pemusnahans we want to count
     *   }
     * })
    **/
    count<T extends pemusnahanCountArgs>(
      args?: Subset<T, pemusnahanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PemusnahanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pemusnahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemusnahanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PemusnahanAggregateArgs>(args: Subset<T, PemusnahanAggregateArgs>): Prisma.PrismaPromise<GetPemusnahanAggregateType<T>>

    /**
     * Group by Pemusnahan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pemusnahanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pemusnahanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pemusnahanGroupByArgs['orderBy'] }
        : { orderBy?: pemusnahanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pemusnahanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPemusnahanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pemusnahan model
   */
  readonly fields: pemusnahanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pemusnahan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pemusnahanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pemusnahan model
   */ 
  interface pemusnahanFieldRefs {
    readonly id: FieldRef<"pemusnahan", 'Int'>
    readonly tanggal: FieldRef<"pemusnahan", 'DateTime'>
    readonly jumlah: FieldRef<"pemusnahan", 'Decimal'>
    readonly jumlah_fix: FieldRef<"pemusnahan", 'Decimal'>
    readonly jangka: FieldRef<"pemusnahan", 'Int'>
    readonly keterangan: FieldRef<"pemusnahan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pemusnahan findUnique
   */
  export type pemusnahanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter, which pemusnahan to fetch.
     */
    where: pemusnahanWhereUniqueInput
  }

  /**
   * pemusnahan findUniqueOrThrow
   */
  export type pemusnahanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter, which pemusnahan to fetch.
     */
    where: pemusnahanWhereUniqueInput
  }

  /**
   * pemusnahan findFirst
   */
  export type pemusnahanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter, which pemusnahan to fetch.
     */
    where?: pemusnahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemusnahans to fetch.
     */
    orderBy?: pemusnahanOrderByWithRelationInput | pemusnahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pemusnahans.
     */
    cursor?: pemusnahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemusnahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemusnahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pemusnahans.
     */
    distinct?: PemusnahanScalarFieldEnum | PemusnahanScalarFieldEnum[]
  }

  /**
   * pemusnahan findFirstOrThrow
   */
  export type pemusnahanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter, which pemusnahan to fetch.
     */
    where?: pemusnahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemusnahans to fetch.
     */
    orderBy?: pemusnahanOrderByWithRelationInput | pemusnahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pemusnahans.
     */
    cursor?: pemusnahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemusnahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemusnahans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pemusnahans.
     */
    distinct?: PemusnahanScalarFieldEnum | PemusnahanScalarFieldEnum[]
  }

  /**
   * pemusnahan findMany
   */
  export type pemusnahanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter, which pemusnahans to fetch.
     */
    where?: pemusnahanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pemusnahans to fetch.
     */
    orderBy?: pemusnahanOrderByWithRelationInput | pemusnahanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pemusnahans.
     */
    cursor?: pemusnahanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pemusnahans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pemusnahans.
     */
    skip?: number
    distinct?: PemusnahanScalarFieldEnum | PemusnahanScalarFieldEnum[]
  }

  /**
   * pemusnahan create
   */
  export type pemusnahanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * The data needed to create a pemusnahan.
     */
    data: XOR<pemusnahanCreateInput, pemusnahanUncheckedCreateInput>
  }

  /**
   * pemusnahan createMany
   */
  export type pemusnahanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pemusnahans.
     */
    data: pemusnahanCreateManyInput | pemusnahanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pemusnahan update
   */
  export type pemusnahanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * The data needed to update a pemusnahan.
     */
    data: XOR<pemusnahanUpdateInput, pemusnahanUncheckedUpdateInput>
    /**
     * Choose, which pemusnahan to update.
     */
    where: pemusnahanWhereUniqueInput
  }

  /**
   * pemusnahan updateMany
   */
  export type pemusnahanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pemusnahans.
     */
    data: XOR<pemusnahanUpdateManyMutationInput, pemusnahanUncheckedUpdateManyInput>
    /**
     * Filter which pemusnahans to update
     */
    where?: pemusnahanWhereInput
  }

  /**
   * pemusnahan upsert
   */
  export type pemusnahanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * The filter to search for the pemusnahan to update in case it exists.
     */
    where: pemusnahanWhereUniqueInput
    /**
     * In case the pemusnahan found by the `where` argument doesn't exist, create a new pemusnahan with this data.
     */
    create: XOR<pemusnahanCreateInput, pemusnahanUncheckedCreateInput>
    /**
     * In case the pemusnahan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pemusnahanUpdateInput, pemusnahanUncheckedUpdateInput>
  }

  /**
   * pemusnahan delete
   */
  export type pemusnahanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
    /**
     * Filter which pemusnahan to delete.
     */
    where: pemusnahanWhereUniqueInput
  }

  /**
   * pemusnahan deleteMany
   */
  export type pemusnahanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pemusnahans to delete
     */
    where?: pemusnahanWhereInput
  }

  /**
   * pemusnahan without action
   */
  export type pemusnahanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pemusnahan
     */
    select?: pemusnahanSelect<ExtArgs> | null
  }


  /**
   * Model produk
   */

  export type AggregateProduk = {
    _count: ProdukCountAggregateOutputType | null
    _avg: ProdukAvgAggregateOutputType | null
    _sum: ProdukSumAggregateOutputType | null
    _min: ProdukMinAggregateOutputType | null
    _max: ProdukMaxAggregateOutputType | null
  }

  export type ProdukAvgAggregateOutputType = {
    id: number | null
    divisi: number | null
    supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
    status: number | null
  }

  export type ProdukSumAggregateOutputType = {
    id: number | null
    divisi: number | null
    supplier: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
    status: number | null
  }

  export type ProdukMinAggregateOutputType = {
    id: number | null
    divisi: number | null
    supplier: number | null
    kode: string | null
    nama: string | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
    keterangan: string | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type ProdukMaxAggregateOutputType = {
    id: number | null
    divisi: number | null
    supplier: number | null
    kode: string | null
    nama: string | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
    keterangan: string | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type ProdukCountAggregateOutputType = {
    id: number
    divisi: number
    supplier: number
    kode: number
    nama: number
    harga_beli: number
    harga_jual: number
    jumlah: number
    diskon: number
    keterangan: number
    status: number
    created: number
    modified: number
    _all: number
  }


  export type ProdukAvgAggregateInputType = {
    id?: true
    divisi?: true
    supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    status?: true
  }

  export type ProdukSumAggregateInputType = {
    id?: true
    divisi?: true
    supplier?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    status?: true
  }

  export type ProdukMinAggregateInputType = {
    id?: true
    divisi?: true
    supplier?: true
    kode?: true
    nama?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    keterangan?: true
    status?: true
    created?: true
    modified?: true
  }

  export type ProdukMaxAggregateInputType = {
    id?: true
    divisi?: true
    supplier?: true
    kode?: true
    nama?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    keterangan?: true
    status?: true
    created?: true
    modified?: true
  }

  export type ProdukCountAggregateInputType = {
    id?: true
    divisi?: true
    supplier?: true
    kode?: true
    nama?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    keterangan?: true
    status?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type ProdukAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produk to aggregate.
     */
    where?: produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produks to fetch.
     */
    orderBy?: produkOrderByWithRelationInput | produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produks
    **/
    _count?: true | ProdukCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdukAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdukSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdukMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdukMaxAggregateInputType
  }

  export type GetProdukAggregateType<T extends ProdukAggregateArgs> = {
        [P in keyof T & keyof AggregateProduk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduk[P]>
      : GetScalarType<T[P], AggregateProduk[P]>
  }




  export type produkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produkWhereInput
    orderBy?: produkOrderByWithAggregationInput | produkOrderByWithAggregationInput[]
    by: ProdukScalarFieldEnum[] | ProdukScalarFieldEnum
    having?: produkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdukCountAggregateInputType | true
    _avg?: ProdukAvgAggregateInputType
    _sum?: ProdukSumAggregateInputType
    _min?: ProdukMinAggregateInputType
    _max?: ProdukMaxAggregateInputType
  }

  export type ProdukGroupByOutputType = {
    id: number
    divisi: number
    supplier: number
    kode: string
    nama: string
    harga_beli: Decimal
    harga_jual: Decimal
    jumlah: number
    diskon: number
    keterangan: string
    status: number
    created: Date
    modified: Date
    _count: ProdukCountAggregateOutputType | null
    _avg: ProdukAvgAggregateOutputType | null
    _sum: ProdukSumAggregateOutputType | null
    _min: ProdukMinAggregateOutputType | null
    _max: ProdukMaxAggregateOutputType | null
  }

  type GetProdukGroupByPayload<T extends produkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProdukGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdukGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdukGroupByOutputType[P]>
            : GetScalarType<T[P], ProdukGroupByOutputType[P]>
        }
      >
    >


  export type produkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    divisi?: boolean
    supplier?: boolean
    kode?: boolean
    nama?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
    diskon?: boolean
    keterangan?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["produk"]>


  export type produkSelectScalar = {
    id?: boolean
    divisi?: boolean
    supplier?: boolean
    kode?: boolean
    nama?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
    diskon?: boolean
    keterangan?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $produkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "produk"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      divisi: number
      supplier: number
      kode: string
      nama: string
      harga_beli: Prisma.Decimal
      harga_jual: Prisma.Decimal
      jumlah: number
      diskon: number
      keterangan: string
      status: number
      created: Date
      modified: Date
    }, ExtArgs["result"]["produk"]>
    composites: {}
  }

  type produkGetPayload<S extends boolean | null | undefined | produkDefaultArgs> = $Result.GetResult<Prisma.$produkPayload, S>

  type produkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<produkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProdukCountAggregateInputType | true
    }

  export interface produkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produk'], meta: { name: 'produk' } }
    /**
     * Find zero or one Produk that matches the filter.
     * @param {produkFindUniqueArgs} args - Arguments to find a Produk
     * @example
     * // Get one Produk
     * const produk = await prisma.produk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends produkFindUniqueArgs>(args: SelectSubset<T, produkFindUniqueArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Produk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {produkFindUniqueOrThrowArgs} args - Arguments to find a Produk
     * @example
     * // Get one Produk
     * const produk = await prisma.produk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends produkFindUniqueOrThrowArgs>(args: SelectSubset<T, produkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Produk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkFindFirstArgs} args - Arguments to find a Produk
     * @example
     * // Get one Produk
     * const produk = await prisma.produk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends produkFindFirstArgs>(args?: SelectSubset<T, produkFindFirstArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Produk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkFindFirstOrThrowArgs} args - Arguments to find a Produk
     * @example
     * // Get one Produk
     * const produk = await prisma.produk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends produkFindFirstOrThrowArgs>(args?: SelectSubset<T, produkFindFirstOrThrowArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Produks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produks
     * const produks = await prisma.produk.findMany()
     * 
     * // Get first 10 Produks
     * const produks = await prisma.produk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produkWithIdOnly = await prisma.produk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends produkFindManyArgs>(args?: SelectSubset<T, produkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Produk.
     * @param {produkCreateArgs} args - Arguments to create a Produk.
     * @example
     * // Create one Produk
     * const Produk = await prisma.produk.create({
     *   data: {
     *     // ... data to create a Produk
     *   }
     * })
     * 
     */
    create<T extends produkCreateArgs>(args: SelectSubset<T, produkCreateArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Produks.
     * @param {produkCreateManyArgs} args - Arguments to create many Produks.
     * @example
     * // Create many Produks
     * const produk = await prisma.produk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends produkCreateManyArgs>(args?: SelectSubset<T, produkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produk.
     * @param {produkDeleteArgs} args - Arguments to delete one Produk.
     * @example
     * // Delete one Produk
     * const Produk = await prisma.produk.delete({
     *   where: {
     *     // ... filter to delete one Produk
     *   }
     * })
     * 
     */
    delete<T extends produkDeleteArgs>(args: SelectSubset<T, produkDeleteArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Produk.
     * @param {produkUpdateArgs} args - Arguments to update one Produk.
     * @example
     * // Update one Produk
     * const produk = await prisma.produk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends produkUpdateArgs>(args: SelectSubset<T, produkUpdateArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Produks.
     * @param {produkDeleteManyArgs} args - Arguments to filter Produks to delete.
     * @example
     * // Delete a few Produks
     * const { count } = await prisma.produk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends produkDeleteManyArgs>(args?: SelectSubset<T, produkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produks
     * const produk = await prisma.produk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends produkUpdateManyArgs>(args: SelectSubset<T, produkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produk.
     * @param {produkUpsertArgs} args - Arguments to update or create a Produk.
     * @example
     * // Update or create a Produk
     * const produk = await prisma.produk.upsert({
     *   create: {
     *     // ... data to create a Produk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produk we want to update
     *   }
     * })
     */
    upsert<T extends produkUpsertArgs>(args: SelectSubset<T, produkUpsertArgs<ExtArgs>>): Prisma__produkClient<$Result.GetResult<Prisma.$produkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Produks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkCountArgs} args - Arguments to filter Produks to count.
     * @example
     * // Count the number of Produks
     * const count = await prisma.produk.count({
     *   where: {
     *     // ... the filter for the Produks we want to count
     *   }
     * })
    **/
    count<T extends produkCountArgs>(
      args?: Subset<T, produkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdukCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdukAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdukAggregateArgs>(args: Subset<T, ProdukAggregateArgs>): Prisma.PrismaPromise<GetProdukAggregateType<T>>

    /**
     * Group by Produk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produkGroupByArgs['orderBy'] }
        : { orderBy?: produkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdukGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produk model
   */
  readonly fields: produkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the produk model
   */ 
  interface produkFieldRefs {
    readonly id: FieldRef<"produk", 'Int'>
    readonly divisi: FieldRef<"produk", 'Int'>
    readonly supplier: FieldRef<"produk", 'Int'>
    readonly kode: FieldRef<"produk", 'String'>
    readonly nama: FieldRef<"produk", 'String'>
    readonly harga_beli: FieldRef<"produk", 'Decimal'>
    readonly harga_jual: FieldRef<"produk", 'Decimal'>
    readonly jumlah: FieldRef<"produk", 'Float'>
    readonly diskon: FieldRef<"produk", 'Int'>
    readonly keterangan: FieldRef<"produk", 'String'>
    readonly status: FieldRef<"produk", 'Int'>
    readonly created: FieldRef<"produk", 'DateTime'>
    readonly modified: FieldRef<"produk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * produk findUnique
   */
  export type produkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter, which produk to fetch.
     */
    where: produkWhereUniqueInput
  }

  /**
   * produk findUniqueOrThrow
   */
  export type produkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter, which produk to fetch.
     */
    where: produkWhereUniqueInput
  }

  /**
   * produk findFirst
   */
  export type produkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter, which produk to fetch.
     */
    where?: produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produks to fetch.
     */
    orderBy?: produkOrderByWithRelationInput | produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produks.
     */
    cursor?: produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produks.
     */
    distinct?: ProdukScalarFieldEnum | ProdukScalarFieldEnum[]
  }

  /**
   * produk findFirstOrThrow
   */
  export type produkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter, which produk to fetch.
     */
    where?: produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produks to fetch.
     */
    orderBy?: produkOrderByWithRelationInput | produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produks.
     */
    cursor?: produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produks.
     */
    distinct?: ProdukScalarFieldEnum | ProdukScalarFieldEnum[]
  }

  /**
   * produk findMany
   */
  export type produkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter, which produks to fetch.
     */
    where?: produkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produks to fetch.
     */
    orderBy?: produkOrderByWithRelationInput | produkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produks.
     */
    cursor?: produkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produks.
     */
    skip?: number
    distinct?: ProdukScalarFieldEnum | ProdukScalarFieldEnum[]
  }

  /**
   * produk create
   */
  export type produkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * The data needed to create a produk.
     */
    data: XOR<produkCreateInput, produkUncheckedCreateInput>
  }

  /**
   * produk createMany
   */
  export type produkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produks.
     */
    data: produkCreateManyInput | produkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * produk update
   */
  export type produkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * The data needed to update a produk.
     */
    data: XOR<produkUpdateInput, produkUncheckedUpdateInput>
    /**
     * Choose, which produk to update.
     */
    where: produkWhereUniqueInput
  }

  /**
   * produk updateMany
   */
  export type produkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produks.
     */
    data: XOR<produkUpdateManyMutationInput, produkUncheckedUpdateManyInput>
    /**
     * Filter which produks to update
     */
    where?: produkWhereInput
  }

  /**
   * produk upsert
   */
  export type produkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * The filter to search for the produk to update in case it exists.
     */
    where: produkWhereUniqueInput
    /**
     * In case the produk found by the `where` argument doesn't exist, create a new produk with this data.
     */
    create: XOR<produkCreateInput, produkUncheckedCreateInput>
    /**
     * In case the produk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produkUpdateInput, produkUncheckedUpdateInput>
  }

  /**
   * produk delete
   */
  export type produkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
    /**
     * Filter which produk to delete.
     */
    where: produkWhereUniqueInput
  }

  /**
   * produk deleteMany
   */
  export type produkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produks to delete
     */
    where?: produkWhereInput
  }

  /**
   * produk without action
   */
  export type produkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk
     */
    select?: produkSelect<ExtArgs> | null
  }


  /**
   * Model produk_harga
   */

  export type AggregateProduk_harga = {
    _count: Produk_hargaCountAggregateOutputType | null
    _avg: Produk_hargaAvgAggregateOutputType | null
    _sum: Produk_hargaSumAggregateOutputType | null
    _min: Produk_hargaMinAggregateOutputType | null
    _max: Produk_hargaMaxAggregateOutputType | null
  }

  export type Produk_hargaAvgAggregateOutputType = {
    id: number | null
    id_produk: number | null
    harga_beli: number | null
    harga_jual: number | null
  }

  export type Produk_hargaSumAggregateOutputType = {
    id: number | null
    id_produk: number | null
    harga_beli: number | null
    harga_jual: number | null
  }

  export type Produk_hargaMinAggregateOutputType = {
    id: number | null
    id_produk: number | null
    tanggal: Date | null
    harga_beli: number | null
    harga_jual: number | null
  }

  export type Produk_hargaMaxAggregateOutputType = {
    id: number | null
    id_produk: number | null
    tanggal: Date | null
    harga_beli: number | null
    harga_jual: number | null
  }

  export type Produk_hargaCountAggregateOutputType = {
    id: number
    id_produk: number
    tanggal: number
    harga_beli: number
    harga_jual: number
    _all: number
  }


  export type Produk_hargaAvgAggregateInputType = {
    id?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
  }

  export type Produk_hargaSumAggregateInputType = {
    id?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
  }

  export type Produk_hargaMinAggregateInputType = {
    id?: true
    id_produk?: true
    tanggal?: true
    harga_beli?: true
    harga_jual?: true
  }

  export type Produk_hargaMaxAggregateInputType = {
    id?: true
    id_produk?: true
    tanggal?: true
    harga_beli?: true
    harga_jual?: true
  }

  export type Produk_hargaCountAggregateInputType = {
    id?: true
    id_produk?: true
    tanggal?: true
    harga_beli?: true
    harga_jual?: true
    _all?: true
  }

  export type Produk_hargaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produk_harga to aggregate.
     */
    where?: produk_hargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_hargas to fetch.
     */
    orderBy?: produk_hargaOrderByWithRelationInput | produk_hargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: produk_hargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_hargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_hargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned produk_hargas
    **/
    _count?: true | Produk_hargaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Produk_hargaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Produk_hargaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Produk_hargaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Produk_hargaMaxAggregateInputType
  }

  export type GetProduk_hargaAggregateType<T extends Produk_hargaAggregateArgs> = {
        [P in keyof T & keyof AggregateProduk_harga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduk_harga[P]>
      : GetScalarType<T[P], AggregateProduk_harga[P]>
  }




  export type produk_hargaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: produk_hargaWhereInput
    orderBy?: produk_hargaOrderByWithAggregationInput | produk_hargaOrderByWithAggregationInput[]
    by: Produk_hargaScalarFieldEnum[] | Produk_hargaScalarFieldEnum
    having?: produk_hargaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Produk_hargaCountAggregateInputType | true
    _avg?: Produk_hargaAvgAggregateInputType
    _sum?: Produk_hargaSumAggregateInputType
    _min?: Produk_hargaMinAggregateInputType
    _max?: Produk_hargaMaxAggregateInputType
  }

  export type Produk_hargaGroupByOutputType = {
    id: number
    id_produk: number
    tanggal: Date | null
    harga_beli: number
    harga_jual: number
    _count: Produk_hargaCountAggregateOutputType | null
    _avg: Produk_hargaAvgAggregateOutputType | null
    _sum: Produk_hargaSumAggregateOutputType | null
    _min: Produk_hargaMinAggregateOutputType | null
    _max: Produk_hargaMaxAggregateOutputType | null
  }

  type GetProduk_hargaGroupByPayload<T extends produk_hargaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Produk_hargaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Produk_hargaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Produk_hargaGroupByOutputType[P]>
            : GetScalarType<T[P], Produk_hargaGroupByOutputType[P]>
        }
      >
    >


  export type produk_hargaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_produk?: boolean
    tanggal?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
  }, ExtArgs["result"]["produk_harga"]>


  export type produk_hargaSelectScalar = {
    id?: boolean
    id_produk?: boolean
    tanggal?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
  }


  export type $produk_hargaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "produk_harga"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_produk: number
      tanggal: Date | null
      harga_beli: number
      harga_jual: number
    }, ExtArgs["result"]["produk_harga"]>
    composites: {}
  }

  type produk_hargaGetPayload<S extends boolean | null | undefined | produk_hargaDefaultArgs> = $Result.GetResult<Prisma.$produk_hargaPayload, S>

  type produk_hargaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<produk_hargaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Produk_hargaCountAggregateInputType | true
    }

  export interface produk_hargaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['produk_harga'], meta: { name: 'produk_harga' } }
    /**
     * Find zero or one Produk_harga that matches the filter.
     * @param {produk_hargaFindUniqueArgs} args - Arguments to find a Produk_harga
     * @example
     * // Get one Produk_harga
     * const produk_harga = await prisma.produk_harga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends produk_hargaFindUniqueArgs>(args: SelectSubset<T, produk_hargaFindUniqueArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Produk_harga that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {produk_hargaFindUniqueOrThrowArgs} args - Arguments to find a Produk_harga
     * @example
     * // Get one Produk_harga
     * const produk_harga = await prisma.produk_harga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends produk_hargaFindUniqueOrThrowArgs>(args: SelectSubset<T, produk_hargaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Produk_harga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaFindFirstArgs} args - Arguments to find a Produk_harga
     * @example
     * // Get one Produk_harga
     * const produk_harga = await prisma.produk_harga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends produk_hargaFindFirstArgs>(args?: SelectSubset<T, produk_hargaFindFirstArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Produk_harga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaFindFirstOrThrowArgs} args - Arguments to find a Produk_harga
     * @example
     * // Get one Produk_harga
     * const produk_harga = await prisma.produk_harga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends produk_hargaFindFirstOrThrowArgs>(args?: SelectSubset<T, produk_hargaFindFirstOrThrowArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Produk_hargas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produk_hargas
     * const produk_hargas = await prisma.produk_harga.findMany()
     * 
     * // Get first 10 Produk_hargas
     * const produk_hargas = await prisma.produk_harga.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produk_hargaWithIdOnly = await prisma.produk_harga.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends produk_hargaFindManyArgs>(args?: SelectSubset<T, produk_hargaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Produk_harga.
     * @param {produk_hargaCreateArgs} args - Arguments to create a Produk_harga.
     * @example
     * // Create one Produk_harga
     * const Produk_harga = await prisma.produk_harga.create({
     *   data: {
     *     // ... data to create a Produk_harga
     *   }
     * })
     * 
     */
    create<T extends produk_hargaCreateArgs>(args: SelectSubset<T, produk_hargaCreateArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Produk_hargas.
     * @param {produk_hargaCreateManyArgs} args - Arguments to create many Produk_hargas.
     * @example
     * // Create many Produk_hargas
     * const produk_harga = await prisma.produk_harga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends produk_hargaCreateManyArgs>(args?: SelectSubset<T, produk_hargaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Produk_harga.
     * @param {produk_hargaDeleteArgs} args - Arguments to delete one Produk_harga.
     * @example
     * // Delete one Produk_harga
     * const Produk_harga = await prisma.produk_harga.delete({
     *   where: {
     *     // ... filter to delete one Produk_harga
     *   }
     * })
     * 
     */
    delete<T extends produk_hargaDeleteArgs>(args: SelectSubset<T, produk_hargaDeleteArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Produk_harga.
     * @param {produk_hargaUpdateArgs} args - Arguments to update one Produk_harga.
     * @example
     * // Update one Produk_harga
     * const produk_harga = await prisma.produk_harga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends produk_hargaUpdateArgs>(args: SelectSubset<T, produk_hargaUpdateArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Produk_hargas.
     * @param {produk_hargaDeleteManyArgs} args - Arguments to filter Produk_hargas to delete.
     * @example
     * // Delete a few Produk_hargas
     * const { count } = await prisma.produk_harga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends produk_hargaDeleteManyArgs>(args?: SelectSubset<T, produk_hargaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produk_hargas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produk_hargas
     * const produk_harga = await prisma.produk_harga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends produk_hargaUpdateManyArgs>(args: SelectSubset<T, produk_hargaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Produk_harga.
     * @param {produk_hargaUpsertArgs} args - Arguments to update or create a Produk_harga.
     * @example
     * // Update or create a Produk_harga
     * const produk_harga = await prisma.produk_harga.upsert({
     *   create: {
     *     // ... data to create a Produk_harga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produk_harga we want to update
     *   }
     * })
     */
    upsert<T extends produk_hargaUpsertArgs>(args: SelectSubset<T, produk_hargaUpsertArgs<ExtArgs>>): Prisma__produk_hargaClient<$Result.GetResult<Prisma.$produk_hargaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Produk_hargas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaCountArgs} args - Arguments to filter Produk_hargas to count.
     * @example
     * // Count the number of Produk_hargas
     * const count = await prisma.produk_harga.count({
     *   where: {
     *     // ... the filter for the Produk_hargas we want to count
     *   }
     * })
    **/
    count<T extends produk_hargaCountArgs>(
      args?: Subset<T, produk_hargaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Produk_hargaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produk_harga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Produk_hargaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Produk_hargaAggregateArgs>(args: Subset<T, Produk_hargaAggregateArgs>): Prisma.PrismaPromise<GetProduk_hargaAggregateType<T>>

    /**
     * Group by Produk_harga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {produk_hargaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends produk_hargaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: produk_hargaGroupByArgs['orderBy'] }
        : { orderBy?: produk_hargaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, produk_hargaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduk_hargaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the produk_harga model
   */
  readonly fields: produk_hargaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for produk_harga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__produk_hargaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the produk_harga model
   */ 
  interface produk_hargaFieldRefs {
    readonly id: FieldRef<"produk_harga", 'Int'>
    readonly id_produk: FieldRef<"produk_harga", 'Int'>
    readonly tanggal: FieldRef<"produk_harga", 'DateTime'>
    readonly harga_beli: FieldRef<"produk_harga", 'Float'>
    readonly harga_jual: FieldRef<"produk_harga", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * produk_harga findUnique
   */
  export type produk_hargaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter, which produk_harga to fetch.
     */
    where: produk_hargaWhereUniqueInput
  }

  /**
   * produk_harga findUniqueOrThrow
   */
  export type produk_hargaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter, which produk_harga to fetch.
     */
    where: produk_hargaWhereUniqueInput
  }

  /**
   * produk_harga findFirst
   */
  export type produk_hargaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter, which produk_harga to fetch.
     */
    where?: produk_hargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_hargas to fetch.
     */
    orderBy?: produk_hargaOrderByWithRelationInput | produk_hargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produk_hargas.
     */
    cursor?: produk_hargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_hargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_hargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produk_hargas.
     */
    distinct?: Produk_hargaScalarFieldEnum | Produk_hargaScalarFieldEnum[]
  }

  /**
   * produk_harga findFirstOrThrow
   */
  export type produk_hargaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter, which produk_harga to fetch.
     */
    where?: produk_hargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_hargas to fetch.
     */
    orderBy?: produk_hargaOrderByWithRelationInput | produk_hargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for produk_hargas.
     */
    cursor?: produk_hargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_hargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_hargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of produk_hargas.
     */
    distinct?: Produk_hargaScalarFieldEnum | Produk_hargaScalarFieldEnum[]
  }

  /**
   * produk_harga findMany
   */
  export type produk_hargaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter, which produk_hargas to fetch.
     */
    where?: produk_hargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of produk_hargas to fetch.
     */
    orderBy?: produk_hargaOrderByWithRelationInput | produk_hargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing produk_hargas.
     */
    cursor?: produk_hargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` produk_hargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` produk_hargas.
     */
    skip?: number
    distinct?: Produk_hargaScalarFieldEnum | Produk_hargaScalarFieldEnum[]
  }

  /**
   * produk_harga create
   */
  export type produk_hargaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * The data needed to create a produk_harga.
     */
    data: XOR<produk_hargaCreateInput, produk_hargaUncheckedCreateInput>
  }

  /**
   * produk_harga createMany
   */
  export type produk_hargaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many produk_hargas.
     */
    data: produk_hargaCreateManyInput | produk_hargaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * produk_harga update
   */
  export type produk_hargaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * The data needed to update a produk_harga.
     */
    data: XOR<produk_hargaUpdateInput, produk_hargaUncheckedUpdateInput>
    /**
     * Choose, which produk_harga to update.
     */
    where: produk_hargaWhereUniqueInput
  }

  /**
   * produk_harga updateMany
   */
  export type produk_hargaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update produk_hargas.
     */
    data: XOR<produk_hargaUpdateManyMutationInput, produk_hargaUncheckedUpdateManyInput>
    /**
     * Filter which produk_hargas to update
     */
    where?: produk_hargaWhereInput
  }

  /**
   * produk_harga upsert
   */
  export type produk_hargaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * The filter to search for the produk_harga to update in case it exists.
     */
    where: produk_hargaWhereUniqueInput
    /**
     * In case the produk_harga found by the `where` argument doesn't exist, create a new produk_harga with this data.
     */
    create: XOR<produk_hargaCreateInput, produk_hargaUncheckedCreateInput>
    /**
     * In case the produk_harga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<produk_hargaUpdateInput, produk_hargaUncheckedUpdateInput>
  }

  /**
   * produk_harga delete
   */
  export type produk_hargaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
    /**
     * Filter which produk_harga to delete.
     */
    where: produk_hargaWhereUniqueInput
  }

  /**
   * produk_harga deleteMany
   */
  export type produk_hargaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which produk_hargas to delete
     */
    where?: produk_hargaWhereInput
  }

  /**
   * produk_harga without action
   */
  export type produk_hargaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the produk_harga
     */
    select?: produk_hargaSelect<ExtArgs> | null
  }


  /**
   * Model rapb
   */

  export type AggregateRapb = {
    _count: RapbCountAggregateOutputType | null
    _avg: RapbAvgAggregateOutputType | null
    _sum: RapbSumAggregateOutputType | null
    _min: RapbMinAggregateOutputType | null
    _max: RapbMaxAggregateOutputType | null
  }

  export type RapbAvgAggregateOutputType = {
    no: number | null
    tahun: number | null
    hasil_usaha: Decimal | null
    jasa_bank: Decimal | null
    pendapatan_lain: Decimal | null
    beban_gaji: Decimal | null
    uang_makan: Decimal | null
    thr_karyawan: Decimal | null
    tunjangan_pangan: Decimal | null
    beban_adm: Decimal | null
    beban_perlengkapan: Decimal | null
    tunjangan_kesehatan: Decimal | null
    peny_inventaris: Decimal | null
    peny_gedung: Decimal | null
    pemeliharaan_inventaris: Decimal | null
    pemeliharaan_gedung: Decimal | null
    beban_pensiun: Decimal | null
    kerugian_persediaan: Decimal | null
    sisa_hasil_usaha: Decimal | null
  }

  export type RapbSumAggregateOutputType = {
    no: number | null
    tahun: number | null
    hasil_usaha: Decimal | null
    jasa_bank: Decimal | null
    pendapatan_lain: Decimal | null
    beban_gaji: Decimal | null
    uang_makan: Decimal | null
    thr_karyawan: Decimal | null
    tunjangan_pangan: Decimal | null
    beban_adm: Decimal | null
    beban_perlengkapan: Decimal | null
    tunjangan_kesehatan: Decimal | null
    peny_inventaris: Decimal | null
    peny_gedung: Decimal | null
    pemeliharaan_inventaris: Decimal | null
    pemeliharaan_gedung: Decimal | null
    beban_pensiun: Decimal | null
    kerugian_persediaan: Decimal | null
    sisa_hasil_usaha: Decimal | null
  }

  export type RapbMinAggregateOutputType = {
    no: number | null
    tahun: number | null
    hasil_usaha: Decimal | null
    jasa_bank: Decimal | null
    pendapatan_lain: Decimal | null
    beban_gaji: Decimal | null
    uang_makan: Decimal | null
    thr_karyawan: Decimal | null
    tunjangan_pangan: Decimal | null
    beban_adm: Decimal | null
    beban_perlengkapan: Decimal | null
    tunjangan_kesehatan: Decimal | null
    peny_inventaris: Decimal | null
    peny_gedung: Decimal | null
    pemeliharaan_inventaris: Decimal | null
    pemeliharaan_gedung: Decimal | null
    beban_pensiun: Decimal | null
    kerugian_persediaan: Decimal | null
    sisa_hasil_usaha: Decimal | null
  }

  export type RapbMaxAggregateOutputType = {
    no: number | null
    tahun: number | null
    hasil_usaha: Decimal | null
    jasa_bank: Decimal | null
    pendapatan_lain: Decimal | null
    beban_gaji: Decimal | null
    uang_makan: Decimal | null
    thr_karyawan: Decimal | null
    tunjangan_pangan: Decimal | null
    beban_adm: Decimal | null
    beban_perlengkapan: Decimal | null
    tunjangan_kesehatan: Decimal | null
    peny_inventaris: Decimal | null
    peny_gedung: Decimal | null
    pemeliharaan_inventaris: Decimal | null
    pemeliharaan_gedung: Decimal | null
    beban_pensiun: Decimal | null
    kerugian_persediaan: Decimal | null
    sisa_hasil_usaha: Decimal | null
  }

  export type RapbCountAggregateOutputType = {
    no: number
    tahun: number
    hasil_usaha: number
    jasa_bank: number
    pendapatan_lain: number
    beban_gaji: number
    uang_makan: number
    thr_karyawan: number
    tunjangan_pangan: number
    beban_adm: number
    beban_perlengkapan: number
    tunjangan_kesehatan: number
    peny_inventaris: number
    peny_gedung: number
    pemeliharaan_inventaris: number
    pemeliharaan_gedung: number
    beban_pensiun: number
    kerugian_persediaan: number
    sisa_hasil_usaha: number
    _all: number
  }


  export type RapbAvgAggregateInputType = {
    no?: true
    tahun?: true
    hasil_usaha?: true
    jasa_bank?: true
    pendapatan_lain?: true
    beban_gaji?: true
    uang_makan?: true
    thr_karyawan?: true
    tunjangan_pangan?: true
    beban_adm?: true
    beban_perlengkapan?: true
    tunjangan_kesehatan?: true
    peny_inventaris?: true
    peny_gedung?: true
    pemeliharaan_inventaris?: true
    pemeliharaan_gedung?: true
    beban_pensiun?: true
    kerugian_persediaan?: true
    sisa_hasil_usaha?: true
  }

  export type RapbSumAggregateInputType = {
    no?: true
    tahun?: true
    hasil_usaha?: true
    jasa_bank?: true
    pendapatan_lain?: true
    beban_gaji?: true
    uang_makan?: true
    thr_karyawan?: true
    tunjangan_pangan?: true
    beban_adm?: true
    beban_perlengkapan?: true
    tunjangan_kesehatan?: true
    peny_inventaris?: true
    peny_gedung?: true
    pemeliharaan_inventaris?: true
    pemeliharaan_gedung?: true
    beban_pensiun?: true
    kerugian_persediaan?: true
    sisa_hasil_usaha?: true
  }

  export type RapbMinAggregateInputType = {
    no?: true
    tahun?: true
    hasil_usaha?: true
    jasa_bank?: true
    pendapatan_lain?: true
    beban_gaji?: true
    uang_makan?: true
    thr_karyawan?: true
    tunjangan_pangan?: true
    beban_adm?: true
    beban_perlengkapan?: true
    tunjangan_kesehatan?: true
    peny_inventaris?: true
    peny_gedung?: true
    pemeliharaan_inventaris?: true
    pemeliharaan_gedung?: true
    beban_pensiun?: true
    kerugian_persediaan?: true
    sisa_hasil_usaha?: true
  }

  export type RapbMaxAggregateInputType = {
    no?: true
    tahun?: true
    hasil_usaha?: true
    jasa_bank?: true
    pendapatan_lain?: true
    beban_gaji?: true
    uang_makan?: true
    thr_karyawan?: true
    tunjangan_pangan?: true
    beban_adm?: true
    beban_perlengkapan?: true
    tunjangan_kesehatan?: true
    peny_inventaris?: true
    peny_gedung?: true
    pemeliharaan_inventaris?: true
    pemeliharaan_gedung?: true
    beban_pensiun?: true
    kerugian_persediaan?: true
    sisa_hasil_usaha?: true
  }

  export type RapbCountAggregateInputType = {
    no?: true
    tahun?: true
    hasil_usaha?: true
    jasa_bank?: true
    pendapatan_lain?: true
    beban_gaji?: true
    uang_makan?: true
    thr_karyawan?: true
    tunjangan_pangan?: true
    beban_adm?: true
    beban_perlengkapan?: true
    tunjangan_kesehatan?: true
    peny_inventaris?: true
    peny_gedung?: true
    pemeliharaan_inventaris?: true
    pemeliharaan_gedung?: true
    beban_pensiun?: true
    kerugian_persediaan?: true
    sisa_hasil_usaha?: true
    _all?: true
  }

  export type RapbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rapb to aggregate.
     */
    where?: rapbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapbs to fetch.
     */
    orderBy?: rapbOrderByWithRelationInput | rapbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rapbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rapbs
    **/
    _count?: true | RapbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RapbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RapbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RapbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RapbMaxAggregateInputType
  }

  export type GetRapbAggregateType<T extends RapbAggregateArgs> = {
        [P in keyof T & keyof AggregateRapb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRapb[P]>
      : GetScalarType<T[P], AggregateRapb[P]>
  }




  export type rapbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rapbWhereInput
    orderBy?: rapbOrderByWithAggregationInput | rapbOrderByWithAggregationInput[]
    by: RapbScalarFieldEnum[] | RapbScalarFieldEnum
    having?: rapbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RapbCountAggregateInputType | true
    _avg?: RapbAvgAggregateInputType
    _sum?: RapbSumAggregateInputType
    _min?: RapbMinAggregateInputType
    _max?: RapbMaxAggregateInputType
  }

  export type RapbGroupByOutputType = {
    no: number
    tahun: number
    hasil_usaha: Decimal
    jasa_bank: Decimal
    pendapatan_lain: Decimal
    beban_gaji: Decimal
    uang_makan: Decimal
    thr_karyawan: Decimal
    tunjangan_pangan: Decimal
    beban_adm: Decimal
    beban_perlengkapan: Decimal
    tunjangan_kesehatan: Decimal
    peny_inventaris: Decimal
    peny_gedung: Decimal
    pemeliharaan_inventaris: Decimal
    pemeliharaan_gedung: Decimal
    beban_pensiun: Decimal
    kerugian_persediaan: Decimal
    sisa_hasil_usaha: Decimal
    _count: RapbCountAggregateOutputType | null
    _avg: RapbAvgAggregateOutputType | null
    _sum: RapbSumAggregateOutputType | null
    _min: RapbMinAggregateOutputType | null
    _max: RapbMaxAggregateOutputType | null
  }

  type GetRapbGroupByPayload<T extends rapbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RapbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RapbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RapbGroupByOutputType[P]>
            : GetScalarType<T[P], RapbGroupByOutputType[P]>
        }
      >
    >


  export type rapbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    no?: boolean
    tahun?: boolean
    hasil_usaha?: boolean
    jasa_bank?: boolean
    pendapatan_lain?: boolean
    beban_gaji?: boolean
    uang_makan?: boolean
    thr_karyawan?: boolean
    tunjangan_pangan?: boolean
    beban_adm?: boolean
    beban_perlengkapan?: boolean
    tunjangan_kesehatan?: boolean
    peny_inventaris?: boolean
    peny_gedung?: boolean
    pemeliharaan_inventaris?: boolean
    pemeliharaan_gedung?: boolean
    beban_pensiun?: boolean
    kerugian_persediaan?: boolean
    sisa_hasil_usaha?: boolean
  }, ExtArgs["result"]["rapb"]>


  export type rapbSelectScalar = {
    no?: boolean
    tahun?: boolean
    hasil_usaha?: boolean
    jasa_bank?: boolean
    pendapatan_lain?: boolean
    beban_gaji?: boolean
    uang_makan?: boolean
    thr_karyawan?: boolean
    tunjangan_pangan?: boolean
    beban_adm?: boolean
    beban_perlengkapan?: boolean
    tunjangan_kesehatan?: boolean
    peny_inventaris?: boolean
    peny_gedung?: boolean
    pemeliharaan_inventaris?: boolean
    pemeliharaan_gedung?: boolean
    beban_pensiun?: boolean
    kerugian_persediaan?: boolean
    sisa_hasil_usaha?: boolean
  }


  export type $rapbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rapb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      no: number
      tahun: number
      hasil_usaha: Prisma.Decimal
      jasa_bank: Prisma.Decimal
      pendapatan_lain: Prisma.Decimal
      beban_gaji: Prisma.Decimal
      uang_makan: Prisma.Decimal
      thr_karyawan: Prisma.Decimal
      tunjangan_pangan: Prisma.Decimal
      beban_adm: Prisma.Decimal
      beban_perlengkapan: Prisma.Decimal
      tunjangan_kesehatan: Prisma.Decimal
      peny_inventaris: Prisma.Decimal
      peny_gedung: Prisma.Decimal
      pemeliharaan_inventaris: Prisma.Decimal
      pemeliharaan_gedung: Prisma.Decimal
      beban_pensiun: Prisma.Decimal
      kerugian_persediaan: Prisma.Decimal
      sisa_hasil_usaha: Prisma.Decimal
    }, ExtArgs["result"]["rapb"]>
    composites: {}
  }

  type rapbGetPayload<S extends boolean | null | undefined | rapbDefaultArgs> = $Result.GetResult<Prisma.$rapbPayload, S>

  type rapbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rapbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RapbCountAggregateInputType | true
    }

  export interface rapbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rapb'], meta: { name: 'rapb' } }
    /**
     * Find zero or one Rapb that matches the filter.
     * @param {rapbFindUniqueArgs} args - Arguments to find a Rapb
     * @example
     * // Get one Rapb
     * const rapb = await prisma.rapb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rapbFindUniqueArgs>(args: SelectSubset<T, rapbFindUniqueArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rapb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rapbFindUniqueOrThrowArgs} args - Arguments to find a Rapb
     * @example
     * // Get one Rapb
     * const rapb = await prisma.rapb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rapbFindUniqueOrThrowArgs>(args: SelectSubset<T, rapbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rapb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbFindFirstArgs} args - Arguments to find a Rapb
     * @example
     * // Get one Rapb
     * const rapb = await prisma.rapb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rapbFindFirstArgs>(args?: SelectSubset<T, rapbFindFirstArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rapb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbFindFirstOrThrowArgs} args - Arguments to find a Rapb
     * @example
     * // Get one Rapb
     * const rapb = await prisma.rapb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rapbFindFirstOrThrowArgs>(args?: SelectSubset<T, rapbFindFirstOrThrowArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rapbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rapbs
     * const rapbs = await prisma.rapb.findMany()
     * 
     * // Get first 10 Rapbs
     * const rapbs = await prisma.rapb.findMany({ take: 10 })
     * 
     * // Only select the `no`
     * const rapbWithNoOnly = await prisma.rapb.findMany({ select: { no: true } })
     * 
     */
    findMany<T extends rapbFindManyArgs>(args?: SelectSubset<T, rapbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rapb.
     * @param {rapbCreateArgs} args - Arguments to create a Rapb.
     * @example
     * // Create one Rapb
     * const Rapb = await prisma.rapb.create({
     *   data: {
     *     // ... data to create a Rapb
     *   }
     * })
     * 
     */
    create<T extends rapbCreateArgs>(args: SelectSubset<T, rapbCreateArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rapbs.
     * @param {rapbCreateManyArgs} args - Arguments to create many Rapbs.
     * @example
     * // Create many Rapbs
     * const rapb = await prisma.rapb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rapbCreateManyArgs>(args?: SelectSubset<T, rapbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rapb.
     * @param {rapbDeleteArgs} args - Arguments to delete one Rapb.
     * @example
     * // Delete one Rapb
     * const Rapb = await prisma.rapb.delete({
     *   where: {
     *     // ... filter to delete one Rapb
     *   }
     * })
     * 
     */
    delete<T extends rapbDeleteArgs>(args: SelectSubset<T, rapbDeleteArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rapb.
     * @param {rapbUpdateArgs} args - Arguments to update one Rapb.
     * @example
     * // Update one Rapb
     * const rapb = await prisma.rapb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rapbUpdateArgs>(args: SelectSubset<T, rapbUpdateArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rapbs.
     * @param {rapbDeleteManyArgs} args - Arguments to filter Rapbs to delete.
     * @example
     * // Delete a few Rapbs
     * const { count } = await prisma.rapb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rapbDeleteManyArgs>(args?: SelectSubset<T, rapbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rapbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rapbs
     * const rapb = await prisma.rapb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rapbUpdateManyArgs>(args: SelectSubset<T, rapbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rapb.
     * @param {rapbUpsertArgs} args - Arguments to update or create a Rapb.
     * @example
     * // Update or create a Rapb
     * const rapb = await prisma.rapb.upsert({
     *   create: {
     *     // ... data to create a Rapb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rapb we want to update
     *   }
     * })
     */
    upsert<T extends rapbUpsertArgs>(args: SelectSubset<T, rapbUpsertArgs<ExtArgs>>): Prisma__rapbClient<$Result.GetResult<Prisma.$rapbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rapbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbCountArgs} args - Arguments to filter Rapbs to count.
     * @example
     * // Count the number of Rapbs
     * const count = await prisma.rapb.count({
     *   where: {
     *     // ... the filter for the Rapbs we want to count
     *   }
     * })
    **/
    count<T extends rapbCountArgs>(
      args?: Subset<T, rapbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RapbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rapb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RapbAggregateArgs>(args: Subset<T, RapbAggregateArgs>): Prisma.PrismaPromise<GetRapbAggregateType<T>>

    /**
     * Group by Rapb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rapbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rapbGroupByArgs['orderBy'] }
        : { orderBy?: rapbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rapbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRapbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rapb model
   */
  readonly fields: rapbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rapb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rapbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rapb model
   */ 
  interface rapbFieldRefs {
    readonly no: FieldRef<"rapb", 'Int'>
    readonly tahun: FieldRef<"rapb", 'Int'>
    readonly hasil_usaha: FieldRef<"rapb", 'Decimal'>
    readonly jasa_bank: FieldRef<"rapb", 'Decimal'>
    readonly pendapatan_lain: FieldRef<"rapb", 'Decimal'>
    readonly beban_gaji: FieldRef<"rapb", 'Decimal'>
    readonly uang_makan: FieldRef<"rapb", 'Decimal'>
    readonly thr_karyawan: FieldRef<"rapb", 'Decimal'>
    readonly tunjangan_pangan: FieldRef<"rapb", 'Decimal'>
    readonly beban_adm: FieldRef<"rapb", 'Decimal'>
    readonly beban_perlengkapan: FieldRef<"rapb", 'Decimal'>
    readonly tunjangan_kesehatan: FieldRef<"rapb", 'Decimal'>
    readonly peny_inventaris: FieldRef<"rapb", 'Decimal'>
    readonly peny_gedung: FieldRef<"rapb", 'Decimal'>
    readonly pemeliharaan_inventaris: FieldRef<"rapb", 'Decimal'>
    readonly pemeliharaan_gedung: FieldRef<"rapb", 'Decimal'>
    readonly beban_pensiun: FieldRef<"rapb", 'Decimal'>
    readonly kerugian_persediaan: FieldRef<"rapb", 'Decimal'>
    readonly sisa_hasil_usaha: FieldRef<"rapb", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * rapb findUnique
   */
  export type rapbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter, which rapb to fetch.
     */
    where: rapbWhereUniqueInput
  }

  /**
   * rapb findUniqueOrThrow
   */
  export type rapbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter, which rapb to fetch.
     */
    where: rapbWhereUniqueInput
  }

  /**
   * rapb findFirst
   */
  export type rapbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter, which rapb to fetch.
     */
    where?: rapbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapbs to fetch.
     */
    orderBy?: rapbOrderByWithRelationInput | rapbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rapbs.
     */
    cursor?: rapbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rapbs.
     */
    distinct?: RapbScalarFieldEnum | RapbScalarFieldEnum[]
  }

  /**
   * rapb findFirstOrThrow
   */
  export type rapbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter, which rapb to fetch.
     */
    where?: rapbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapbs to fetch.
     */
    orderBy?: rapbOrderByWithRelationInput | rapbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rapbs.
     */
    cursor?: rapbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rapbs.
     */
    distinct?: RapbScalarFieldEnum | RapbScalarFieldEnum[]
  }

  /**
   * rapb findMany
   */
  export type rapbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter, which rapbs to fetch.
     */
    where?: rapbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapbs to fetch.
     */
    orderBy?: rapbOrderByWithRelationInput | rapbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rapbs.
     */
    cursor?: rapbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapbs.
     */
    skip?: number
    distinct?: RapbScalarFieldEnum | RapbScalarFieldEnum[]
  }

  /**
   * rapb create
   */
  export type rapbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * The data needed to create a rapb.
     */
    data: XOR<rapbCreateInput, rapbUncheckedCreateInput>
  }

  /**
   * rapb createMany
   */
  export type rapbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rapbs.
     */
    data: rapbCreateManyInput | rapbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rapb update
   */
  export type rapbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * The data needed to update a rapb.
     */
    data: XOR<rapbUpdateInput, rapbUncheckedUpdateInput>
    /**
     * Choose, which rapb to update.
     */
    where: rapbWhereUniqueInput
  }

  /**
   * rapb updateMany
   */
  export type rapbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rapbs.
     */
    data: XOR<rapbUpdateManyMutationInput, rapbUncheckedUpdateManyInput>
    /**
     * Filter which rapbs to update
     */
    where?: rapbWhereInput
  }

  /**
   * rapb upsert
   */
  export type rapbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * The filter to search for the rapb to update in case it exists.
     */
    where: rapbWhereUniqueInput
    /**
     * In case the rapb found by the `where` argument doesn't exist, create a new rapb with this data.
     */
    create: XOR<rapbCreateInput, rapbUncheckedCreateInput>
    /**
     * In case the rapb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rapbUpdateInput, rapbUncheckedUpdateInput>
  }

  /**
   * rapb delete
   */
  export type rapbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
    /**
     * Filter which rapb to delete.
     */
    where: rapbWhereUniqueInput
  }

  /**
   * rapb deleteMany
   */
  export type rapbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rapbs to delete
     */
    where?: rapbWhereInput
  }

  /**
   * rapb without action
   */
  export type rapbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapb
     */
    select?: rapbSelect<ExtArgs> | null
  }


  /**
   * Model saldo_toko
   */

  export type AggregateSaldo_toko = {
    _count: Saldo_tokoCountAggregateOutputType | null
    _avg: Saldo_tokoAvgAggregateOutputType | null
    _sum: Saldo_tokoSumAggregateOutputType | null
    _min: Saldo_tokoMinAggregateOutputType | null
    _max: Saldo_tokoMaxAggregateOutputType | null
  }

  export type Saldo_tokoAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    debet: number | null
    kredit: number | null
    saldo: number | null
  }

  export type Saldo_tokoSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    debet: number | null
    kredit: number | null
    saldo: number | null
  }

  export type Saldo_tokoMinAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    tanggal: Date | null
    debet: number | null
    kredit: number | null
    saldo: number | null
    keterangan: string | null
  }

  export type Saldo_tokoMaxAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    tanggal: Date | null
    debet: number | null
    kredit: number | null
    saldo: number | null
    keterangan: string | null
  }

  export type Saldo_tokoCountAggregateOutputType = {
    id: number
    jenis: number
    id_transaksi: number
    tanggal: number
    debet: number
    kredit: number
    saldo: number
    keterangan: number
    _all: number
  }


  export type Saldo_tokoAvgAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
    saldo?: true
  }

  export type Saldo_tokoSumAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
    saldo?: true
  }

  export type Saldo_tokoMinAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    tanggal?: true
    debet?: true
    kredit?: true
    saldo?: true
    keterangan?: true
  }

  export type Saldo_tokoMaxAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    tanggal?: true
    debet?: true
    kredit?: true
    saldo?: true
    keterangan?: true
  }

  export type Saldo_tokoCountAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    tanggal?: true
    debet?: true
    kredit?: true
    saldo?: true
    keterangan?: true
    _all?: true
  }

  export type Saldo_tokoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saldo_toko to aggregate.
     */
    where?: saldo_tokoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saldo_tokos to fetch.
     */
    orderBy?: saldo_tokoOrderByWithRelationInput | saldo_tokoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saldo_tokoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saldo_tokos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saldo_tokos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saldo_tokos
    **/
    _count?: true | Saldo_tokoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Saldo_tokoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Saldo_tokoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Saldo_tokoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Saldo_tokoMaxAggregateInputType
  }

  export type GetSaldo_tokoAggregateType<T extends Saldo_tokoAggregateArgs> = {
        [P in keyof T & keyof AggregateSaldo_toko]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaldo_toko[P]>
      : GetScalarType<T[P], AggregateSaldo_toko[P]>
  }




  export type saldo_tokoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saldo_tokoWhereInput
    orderBy?: saldo_tokoOrderByWithAggregationInput | saldo_tokoOrderByWithAggregationInput[]
    by: Saldo_tokoScalarFieldEnum[] | Saldo_tokoScalarFieldEnum
    having?: saldo_tokoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Saldo_tokoCountAggregateInputType | true
    _avg?: Saldo_tokoAvgAggregateInputType
    _sum?: Saldo_tokoSumAggregateInputType
    _min?: Saldo_tokoMinAggregateInputType
    _max?: Saldo_tokoMaxAggregateInputType
  }

  export type Saldo_tokoGroupByOutputType = {
    id: number
    jenis: number
    id_transaksi: number
    tanggal: Date | null
    debet: number
    kredit: number
    saldo: number
    keterangan: string
    _count: Saldo_tokoCountAggregateOutputType | null
    _avg: Saldo_tokoAvgAggregateOutputType | null
    _sum: Saldo_tokoSumAggregateOutputType | null
    _min: Saldo_tokoMinAggregateOutputType | null
    _max: Saldo_tokoMaxAggregateOutputType | null
  }

  type GetSaldo_tokoGroupByPayload<T extends saldo_tokoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Saldo_tokoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Saldo_tokoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Saldo_tokoGroupByOutputType[P]>
            : GetScalarType<T[P], Saldo_tokoGroupByOutputType[P]>
        }
      >
    >


  export type saldo_tokoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jenis?: boolean
    id_transaksi?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    saldo?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["saldo_toko"]>


  export type saldo_tokoSelectScalar = {
    id?: boolean
    jenis?: boolean
    id_transaksi?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    saldo?: boolean
    keterangan?: boolean
  }


  export type $saldo_tokoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saldo_toko"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jenis: number
      id_transaksi: number
      tanggal: Date | null
      debet: number
      kredit: number
      saldo: number
      keterangan: string
    }, ExtArgs["result"]["saldo_toko"]>
    composites: {}
  }

  type saldo_tokoGetPayload<S extends boolean | null | undefined | saldo_tokoDefaultArgs> = $Result.GetResult<Prisma.$saldo_tokoPayload, S>

  type saldo_tokoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<saldo_tokoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Saldo_tokoCountAggregateInputType | true
    }

  export interface saldo_tokoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saldo_toko'], meta: { name: 'saldo_toko' } }
    /**
     * Find zero or one Saldo_toko that matches the filter.
     * @param {saldo_tokoFindUniqueArgs} args - Arguments to find a Saldo_toko
     * @example
     * // Get one Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saldo_tokoFindUniqueArgs>(args: SelectSubset<T, saldo_tokoFindUniqueArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Saldo_toko that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {saldo_tokoFindUniqueOrThrowArgs} args - Arguments to find a Saldo_toko
     * @example
     * // Get one Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saldo_tokoFindUniqueOrThrowArgs>(args: SelectSubset<T, saldo_tokoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Saldo_toko that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoFindFirstArgs} args - Arguments to find a Saldo_toko
     * @example
     * // Get one Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saldo_tokoFindFirstArgs>(args?: SelectSubset<T, saldo_tokoFindFirstArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Saldo_toko that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoFindFirstOrThrowArgs} args - Arguments to find a Saldo_toko
     * @example
     * // Get one Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saldo_tokoFindFirstOrThrowArgs>(args?: SelectSubset<T, saldo_tokoFindFirstOrThrowArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Saldo_tokos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Saldo_tokos
     * const saldo_tokos = await prisma.saldo_toko.findMany()
     * 
     * // Get first 10 Saldo_tokos
     * const saldo_tokos = await prisma.saldo_toko.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saldo_tokoWithIdOnly = await prisma.saldo_toko.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saldo_tokoFindManyArgs>(args?: SelectSubset<T, saldo_tokoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Saldo_toko.
     * @param {saldo_tokoCreateArgs} args - Arguments to create a Saldo_toko.
     * @example
     * // Create one Saldo_toko
     * const Saldo_toko = await prisma.saldo_toko.create({
     *   data: {
     *     // ... data to create a Saldo_toko
     *   }
     * })
     * 
     */
    create<T extends saldo_tokoCreateArgs>(args: SelectSubset<T, saldo_tokoCreateArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Saldo_tokos.
     * @param {saldo_tokoCreateManyArgs} args - Arguments to create many Saldo_tokos.
     * @example
     * // Create many Saldo_tokos
     * const saldo_toko = await prisma.saldo_toko.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saldo_tokoCreateManyArgs>(args?: SelectSubset<T, saldo_tokoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Saldo_toko.
     * @param {saldo_tokoDeleteArgs} args - Arguments to delete one Saldo_toko.
     * @example
     * // Delete one Saldo_toko
     * const Saldo_toko = await prisma.saldo_toko.delete({
     *   where: {
     *     // ... filter to delete one Saldo_toko
     *   }
     * })
     * 
     */
    delete<T extends saldo_tokoDeleteArgs>(args: SelectSubset<T, saldo_tokoDeleteArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Saldo_toko.
     * @param {saldo_tokoUpdateArgs} args - Arguments to update one Saldo_toko.
     * @example
     * // Update one Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saldo_tokoUpdateArgs>(args: SelectSubset<T, saldo_tokoUpdateArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Saldo_tokos.
     * @param {saldo_tokoDeleteManyArgs} args - Arguments to filter Saldo_tokos to delete.
     * @example
     * // Delete a few Saldo_tokos
     * const { count } = await prisma.saldo_toko.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saldo_tokoDeleteManyArgs>(args?: SelectSubset<T, saldo_tokoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Saldo_tokos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Saldo_tokos
     * const saldo_toko = await prisma.saldo_toko.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saldo_tokoUpdateManyArgs>(args: SelectSubset<T, saldo_tokoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Saldo_toko.
     * @param {saldo_tokoUpsertArgs} args - Arguments to update or create a Saldo_toko.
     * @example
     * // Update or create a Saldo_toko
     * const saldo_toko = await prisma.saldo_toko.upsert({
     *   create: {
     *     // ... data to create a Saldo_toko
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Saldo_toko we want to update
     *   }
     * })
     */
    upsert<T extends saldo_tokoUpsertArgs>(args: SelectSubset<T, saldo_tokoUpsertArgs<ExtArgs>>): Prisma__saldo_tokoClient<$Result.GetResult<Prisma.$saldo_tokoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Saldo_tokos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoCountArgs} args - Arguments to filter Saldo_tokos to count.
     * @example
     * // Count the number of Saldo_tokos
     * const count = await prisma.saldo_toko.count({
     *   where: {
     *     // ... the filter for the Saldo_tokos we want to count
     *   }
     * })
    **/
    count<T extends saldo_tokoCountArgs>(
      args?: Subset<T, saldo_tokoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Saldo_tokoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Saldo_toko.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Saldo_tokoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Saldo_tokoAggregateArgs>(args: Subset<T, Saldo_tokoAggregateArgs>): Prisma.PrismaPromise<GetSaldo_tokoAggregateType<T>>

    /**
     * Group by Saldo_toko.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saldo_tokoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saldo_tokoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saldo_tokoGroupByArgs['orderBy'] }
        : { orderBy?: saldo_tokoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saldo_tokoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaldo_tokoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saldo_toko model
   */
  readonly fields: saldo_tokoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saldo_toko.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saldo_tokoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saldo_toko model
   */ 
  interface saldo_tokoFieldRefs {
    readonly id: FieldRef<"saldo_toko", 'Int'>
    readonly jenis: FieldRef<"saldo_toko", 'Int'>
    readonly id_transaksi: FieldRef<"saldo_toko", 'Int'>
    readonly tanggal: FieldRef<"saldo_toko", 'DateTime'>
    readonly debet: FieldRef<"saldo_toko", 'Float'>
    readonly kredit: FieldRef<"saldo_toko", 'Float'>
    readonly saldo: FieldRef<"saldo_toko", 'Float'>
    readonly keterangan: FieldRef<"saldo_toko", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saldo_toko findUnique
   */
  export type saldo_tokoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter, which saldo_toko to fetch.
     */
    where: saldo_tokoWhereUniqueInput
  }

  /**
   * saldo_toko findUniqueOrThrow
   */
  export type saldo_tokoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter, which saldo_toko to fetch.
     */
    where: saldo_tokoWhereUniqueInput
  }

  /**
   * saldo_toko findFirst
   */
  export type saldo_tokoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter, which saldo_toko to fetch.
     */
    where?: saldo_tokoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saldo_tokos to fetch.
     */
    orderBy?: saldo_tokoOrderByWithRelationInput | saldo_tokoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saldo_tokos.
     */
    cursor?: saldo_tokoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saldo_tokos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saldo_tokos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saldo_tokos.
     */
    distinct?: Saldo_tokoScalarFieldEnum | Saldo_tokoScalarFieldEnum[]
  }

  /**
   * saldo_toko findFirstOrThrow
   */
  export type saldo_tokoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter, which saldo_toko to fetch.
     */
    where?: saldo_tokoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saldo_tokos to fetch.
     */
    orderBy?: saldo_tokoOrderByWithRelationInput | saldo_tokoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saldo_tokos.
     */
    cursor?: saldo_tokoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saldo_tokos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saldo_tokos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saldo_tokos.
     */
    distinct?: Saldo_tokoScalarFieldEnum | Saldo_tokoScalarFieldEnum[]
  }

  /**
   * saldo_toko findMany
   */
  export type saldo_tokoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter, which saldo_tokos to fetch.
     */
    where?: saldo_tokoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saldo_tokos to fetch.
     */
    orderBy?: saldo_tokoOrderByWithRelationInput | saldo_tokoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saldo_tokos.
     */
    cursor?: saldo_tokoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saldo_tokos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saldo_tokos.
     */
    skip?: number
    distinct?: Saldo_tokoScalarFieldEnum | Saldo_tokoScalarFieldEnum[]
  }

  /**
   * saldo_toko create
   */
  export type saldo_tokoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * The data needed to create a saldo_toko.
     */
    data: XOR<saldo_tokoCreateInput, saldo_tokoUncheckedCreateInput>
  }

  /**
   * saldo_toko createMany
   */
  export type saldo_tokoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saldo_tokos.
     */
    data: saldo_tokoCreateManyInput | saldo_tokoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saldo_toko update
   */
  export type saldo_tokoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * The data needed to update a saldo_toko.
     */
    data: XOR<saldo_tokoUpdateInput, saldo_tokoUncheckedUpdateInput>
    /**
     * Choose, which saldo_toko to update.
     */
    where: saldo_tokoWhereUniqueInput
  }

  /**
   * saldo_toko updateMany
   */
  export type saldo_tokoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saldo_tokos.
     */
    data: XOR<saldo_tokoUpdateManyMutationInput, saldo_tokoUncheckedUpdateManyInput>
    /**
     * Filter which saldo_tokos to update
     */
    where?: saldo_tokoWhereInput
  }

  /**
   * saldo_toko upsert
   */
  export type saldo_tokoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * The filter to search for the saldo_toko to update in case it exists.
     */
    where: saldo_tokoWhereUniqueInput
    /**
     * In case the saldo_toko found by the `where` argument doesn't exist, create a new saldo_toko with this data.
     */
    create: XOR<saldo_tokoCreateInput, saldo_tokoUncheckedCreateInput>
    /**
     * In case the saldo_toko was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saldo_tokoUpdateInput, saldo_tokoUncheckedUpdateInput>
  }

  /**
   * saldo_toko delete
   */
  export type saldo_tokoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
    /**
     * Filter which saldo_toko to delete.
     */
    where: saldo_tokoWhereUniqueInput
  }

  /**
   * saldo_toko deleteMany
   */
  export type saldo_tokoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saldo_tokos to delete
     */
    where?: saldo_tokoWhereInput
  }

  /**
   * saldo_toko without action
   */
  export type saldo_tokoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saldo_toko
     */
    select?: saldo_tokoSelect<ExtArgs> | null
  }


  /**
   * Model shu_mutasi
   */

  export type AggregateShu_mutasi = {
    _count: Shu_mutasiCountAggregateOutputType | null
    _avg: Shu_mutasiAvgAggregateOutputType | null
    _sum: Shu_mutasiSumAggregateOutputType | null
    _min: Shu_mutasiMinAggregateOutputType | null
    _max: Shu_mutasiMaxAggregateOutputType | null
  }

  export type Shu_mutasiAvgAggregateOutputType = {
    id: number | null
    tahun_shu: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Shu_mutasiSumAggregateOutputType = {
    id: number | null
    tahun_shu: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Shu_mutasiMinAggregateOutputType = {
    id: number | null
    tahun_shu: number | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Shu_mutasiMaxAggregateOutputType = {
    id: number | null
    tahun_shu: number | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Shu_mutasiCountAggregateOutputType = {
    id: number
    tahun_shu: number
    tanggal: number
    debet: number
    kredit: number
    keterangan: number
    _all: number
  }


  export type Shu_mutasiAvgAggregateInputType = {
    id?: true
    tahun_shu?: true
    debet?: true
    kredit?: true
  }

  export type Shu_mutasiSumAggregateInputType = {
    id?: true
    tahun_shu?: true
    debet?: true
    kredit?: true
  }

  export type Shu_mutasiMinAggregateInputType = {
    id?: true
    tahun_shu?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Shu_mutasiMaxAggregateInputType = {
    id?: true
    tahun_shu?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Shu_mutasiCountAggregateInputType = {
    id?: true
    tahun_shu?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
    _all?: true
  }

  export type Shu_mutasiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shu_mutasi to aggregate.
     */
    where?: shu_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shu_mutasis to fetch.
     */
    orderBy?: shu_mutasiOrderByWithRelationInput | shu_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shu_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shu_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shu_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shu_mutasis
    **/
    _count?: true | Shu_mutasiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shu_mutasiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shu_mutasiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shu_mutasiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shu_mutasiMaxAggregateInputType
  }

  export type GetShu_mutasiAggregateType<T extends Shu_mutasiAggregateArgs> = {
        [P in keyof T & keyof AggregateShu_mutasi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShu_mutasi[P]>
      : GetScalarType<T[P], AggregateShu_mutasi[P]>
  }




  export type shu_mutasiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shu_mutasiWhereInput
    orderBy?: shu_mutasiOrderByWithAggregationInput | shu_mutasiOrderByWithAggregationInput[]
    by: Shu_mutasiScalarFieldEnum[] | Shu_mutasiScalarFieldEnum
    having?: shu_mutasiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shu_mutasiCountAggregateInputType | true
    _avg?: Shu_mutasiAvgAggregateInputType
    _sum?: Shu_mutasiSumAggregateInputType
    _min?: Shu_mutasiMinAggregateInputType
    _max?: Shu_mutasiMaxAggregateInputType
  }

  export type Shu_mutasiGroupByOutputType = {
    id: number
    tahun_shu: number
    tanggal: Date
    debet: Decimal
    kredit: Decimal
    keterangan: string
    _count: Shu_mutasiCountAggregateOutputType | null
    _avg: Shu_mutasiAvgAggregateOutputType | null
    _sum: Shu_mutasiSumAggregateOutputType | null
    _min: Shu_mutasiMinAggregateOutputType | null
    _max: Shu_mutasiMaxAggregateOutputType | null
  }

  type GetShu_mutasiGroupByPayload<T extends shu_mutasiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shu_mutasiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shu_mutasiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shu_mutasiGroupByOutputType[P]>
            : GetScalarType<T[P], Shu_mutasiGroupByOutputType[P]>
        }
      >
    >


  export type shu_mutasiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun_shu?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["shu_mutasi"]>


  export type shu_mutasiSelectScalar = {
    id?: boolean
    tahun_shu?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }


  export type $shu_mutasiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shu_mutasi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tahun_shu: number
      tanggal: Date
      debet: Prisma.Decimal
      kredit: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["shu_mutasi"]>
    composites: {}
  }

  type shu_mutasiGetPayload<S extends boolean | null | undefined | shu_mutasiDefaultArgs> = $Result.GetResult<Prisma.$shu_mutasiPayload, S>

  type shu_mutasiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<shu_mutasiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Shu_mutasiCountAggregateInputType | true
    }

  export interface shu_mutasiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shu_mutasi'], meta: { name: 'shu_mutasi' } }
    /**
     * Find zero or one Shu_mutasi that matches the filter.
     * @param {shu_mutasiFindUniqueArgs} args - Arguments to find a Shu_mutasi
     * @example
     * // Get one Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shu_mutasiFindUniqueArgs>(args: SelectSubset<T, shu_mutasiFindUniqueArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shu_mutasi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {shu_mutasiFindUniqueOrThrowArgs} args - Arguments to find a Shu_mutasi
     * @example
     * // Get one Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shu_mutasiFindUniqueOrThrowArgs>(args: SelectSubset<T, shu_mutasiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shu_mutasi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiFindFirstArgs} args - Arguments to find a Shu_mutasi
     * @example
     * // Get one Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shu_mutasiFindFirstArgs>(args?: SelectSubset<T, shu_mutasiFindFirstArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shu_mutasi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiFindFirstOrThrowArgs} args - Arguments to find a Shu_mutasi
     * @example
     * // Get one Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shu_mutasiFindFirstOrThrowArgs>(args?: SelectSubset<T, shu_mutasiFindFirstOrThrowArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shu_mutasis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shu_mutasis
     * const shu_mutasis = await prisma.shu_mutasi.findMany()
     * 
     * // Get first 10 Shu_mutasis
     * const shu_mutasis = await prisma.shu_mutasi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shu_mutasiWithIdOnly = await prisma.shu_mutasi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shu_mutasiFindManyArgs>(args?: SelectSubset<T, shu_mutasiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shu_mutasi.
     * @param {shu_mutasiCreateArgs} args - Arguments to create a Shu_mutasi.
     * @example
     * // Create one Shu_mutasi
     * const Shu_mutasi = await prisma.shu_mutasi.create({
     *   data: {
     *     // ... data to create a Shu_mutasi
     *   }
     * })
     * 
     */
    create<T extends shu_mutasiCreateArgs>(args: SelectSubset<T, shu_mutasiCreateArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shu_mutasis.
     * @param {shu_mutasiCreateManyArgs} args - Arguments to create many Shu_mutasis.
     * @example
     * // Create many Shu_mutasis
     * const shu_mutasi = await prisma.shu_mutasi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shu_mutasiCreateManyArgs>(args?: SelectSubset<T, shu_mutasiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shu_mutasi.
     * @param {shu_mutasiDeleteArgs} args - Arguments to delete one Shu_mutasi.
     * @example
     * // Delete one Shu_mutasi
     * const Shu_mutasi = await prisma.shu_mutasi.delete({
     *   where: {
     *     // ... filter to delete one Shu_mutasi
     *   }
     * })
     * 
     */
    delete<T extends shu_mutasiDeleteArgs>(args: SelectSubset<T, shu_mutasiDeleteArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shu_mutasi.
     * @param {shu_mutasiUpdateArgs} args - Arguments to update one Shu_mutasi.
     * @example
     * // Update one Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shu_mutasiUpdateArgs>(args: SelectSubset<T, shu_mutasiUpdateArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shu_mutasis.
     * @param {shu_mutasiDeleteManyArgs} args - Arguments to filter Shu_mutasis to delete.
     * @example
     * // Delete a few Shu_mutasis
     * const { count } = await prisma.shu_mutasi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shu_mutasiDeleteManyArgs>(args?: SelectSubset<T, shu_mutasiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shu_mutasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shu_mutasis
     * const shu_mutasi = await prisma.shu_mutasi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shu_mutasiUpdateManyArgs>(args: SelectSubset<T, shu_mutasiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shu_mutasi.
     * @param {shu_mutasiUpsertArgs} args - Arguments to update or create a Shu_mutasi.
     * @example
     * // Update or create a Shu_mutasi
     * const shu_mutasi = await prisma.shu_mutasi.upsert({
     *   create: {
     *     // ... data to create a Shu_mutasi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shu_mutasi we want to update
     *   }
     * })
     */
    upsert<T extends shu_mutasiUpsertArgs>(args: SelectSubset<T, shu_mutasiUpsertArgs<ExtArgs>>): Prisma__shu_mutasiClient<$Result.GetResult<Prisma.$shu_mutasiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shu_mutasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiCountArgs} args - Arguments to filter Shu_mutasis to count.
     * @example
     * // Count the number of Shu_mutasis
     * const count = await prisma.shu_mutasi.count({
     *   where: {
     *     // ... the filter for the Shu_mutasis we want to count
     *   }
     * })
    **/
    count<T extends shu_mutasiCountArgs>(
      args?: Subset<T, shu_mutasiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shu_mutasiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shu_mutasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shu_mutasiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shu_mutasiAggregateArgs>(args: Subset<T, Shu_mutasiAggregateArgs>): Prisma.PrismaPromise<GetShu_mutasiAggregateType<T>>

    /**
     * Group by Shu_mutasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shu_mutasiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shu_mutasiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shu_mutasiGroupByArgs['orderBy'] }
        : { orderBy?: shu_mutasiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shu_mutasiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShu_mutasiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shu_mutasi model
   */
  readonly fields: shu_mutasiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shu_mutasi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shu_mutasiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shu_mutasi model
   */ 
  interface shu_mutasiFieldRefs {
    readonly id: FieldRef<"shu_mutasi", 'Int'>
    readonly tahun_shu: FieldRef<"shu_mutasi", 'Int'>
    readonly tanggal: FieldRef<"shu_mutasi", 'DateTime'>
    readonly debet: FieldRef<"shu_mutasi", 'Decimal'>
    readonly kredit: FieldRef<"shu_mutasi", 'Decimal'>
    readonly keterangan: FieldRef<"shu_mutasi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * shu_mutasi findUnique
   */
  export type shu_mutasiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which shu_mutasi to fetch.
     */
    where: shu_mutasiWhereUniqueInput
  }

  /**
   * shu_mutasi findUniqueOrThrow
   */
  export type shu_mutasiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which shu_mutasi to fetch.
     */
    where: shu_mutasiWhereUniqueInput
  }

  /**
   * shu_mutasi findFirst
   */
  export type shu_mutasiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which shu_mutasi to fetch.
     */
    where?: shu_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shu_mutasis to fetch.
     */
    orderBy?: shu_mutasiOrderByWithRelationInput | shu_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shu_mutasis.
     */
    cursor?: shu_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shu_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shu_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shu_mutasis.
     */
    distinct?: Shu_mutasiScalarFieldEnum | Shu_mutasiScalarFieldEnum[]
  }

  /**
   * shu_mutasi findFirstOrThrow
   */
  export type shu_mutasiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which shu_mutasi to fetch.
     */
    where?: shu_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shu_mutasis to fetch.
     */
    orderBy?: shu_mutasiOrderByWithRelationInput | shu_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shu_mutasis.
     */
    cursor?: shu_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shu_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shu_mutasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shu_mutasis.
     */
    distinct?: Shu_mutasiScalarFieldEnum | Shu_mutasiScalarFieldEnum[]
  }

  /**
   * shu_mutasi findMany
   */
  export type shu_mutasiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter, which shu_mutasis to fetch.
     */
    where?: shu_mutasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shu_mutasis to fetch.
     */
    orderBy?: shu_mutasiOrderByWithRelationInput | shu_mutasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shu_mutasis.
     */
    cursor?: shu_mutasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shu_mutasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shu_mutasis.
     */
    skip?: number
    distinct?: Shu_mutasiScalarFieldEnum | Shu_mutasiScalarFieldEnum[]
  }

  /**
   * shu_mutasi create
   */
  export type shu_mutasiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * The data needed to create a shu_mutasi.
     */
    data: XOR<shu_mutasiCreateInput, shu_mutasiUncheckedCreateInput>
  }

  /**
   * shu_mutasi createMany
   */
  export type shu_mutasiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shu_mutasis.
     */
    data: shu_mutasiCreateManyInput | shu_mutasiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shu_mutasi update
   */
  export type shu_mutasiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * The data needed to update a shu_mutasi.
     */
    data: XOR<shu_mutasiUpdateInput, shu_mutasiUncheckedUpdateInput>
    /**
     * Choose, which shu_mutasi to update.
     */
    where: shu_mutasiWhereUniqueInput
  }

  /**
   * shu_mutasi updateMany
   */
  export type shu_mutasiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shu_mutasis.
     */
    data: XOR<shu_mutasiUpdateManyMutationInput, shu_mutasiUncheckedUpdateManyInput>
    /**
     * Filter which shu_mutasis to update
     */
    where?: shu_mutasiWhereInput
  }

  /**
   * shu_mutasi upsert
   */
  export type shu_mutasiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * The filter to search for the shu_mutasi to update in case it exists.
     */
    where: shu_mutasiWhereUniqueInput
    /**
     * In case the shu_mutasi found by the `where` argument doesn't exist, create a new shu_mutasi with this data.
     */
    create: XOR<shu_mutasiCreateInput, shu_mutasiUncheckedCreateInput>
    /**
     * In case the shu_mutasi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shu_mutasiUpdateInput, shu_mutasiUncheckedUpdateInput>
  }

  /**
   * shu_mutasi delete
   */
  export type shu_mutasiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
    /**
     * Filter which shu_mutasi to delete.
     */
    where: shu_mutasiWhereUniqueInput
  }

  /**
   * shu_mutasi deleteMany
   */
  export type shu_mutasiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shu_mutasis to delete
     */
    where?: shu_mutasiWhereInput
  }

  /**
   * shu_mutasi without action
   */
  export type shu_mutasiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shu_mutasi
     */
    select?: shu_mutasiSelect<ExtArgs> | null
  }


  /**
   * Model supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
    kredit: Decimal | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
    kredit: Decimal | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    pemilik: string | null
    kontak: string | null
    kredit: Decimal | null
    created: Date | null
    modified: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    nama: string | null
    alamat: string | null
    pemilik: string | null
    kontak: string | null
    kredit: Decimal | null
    created: Date | null
    modified: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    kode: number
    nama: number
    alamat: number
    pemilik: number
    kontak: number
    kredit: number
    created: number
    modified: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
    kredit?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
    kredit?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    pemilik?: true
    kontak?: true
    kredit?: true
    created?: true
    modified?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    pemilik?: true
    kontak?: true
    kredit?: true
    created?: true
    modified?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    kode?: true
    nama?: true
    alamat?: true
    pemilik?: true
    kontak?: true
    kredit?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier to aggregate.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type supplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplierWhereInput
    orderBy?: supplierOrderByWithAggregationInput | supplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: supplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    kode: string
    nama: string
    alamat: string
    pemilik: string
    kontak: string
    kredit: Decimal
    created: Date
    modified: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends supplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type supplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    pemilik?: boolean
    kontak?: boolean
    kredit?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["supplier"]>


  export type supplierSelectScalar = {
    id?: boolean
    kode?: boolean
    nama?: boolean
    alamat?: boolean
    pemilik?: boolean
    kontak?: boolean
    kredit?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $supplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      nama: string
      alamat: string
      pemilik: string
      kontak: string
      kredit: Prisma.Decimal
      created: Date
      modified: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type supplierGetPayload<S extends boolean | null | undefined | supplierDefaultArgs> = $Result.GetResult<Prisma.$supplierPayload, S>

  type supplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface supplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier'], meta: { name: 'supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {supplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supplierFindUniqueArgs>(args: SelectSubset<T, supplierFindUniqueArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {supplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supplierFindUniqueOrThrowArgs>(args: SelectSubset<T, supplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supplierFindFirstArgs>(args?: SelectSubset<T, supplierFindFirstArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supplierFindFirstOrThrowArgs>(args?: SelectSubset<T, supplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends supplierFindManyArgs>(args?: SelectSubset<T, supplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {supplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends supplierCreateArgs>(args: SelectSubset<T, supplierCreateArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {supplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supplierCreateManyArgs>(args?: SelectSubset<T, supplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {supplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends supplierDeleteArgs>(args: SelectSubset<T, supplierDeleteArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {supplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supplierUpdateArgs>(args: SelectSubset<T, supplierUpdateArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {supplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supplierDeleteManyArgs>(args?: SelectSubset<T, supplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supplierUpdateManyArgs>(args: SelectSubset<T, supplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {supplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends supplierUpsertArgs>(args: SelectSubset<T, supplierUpsertArgs<ExtArgs>>): Prisma__supplierClient<$Result.GetResult<Prisma.$supplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends supplierCountArgs>(
      args?: Subset<T, supplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplierGroupByArgs['orderBy'] }
        : { orderBy?: supplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier model
   */
  readonly fields: supplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supplier model
   */ 
  interface supplierFieldRefs {
    readonly id: FieldRef<"supplier", 'Int'>
    readonly kode: FieldRef<"supplier", 'String'>
    readonly nama: FieldRef<"supplier", 'String'>
    readonly alamat: FieldRef<"supplier", 'String'>
    readonly pemilik: FieldRef<"supplier", 'String'>
    readonly kontak: FieldRef<"supplier", 'String'>
    readonly kredit: FieldRef<"supplier", 'Decimal'>
    readonly created: FieldRef<"supplier", 'DateTime'>
    readonly modified: FieldRef<"supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * supplier findUnique
   */
  export type supplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findUniqueOrThrow
   */
  export type supplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier findFirst
   */
  export type supplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findFirstOrThrow
   */
  export type supplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter, which supplier to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier findMany
   */
  export type supplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter, which suppliers to fetch.
     */
    where?: supplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suppliers to fetch.
     */
    orderBy?: supplierOrderByWithRelationInput | supplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suppliers.
     */
    cursor?: supplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * supplier create
   */
  export type supplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * The data needed to create a supplier.
     */
    data: XOR<supplierCreateInput, supplierUncheckedCreateInput>
  }

  /**
   * supplier createMany
   */
  export type supplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suppliers.
     */
    data: supplierCreateManyInput | supplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplier update
   */
  export type supplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * The data needed to update a supplier.
     */
    data: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
    /**
     * Choose, which supplier to update.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier updateMany
   */
  export type supplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suppliers.
     */
    data: XOR<supplierUpdateManyMutationInput, supplierUncheckedUpdateManyInput>
    /**
     * Filter which suppliers to update
     */
    where?: supplierWhereInput
  }

  /**
   * supplier upsert
   */
  export type supplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * The filter to search for the supplier to update in case it exists.
     */
    where: supplierWhereUniqueInput
    /**
     * In case the supplier found by the `where` argument doesn't exist, create a new supplier with this data.
     */
    create: XOR<supplierCreateInput, supplierUncheckedCreateInput>
    /**
     * In case the supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplierUpdateInput, supplierUncheckedUpdateInput>
  }

  /**
   * supplier delete
   */
  export type supplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
    /**
     * Filter which supplier to delete.
     */
    where: supplierWhereUniqueInput
  }

  /**
   * supplier deleteMany
   */
  export type supplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suppliers to delete
     */
    where?: supplierWhereInput
  }

  /**
   * supplier without action
   */
  export type supplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier
     */
    select?: supplierSelect<ExtArgs> | null
  }


  /**
   * Model supplier_kredit
   */

  export type AggregateSupplier_kredit = {
    _count: Supplier_kreditCountAggregateOutputType | null
    _avg: Supplier_kreditAvgAggregateOutputType | null
    _sum: Supplier_kreditSumAggregateOutputType | null
    _min: Supplier_kreditMinAggregateOutputType | null
    _max: Supplier_kreditMaxAggregateOutputType | null
  }

  export type Supplier_kreditAvgAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Supplier_kreditSumAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Supplier_kreditMinAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    ex_bukti: string | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Supplier_kreditMaxAggregateOutputType = {
    id: number | null
    id_supplier: number | null
    id_transaksi: number | null
    ex_bukti: string | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Supplier_kreditCountAggregateOutputType = {
    id: number
    id_supplier: number
    id_transaksi: number
    ex_bukti: number
    tanggal: number
    debet: number
    kredit: number
    keterangan: number
    _all: number
  }


  export type Supplier_kreditAvgAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
  }

  export type Supplier_kreditSumAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    debet?: true
    kredit?: true
  }

  export type Supplier_kreditMinAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Supplier_kreditMaxAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Supplier_kreditCountAggregateInputType = {
    id?: true
    id_supplier?: true
    id_transaksi?: true
    ex_bukti?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
    _all?: true
  }

  export type Supplier_kreditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier_kredit to aggregate.
     */
    where?: supplier_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplier_kredits to fetch.
     */
    orderBy?: supplier_kreditOrderByWithRelationInput | supplier_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supplier_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplier_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplier_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supplier_kredits
    **/
    _count?: true | Supplier_kreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Supplier_kreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Supplier_kreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Supplier_kreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Supplier_kreditMaxAggregateInputType
  }

  export type GetSupplier_kreditAggregateType<T extends Supplier_kreditAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier_kredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier_kredit[P]>
      : GetScalarType<T[P], AggregateSupplier_kredit[P]>
  }




  export type supplier_kreditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supplier_kreditWhereInput
    orderBy?: supplier_kreditOrderByWithAggregationInput | supplier_kreditOrderByWithAggregationInput[]
    by: Supplier_kreditScalarFieldEnum[] | Supplier_kreditScalarFieldEnum
    having?: supplier_kreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Supplier_kreditCountAggregateInputType | true
    _avg?: Supplier_kreditAvgAggregateInputType
    _sum?: Supplier_kreditSumAggregateInputType
    _min?: Supplier_kreditMinAggregateInputType
    _max?: Supplier_kreditMaxAggregateInputType
  }

  export type Supplier_kreditGroupByOutputType = {
    id: number
    id_supplier: number
    id_transaksi: number
    ex_bukti: string
    tanggal: Date | null
    debet: Decimal
    kredit: Decimal
    keterangan: string
    _count: Supplier_kreditCountAggregateOutputType | null
    _avg: Supplier_kreditAvgAggregateOutputType | null
    _sum: Supplier_kreditSumAggregateOutputType | null
    _min: Supplier_kreditMinAggregateOutputType | null
    _max: Supplier_kreditMaxAggregateOutputType | null
  }

  type GetSupplier_kreditGroupByPayload<T extends supplier_kreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Supplier_kreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Supplier_kreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Supplier_kreditGroupByOutputType[P]>
            : GetScalarType<T[P], Supplier_kreditGroupByOutputType[P]>
        }
      >
    >


  export type supplier_kreditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_supplier?: boolean
    id_transaksi?: boolean
    ex_bukti?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["supplier_kredit"]>


  export type supplier_kreditSelectScalar = {
    id?: boolean
    id_supplier?: boolean
    id_transaksi?: boolean
    ex_bukti?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }


  export type $supplier_kreditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supplier_kredit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      id_supplier: number
      id_transaksi: number
      ex_bukti: string
      tanggal: Date | null
      debet: Prisma.Decimal
      kredit: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["supplier_kredit"]>
    composites: {}
  }

  type supplier_kreditGetPayload<S extends boolean | null | undefined | supplier_kreditDefaultArgs> = $Result.GetResult<Prisma.$supplier_kreditPayload, S>

  type supplier_kreditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supplier_kreditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Supplier_kreditCountAggregateInputType | true
    }

  export interface supplier_kreditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supplier_kredit'], meta: { name: 'supplier_kredit' } }
    /**
     * Find zero or one Supplier_kredit that matches the filter.
     * @param {supplier_kreditFindUniqueArgs} args - Arguments to find a Supplier_kredit
     * @example
     * // Get one Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supplier_kreditFindUniqueArgs>(args: SelectSubset<T, supplier_kreditFindUniqueArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier_kredit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {supplier_kreditFindUniqueOrThrowArgs} args - Arguments to find a Supplier_kredit
     * @example
     * // Get one Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supplier_kreditFindUniqueOrThrowArgs>(args: SelectSubset<T, supplier_kreditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier_kredit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditFindFirstArgs} args - Arguments to find a Supplier_kredit
     * @example
     * // Get one Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supplier_kreditFindFirstArgs>(args?: SelectSubset<T, supplier_kreditFindFirstArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier_kredit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditFindFirstOrThrowArgs} args - Arguments to find a Supplier_kredit
     * @example
     * // Get one Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supplier_kreditFindFirstOrThrowArgs>(args?: SelectSubset<T, supplier_kreditFindFirstOrThrowArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Supplier_kredits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supplier_kredits
     * const supplier_kredits = await prisma.supplier_kredit.findMany()
     * 
     * // Get first 10 Supplier_kredits
     * const supplier_kredits = await prisma.supplier_kredit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplier_kreditWithIdOnly = await prisma.supplier_kredit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends supplier_kreditFindManyArgs>(args?: SelectSubset<T, supplier_kreditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier_kredit.
     * @param {supplier_kreditCreateArgs} args - Arguments to create a Supplier_kredit.
     * @example
     * // Create one Supplier_kredit
     * const Supplier_kredit = await prisma.supplier_kredit.create({
     *   data: {
     *     // ... data to create a Supplier_kredit
     *   }
     * })
     * 
     */
    create<T extends supplier_kreditCreateArgs>(args: SelectSubset<T, supplier_kreditCreateArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Supplier_kredits.
     * @param {supplier_kreditCreateManyArgs} args - Arguments to create many Supplier_kredits.
     * @example
     * // Create many Supplier_kredits
     * const supplier_kredit = await prisma.supplier_kredit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supplier_kreditCreateManyArgs>(args?: SelectSubset<T, supplier_kreditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier_kredit.
     * @param {supplier_kreditDeleteArgs} args - Arguments to delete one Supplier_kredit.
     * @example
     * // Delete one Supplier_kredit
     * const Supplier_kredit = await prisma.supplier_kredit.delete({
     *   where: {
     *     // ... filter to delete one Supplier_kredit
     *   }
     * })
     * 
     */
    delete<T extends supplier_kreditDeleteArgs>(args: SelectSubset<T, supplier_kreditDeleteArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier_kredit.
     * @param {supplier_kreditUpdateArgs} args - Arguments to update one Supplier_kredit.
     * @example
     * // Update one Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supplier_kreditUpdateArgs>(args: SelectSubset<T, supplier_kreditUpdateArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Supplier_kredits.
     * @param {supplier_kreditDeleteManyArgs} args - Arguments to filter Supplier_kredits to delete.
     * @example
     * // Delete a few Supplier_kredits
     * const { count } = await prisma.supplier_kredit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supplier_kreditDeleteManyArgs>(args?: SelectSubset<T, supplier_kreditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supplier_kredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supplier_kredits
     * const supplier_kredit = await prisma.supplier_kredit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supplier_kreditUpdateManyArgs>(args: SelectSubset<T, supplier_kreditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier_kredit.
     * @param {supplier_kreditUpsertArgs} args - Arguments to update or create a Supplier_kredit.
     * @example
     * // Update or create a Supplier_kredit
     * const supplier_kredit = await prisma.supplier_kredit.upsert({
     *   create: {
     *     // ... data to create a Supplier_kredit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier_kredit we want to update
     *   }
     * })
     */
    upsert<T extends supplier_kreditUpsertArgs>(args: SelectSubset<T, supplier_kreditUpsertArgs<ExtArgs>>): Prisma__supplier_kreditClient<$Result.GetResult<Prisma.$supplier_kreditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Supplier_kredits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditCountArgs} args - Arguments to filter Supplier_kredits to count.
     * @example
     * // Count the number of Supplier_kredits
     * const count = await prisma.supplier_kredit.count({
     *   where: {
     *     // ... the filter for the Supplier_kredits we want to count
     *   }
     * })
    **/
    count<T extends supplier_kreditCountArgs>(
      args?: Subset<T, supplier_kreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Supplier_kreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier_kredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Supplier_kreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Supplier_kreditAggregateArgs>(args: Subset<T, Supplier_kreditAggregateArgs>): Prisma.PrismaPromise<GetSupplier_kreditAggregateType<T>>

    /**
     * Group by Supplier_kredit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supplier_kreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supplier_kreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supplier_kreditGroupByArgs['orderBy'] }
        : { orderBy?: supplier_kreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supplier_kreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplier_kreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supplier_kredit model
   */
  readonly fields: supplier_kreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supplier_kredit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supplier_kreditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supplier_kredit model
   */ 
  interface supplier_kreditFieldRefs {
    readonly id: FieldRef<"supplier_kredit", 'Int'>
    readonly id_supplier: FieldRef<"supplier_kredit", 'Int'>
    readonly id_transaksi: FieldRef<"supplier_kredit", 'Int'>
    readonly ex_bukti: FieldRef<"supplier_kredit", 'String'>
    readonly tanggal: FieldRef<"supplier_kredit", 'DateTime'>
    readonly debet: FieldRef<"supplier_kredit", 'Decimal'>
    readonly kredit: FieldRef<"supplier_kredit", 'Decimal'>
    readonly keterangan: FieldRef<"supplier_kredit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * supplier_kredit findUnique
   */
  export type supplier_kreditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter, which supplier_kredit to fetch.
     */
    where: supplier_kreditWhereUniqueInput
  }

  /**
   * supplier_kredit findUniqueOrThrow
   */
  export type supplier_kreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter, which supplier_kredit to fetch.
     */
    where: supplier_kreditWhereUniqueInput
  }

  /**
   * supplier_kredit findFirst
   */
  export type supplier_kreditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter, which supplier_kredit to fetch.
     */
    where?: supplier_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplier_kredits to fetch.
     */
    orderBy?: supplier_kreditOrderByWithRelationInput | supplier_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supplier_kredits.
     */
    cursor?: supplier_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplier_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplier_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supplier_kredits.
     */
    distinct?: Supplier_kreditScalarFieldEnum | Supplier_kreditScalarFieldEnum[]
  }

  /**
   * supplier_kredit findFirstOrThrow
   */
  export type supplier_kreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter, which supplier_kredit to fetch.
     */
    where?: supplier_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplier_kredits to fetch.
     */
    orderBy?: supplier_kreditOrderByWithRelationInput | supplier_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supplier_kredits.
     */
    cursor?: supplier_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplier_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplier_kredits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supplier_kredits.
     */
    distinct?: Supplier_kreditScalarFieldEnum | Supplier_kreditScalarFieldEnum[]
  }

  /**
   * supplier_kredit findMany
   */
  export type supplier_kreditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter, which supplier_kredits to fetch.
     */
    where?: supplier_kreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supplier_kredits to fetch.
     */
    orderBy?: supplier_kreditOrderByWithRelationInput | supplier_kreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supplier_kredits.
     */
    cursor?: supplier_kreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supplier_kredits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supplier_kredits.
     */
    skip?: number
    distinct?: Supplier_kreditScalarFieldEnum | Supplier_kreditScalarFieldEnum[]
  }

  /**
   * supplier_kredit create
   */
  export type supplier_kreditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * The data needed to create a supplier_kredit.
     */
    data: XOR<supplier_kreditCreateInput, supplier_kreditUncheckedCreateInput>
  }

  /**
   * supplier_kredit createMany
   */
  export type supplier_kreditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supplier_kredits.
     */
    data: supplier_kreditCreateManyInput | supplier_kreditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supplier_kredit update
   */
  export type supplier_kreditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * The data needed to update a supplier_kredit.
     */
    data: XOR<supplier_kreditUpdateInput, supplier_kreditUncheckedUpdateInput>
    /**
     * Choose, which supplier_kredit to update.
     */
    where: supplier_kreditWhereUniqueInput
  }

  /**
   * supplier_kredit updateMany
   */
  export type supplier_kreditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supplier_kredits.
     */
    data: XOR<supplier_kreditUpdateManyMutationInput, supplier_kreditUncheckedUpdateManyInput>
    /**
     * Filter which supplier_kredits to update
     */
    where?: supplier_kreditWhereInput
  }

  /**
   * supplier_kredit upsert
   */
  export type supplier_kreditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * The filter to search for the supplier_kredit to update in case it exists.
     */
    where: supplier_kreditWhereUniqueInput
    /**
     * In case the supplier_kredit found by the `where` argument doesn't exist, create a new supplier_kredit with this data.
     */
    create: XOR<supplier_kreditCreateInput, supplier_kreditUncheckedCreateInput>
    /**
     * In case the supplier_kredit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supplier_kreditUpdateInput, supplier_kreditUncheckedUpdateInput>
  }

  /**
   * supplier_kredit delete
   */
  export type supplier_kreditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
    /**
     * Filter which supplier_kredit to delete.
     */
    where: supplier_kreditWhereUniqueInput
  }

  /**
   * supplier_kredit deleteMany
   */
  export type supplier_kreditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supplier_kredits to delete
     */
    where?: supplier_kreditWhereInput
  }

  /**
   * supplier_kredit without action
   */
  export type supplier_kreditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supplier_kredit
     */
    select?: supplier_kreditSelect<ExtArgs> | null
  }


  /**
   * Model transaksi
   */

  export type AggregateTransaksi = {
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  export type TransaksiAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    sumber: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    diskon_item: number | null
    diskon_persen: number | null
    diskon_total: Decimal | null
    bayar: Decimal | null
    kredit: number | null
    anggota: number | null
    admin: number | null
    status: number | null
  }

  export type TransaksiSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    sumber: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    diskon_item: number | null
    diskon_persen: number | null
    diskon_total: Decimal | null
    bayar: Decimal | null
    kredit: number | null
    anggota: number | null
    admin: number | null
    status: number | null
  }

  export type TransaksiMinAggregateOutputType = {
    id: number | null
    kode: string | null
    kode_ex: string | null
    kode_2: string | null
    tanggal: Date | null
    jenis: number | null
    sumber: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    diskon_item: number | null
    diskon_persen: number | null
    diskon_total: Decimal | null
    bayar: Decimal | null
    kredit: number | null
    keterangan: string | null
    anggota: number | null
    admin: number | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type TransaksiMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    kode_ex: string | null
    kode_2: string | null
    tanggal: Date | null
    jenis: number | null
    sumber: number | null
    jumlah: number | null
    produk: number | null
    total_beli: Decimal | null
    total_jual: Decimal | null
    diskon_item: number | null
    diskon_persen: number | null
    diskon_total: Decimal | null
    bayar: Decimal | null
    kredit: number | null
    keterangan: string | null
    anggota: number | null
    admin: number | null
    status: number | null
    created: Date | null
    modified: Date | null
  }

  export type TransaksiCountAggregateOutputType = {
    id: number
    kode: number
    kode_ex: number
    kode_2: number
    tanggal: number
    jenis: number
    sumber: number
    jumlah: number
    produk: number
    total_beli: number
    total_jual: number
    diskon_item: number
    diskon_persen: number
    diskon_total: number
    bayar: number
    kredit: number
    keterangan: number
    anggota: number
    admin: number
    status: number
    created: number
    modified: number
    _all: number
  }


  export type TransaksiAvgAggregateInputType = {
    id?: true
    jenis?: true
    sumber?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    diskon_item?: true
    diskon_persen?: true
    diskon_total?: true
    bayar?: true
    kredit?: true
    anggota?: true
    admin?: true
    status?: true
  }

  export type TransaksiSumAggregateInputType = {
    id?: true
    jenis?: true
    sumber?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    diskon_item?: true
    diskon_persen?: true
    diskon_total?: true
    bayar?: true
    kredit?: true
    anggota?: true
    admin?: true
    status?: true
  }

  export type TransaksiMinAggregateInputType = {
    id?: true
    kode?: true
    kode_ex?: true
    kode_2?: true
    tanggal?: true
    jenis?: true
    sumber?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    diskon_item?: true
    diskon_persen?: true
    diskon_total?: true
    bayar?: true
    kredit?: true
    keterangan?: true
    anggota?: true
    admin?: true
    status?: true
    created?: true
    modified?: true
  }

  export type TransaksiMaxAggregateInputType = {
    id?: true
    kode?: true
    kode_ex?: true
    kode_2?: true
    tanggal?: true
    jenis?: true
    sumber?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    diskon_item?: true
    diskon_persen?: true
    diskon_total?: true
    bayar?: true
    kredit?: true
    keterangan?: true
    anggota?: true
    admin?: true
    status?: true
    created?: true
    modified?: true
  }

  export type TransaksiCountAggregateInputType = {
    id?: true
    kode?: true
    kode_ex?: true
    kode_2?: true
    tanggal?: true
    jenis?: true
    sumber?: true
    jumlah?: true
    produk?: true
    total_beli?: true
    total_jual?: true
    diskon_item?: true
    diskon_persen?: true
    diskon_total?: true
    bayar?: true
    kredit?: true
    keterangan?: true
    anggota?: true
    admin?: true
    status?: true
    created?: true
    modified?: true
    _all?: true
  }

  export type TransaksiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi to aggregate.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksis
    **/
    _count?: true | TransaksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransaksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransaksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransaksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransaksiMaxAggregateInputType
  }

  export type GetTransaksiAggregateType<T extends TransaksiAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi[P]>
      : GetScalarType<T[P], AggregateTransaksi[P]>
  }




  export type transaksiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithAggregationInput | transaksiOrderByWithAggregationInput[]
    by: TransaksiScalarFieldEnum[] | TransaksiScalarFieldEnum
    having?: transaksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransaksiCountAggregateInputType | true
    _avg?: TransaksiAvgAggregateInputType
    _sum?: TransaksiSumAggregateInputType
    _min?: TransaksiMinAggregateInputType
    _max?: TransaksiMaxAggregateInputType
  }

  export type TransaksiGroupByOutputType = {
    id: number
    kode: string
    kode_ex: string
    kode_2: string
    tanggal: Date | null
    jenis: number
    sumber: number
    jumlah: number
    produk: number
    total_beli: Decimal
    total_jual: Decimal
    diskon_item: number
    diskon_persen: number
    diskon_total: Decimal
    bayar: Decimal
    kredit: number
    keterangan: string
    anggota: number
    admin: number
    status: number
    created: Date | null
    modified: Date | null
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  type GetTransaksiGroupByPayload<T extends transaksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransaksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransaksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
            : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
        }
      >
    >


  export type transaksiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kode?: boolean
    kode_ex?: boolean
    kode_2?: boolean
    tanggal?: boolean
    jenis?: boolean
    sumber?: boolean
    jumlah?: boolean
    produk?: boolean
    total_beli?: boolean
    total_jual?: boolean
    diskon_item?: boolean
    diskon_persen?: boolean
    diskon_total?: boolean
    bayar?: boolean
    kredit?: boolean
    keterangan?: boolean
    anggota?: boolean
    admin?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }, ExtArgs["result"]["transaksi"]>


  export type transaksiSelectScalar = {
    id?: boolean
    kode?: boolean
    kode_ex?: boolean
    kode_2?: boolean
    tanggal?: boolean
    jenis?: boolean
    sumber?: boolean
    jumlah?: boolean
    produk?: boolean
    total_beli?: boolean
    total_jual?: boolean
    diskon_item?: boolean
    diskon_persen?: boolean
    diskon_total?: boolean
    bayar?: boolean
    kredit?: boolean
    keterangan?: boolean
    anggota?: boolean
    admin?: boolean
    status?: boolean
    created?: boolean
    modified?: boolean
  }


  export type $transaksiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      kode: string
      kode_ex: string
      kode_2: string
      tanggal: Date | null
      jenis: number
      sumber: number
      jumlah: number
      produk: number
      total_beli: Prisma.Decimal
      total_jual: Prisma.Decimal
      diskon_item: number
      diskon_persen: number
      diskon_total: Prisma.Decimal
      bayar: Prisma.Decimal
      kredit: number
      keterangan: string
      anggota: number
      admin: number
      status: number
      created: Date | null
      modified: Date | null
    }, ExtArgs["result"]["transaksi"]>
    composites: {}
  }

  type transaksiGetPayload<S extends boolean | null | undefined | transaksiDefaultArgs> = $Result.GetResult<Prisma.$transaksiPayload, S>

  type transaksiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transaksiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransaksiCountAggregateInputType | true
    }

  export interface transaksiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi'], meta: { name: 'transaksi' } }
    /**
     * Find zero or one Transaksi that matches the filter.
     * @param {transaksiFindUniqueArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksiFindUniqueArgs>(args: SelectSubset<T, transaksiFindUniqueArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaksi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transaksiFindUniqueOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksiFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksiFindFirstArgs>(args?: SelectSubset<T, transaksiFindFirstArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksiFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksiFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transaksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksis
     * const transaksis = await prisma.transaksi.findMany()
     * 
     * // Get first 10 Transaksis
     * const transaksis = await prisma.transaksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksiWithIdOnly = await prisma.transaksi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksiFindManyArgs>(args?: SelectSubset<T, transaksiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaksi.
     * @param {transaksiCreateArgs} args - Arguments to create a Transaksi.
     * @example
     * // Create one Transaksi
     * const Transaksi = await prisma.transaksi.create({
     *   data: {
     *     // ... data to create a Transaksi
     *   }
     * })
     * 
     */
    create<T extends transaksiCreateArgs>(args: SelectSubset<T, transaksiCreateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transaksis.
     * @param {transaksiCreateManyArgs} args - Arguments to create many Transaksis.
     * @example
     * // Create many Transaksis
     * const transaksi = await prisma.transaksi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksiCreateManyArgs>(args?: SelectSubset<T, transaksiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaksi.
     * @param {transaksiDeleteArgs} args - Arguments to delete one Transaksi.
     * @example
     * // Delete one Transaksi
     * const Transaksi = await prisma.transaksi.delete({
     *   where: {
     *     // ... filter to delete one Transaksi
     *   }
     * })
     * 
     */
    delete<T extends transaksiDeleteArgs>(args: SelectSubset<T, transaksiDeleteArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaksi.
     * @param {transaksiUpdateArgs} args - Arguments to update one Transaksi.
     * @example
     * // Update one Transaksi
     * const transaksi = await prisma.transaksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksiUpdateArgs>(args: SelectSubset<T, transaksiUpdateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transaksis.
     * @param {transaksiDeleteManyArgs} args - Arguments to filter Transaksis to delete.
     * @example
     * // Delete a few Transaksis
     * const { count } = await prisma.transaksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksiDeleteManyArgs>(args?: SelectSubset<T, transaksiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksis
     * const transaksi = await prisma.transaksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksiUpdateManyArgs>(args: SelectSubset<T, transaksiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaksi.
     * @param {transaksiUpsertArgs} args - Arguments to update or create a Transaksi.
     * @example
     * // Update or create a Transaksi
     * const transaksi = await prisma.transaksi.upsert({
     *   create: {
     *     // ... data to create a Transaksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi we want to update
     *   }
     * })
     */
    upsert<T extends transaksiUpsertArgs>(args: SelectSubset<T, transaksiUpsertArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiCountArgs} args - Arguments to filter Transaksis to count.
     * @example
     * // Count the number of Transaksis
     * const count = await prisma.transaksi.count({
     *   where: {
     *     // ... the filter for the Transaksis we want to count
     *   }
     * })
    **/
    count<T extends transaksiCountArgs>(
      args?: Subset<T, transaksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransaksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransaksiAggregateArgs>(args: Subset<T, TransaksiAggregateArgs>): Prisma.PrismaPromise<GetTransaksiAggregateType<T>>

    /**
     * Group by Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksiGroupByArgs['orderBy'] }
        : { orderBy?: transaksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi model
   */
  readonly fields: transaksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi model
   */ 
  interface transaksiFieldRefs {
    readonly id: FieldRef<"transaksi", 'Int'>
    readonly kode: FieldRef<"transaksi", 'String'>
    readonly kode_ex: FieldRef<"transaksi", 'String'>
    readonly kode_2: FieldRef<"transaksi", 'String'>
    readonly tanggal: FieldRef<"transaksi", 'DateTime'>
    readonly jenis: FieldRef<"transaksi", 'Int'>
    readonly sumber: FieldRef<"transaksi", 'Int'>
    readonly jumlah: FieldRef<"transaksi", 'Float'>
    readonly produk: FieldRef<"transaksi", 'Int'>
    readonly total_beli: FieldRef<"transaksi", 'Decimal'>
    readonly total_jual: FieldRef<"transaksi", 'Decimal'>
    readonly diskon_item: FieldRef<"transaksi", 'Float'>
    readonly diskon_persen: FieldRef<"transaksi", 'Int'>
    readonly diskon_total: FieldRef<"transaksi", 'Decimal'>
    readonly bayar: FieldRef<"transaksi", 'Decimal'>
    readonly kredit: FieldRef<"transaksi", 'Int'>
    readonly keterangan: FieldRef<"transaksi", 'String'>
    readonly anggota: FieldRef<"transaksi", 'Int'>
    readonly admin: FieldRef<"transaksi", 'Int'>
    readonly status: FieldRef<"transaksi", 'Int'>
    readonly created: FieldRef<"transaksi", 'DateTime'>
    readonly modified: FieldRef<"transaksi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaksi findUnique
   */
  export type transaksiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findUniqueOrThrow
   */
  export type transaksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findFirst
   */
  export type transaksiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findFirstOrThrow
   */
  export type transaksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findMany
   */
  export type transaksiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter, which transaksis to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi create
   */
  export type transaksiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * The data needed to create a transaksi.
     */
    data: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
  }

  /**
   * transaksi createMany
   */
  export type transaksiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksis.
     */
    data: transaksiCreateManyInput | transaksiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi update
   */
  export type transaksiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * The data needed to update a transaksi.
     */
    data: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
    /**
     * Choose, which transaksi to update.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi updateMany
   */
  export type transaksiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksis.
     */
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyInput>
    /**
     * Filter which transaksis to update
     */
    where?: transaksiWhereInput
  }

  /**
   * transaksi upsert
   */
  export type transaksiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * The filter to search for the transaksi to update in case it exists.
     */
    where: transaksiWhereUniqueInput
    /**
     * In case the transaksi found by the `where` argument doesn't exist, create a new transaksi with this data.
     */
    create: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
    /**
     * In case the transaksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
  }

  /**
   * transaksi delete
   */
  export type transaksiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Filter which transaksi to delete.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi deleteMany
   */
  export type transaksiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksis to delete
     */
    where?: transaksiWhereInput
  }

  /**
   * transaksi without action
   */
  export type transaksiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
  }


  /**
   * Model transaksi_item
   */

  export type AggregateTransaksi_item = {
    _count: Transaksi_itemCountAggregateOutputType | null
    _avg: Transaksi_itemAvgAggregateOutputType | null
    _sum: Transaksi_itemSumAggregateOutputType | null
    _min: Transaksi_itemMinAggregateOutputType | null
    _max: Transaksi_itemMaxAggregateOutputType | null
  }

  export type Transaksi_itemAvgAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    id_produk: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
  }

  export type Transaksi_itemSumAggregateOutputType = {
    id: number | null
    jenis: number | null
    id_transaksi: number | null
    id_produk: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
  }

  export type Transaksi_itemMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jenis: number | null
    id_transaksi: number | null
    id_produk: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
  }

  export type Transaksi_itemMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    jenis: number | null
    id_transaksi: number | null
    id_produk: number | null
    harga_beli: Decimal | null
    harga_jual: Decimal | null
    jumlah: number | null
    diskon: number | null
  }

  export type Transaksi_itemCountAggregateOutputType = {
    id: number
    tanggal: number
    jenis: number
    id_transaksi: number
    id_produk: number
    harga_beli: number
    harga_jual: number
    jumlah: number
    diskon: number
    _all: number
  }


  export type Transaksi_itemAvgAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
  }

  export type Transaksi_itemSumAggregateInputType = {
    id?: true
    jenis?: true
    id_transaksi?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
  }

  export type Transaksi_itemMinAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    id_transaksi?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
  }

  export type Transaksi_itemMaxAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    id_transaksi?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
  }

  export type Transaksi_itemCountAggregateInputType = {
    id?: true
    tanggal?: true
    jenis?: true
    id_transaksi?: true
    id_produk?: true
    harga_beli?: true
    harga_jual?: true
    jumlah?: true
    diskon?: true
    _all?: true
  }

  export type Transaksi_itemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_item to aggregate.
     */
    where?: transaksi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_items to fetch.
     */
    orderBy?: transaksi_itemOrderByWithRelationInput | transaksi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksi_items
    **/
    _count?: true | Transaksi_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Transaksi_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Transaksi_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaksi_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaksi_itemMaxAggregateInputType
  }

  export type GetTransaksi_itemAggregateType<T extends Transaksi_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi_item[P]>
      : GetScalarType<T[P], AggregateTransaksi_item[P]>
  }




  export type transaksi_itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksi_itemWhereInput
    orderBy?: transaksi_itemOrderByWithAggregationInput | transaksi_itemOrderByWithAggregationInput[]
    by: Transaksi_itemScalarFieldEnum[] | Transaksi_itemScalarFieldEnum
    having?: transaksi_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaksi_itemCountAggregateInputType | true
    _avg?: Transaksi_itemAvgAggregateInputType
    _sum?: Transaksi_itemSumAggregateInputType
    _min?: Transaksi_itemMinAggregateInputType
    _max?: Transaksi_itemMaxAggregateInputType
  }

  export type Transaksi_itemGroupByOutputType = {
    id: number
    tanggal: Date | null
    jenis: number
    id_transaksi: number
    id_produk: number
    harga_beli: Decimal
    harga_jual: Decimal
    jumlah: number
    diskon: number
    _count: Transaksi_itemCountAggregateOutputType | null
    _avg: Transaksi_itemAvgAggregateOutputType | null
    _sum: Transaksi_itemSumAggregateOutputType | null
    _min: Transaksi_itemMinAggregateOutputType | null
    _max: Transaksi_itemMaxAggregateOutputType | null
  }

  type GetTransaksi_itemGroupByPayload<T extends transaksi_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaksi_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaksi_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaksi_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Transaksi_itemGroupByOutputType[P]>
        }
      >
    >


  export type transaksi_itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    jenis?: boolean
    id_transaksi?: boolean
    id_produk?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
    diskon?: boolean
  }, ExtArgs["result"]["transaksi_item"]>


  export type transaksi_itemSelectScalar = {
    id?: boolean
    tanggal?: boolean
    jenis?: boolean
    id_transaksi?: boolean
    id_produk?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    jumlah?: boolean
    diskon?: boolean
  }


  export type $transaksi_itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi_item"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date | null
      jenis: number
      id_transaksi: number
      id_produk: number
      harga_beli: Prisma.Decimal
      harga_jual: Prisma.Decimal
      jumlah: number
      diskon: number
    }, ExtArgs["result"]["transaksi_item"]>
    composites: {}
  }

  type transaksi_itemGetPayload<S extends boolean | null | undefined | transaksi_itemDefaultArgs> = $Result.GetResult<Prisma.$transaksi_itemPayload, S>

  type transaksi_itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transaksi_itemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Transaksi_itemCountAggregateInputType | true
    }

  export interface transaksi_itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi_item'], meta: { name: 'transaksi_item' } }
    /**
     * Find zero or one Transaksi_item that matches the filter.
     * @param {transaksi_itemFindUniqueArgs} args - Arguments to find a Transaksi_item
     * @example
     * // Get one Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksi_itemFindUniqueArgs>(args: SelectSubset<T, transaksi_itemFindUniqueArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaksi_item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transaksi_itemFindUniqueOrThrowArgs} args - Arguments to find a Transaksi_item
     * @example
     * // Get one Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksi_itemFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksi_itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaksi_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemFindFirstArgs} args - Arguments to find a Transaksi_item
     * @example
     * // Get one Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksi_itemFindFirstArgs>(args?: SelectSubset<T, transaksi_itemFindFirstArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaksi_item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemFindFirstOrThrowArgs} args - Arguments to find a Transaksi_item
     * @example
     * // Get one Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksi_itemFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksi_itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transaksi_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksi_items
     * const transaksi_items = await prisma.transaksi_item.findMany()
     * 
     * // Get first 10 Transaksi_items
     * const transaksi_items = await prisma.transaksi_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksi_itemWithIdOnly = await prisma.transaksi_item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksi_itemFindManyArgs>(args?: SelectSubset<T, transaksi_itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaksi_item.
     * @param {transaksi_itemCreateArgs} args - Arguments to create a Transaksi_item.
     * @example
     * // Create one Transaksi_item
     * const Transaksi_item = await prisma.transaksi_item.create({
     *   data: {
     *     // ... data to create a Transaksi_item
     *   }
     * })
     * 
     */
    create<T extends transaksi_itemCreateArgs>(args: SelectSubset<T, transaksi_itemCreateArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transaksi_items.
     * @param {transaksi_itemCreateManyArgs} args - Arguments to create many Transaksi_items.
     * @example
     * // Create many Transaksi_items
     * const transaksi_item = await prisma.transaksi_item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksi_itemCreateManyArgs>(args?: SelectSubset<T, transaksi_itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaksi_item.
     * @param {transaksi_itemDeleteArgs} args - Arguments to delete one Transaksi_item.
     * @example
     * // Delete one Transaksi_item
     * const Transaksi_item = await prisma.transaksi_item.delete({
     *   where: {
     *     // ... filter to delete one Transaksi_item
     *   }
     * })
     * 
     */
    delete<T extends transaksi_itemDeleteArgs>(args: SelectSubset<T, transaksi_itemDeleteArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaksi_item.
     * @param {transaksi_itemUpdateArgs} args - Arguments to update one Transaksi_item.
     * @example
     * // Update one Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksi_itemUpdateArgs>(args: SelectSubset<T, transaksi_itemUpdateArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transaksi_items.
     * @param {transaksi_itemDeleteManyArgs} args - Arguments to filter Transaksi_items to delete.
     * @example
     * // Delete a few Transaksi_items
     * const { count } = await prisma.transaksi_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksi_itemDeleteManyArgs>(args?: SelectSubset<T, transaksi_itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksi_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksi_items
     * const transaksi_item = await prisma.transaksi_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksi_itemUpdateManyArgs>(args: SelectSubset<T, transaksi_itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaksi_item.
     * @param {transaksi_itemUpsertArgs} args - Arguments to update or create a Transaksi_item.
     * @example
     * // Update or create a Transaksi_item
     * const transaksi_item = await prisma.transaksi_item.upsert({
     *   create: {
     *     // ... data to create a Transaksi_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi_item we want to update
     *   }
     * })
     */
    upsert<T extends transaksi_itemUpsertArgs>(args: SelectSubset<T, transaksi_itemUpsertArgs<ExtArgs>>): Prisma__transaksi_itemClient<$Result.GetResult<Prisma.$transaksi_itemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transaksi_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemCountArgs} args - Arguments to filter Transaksi_items to count.
     * @example
     * // Count the number of Transaksi_items
     * const count = await prisma.transaksi_item.count({
     *   where: {
     *     // ... the filter for the Transaksi_items we want to count
     *   }
     * })
    **/
    count<T extends transaksi_itemCountArgs>(
      args?: Subset<T, transaksi_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaksi_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaksi_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaksi_itemAggregateArgs>(args: Subset<T, Transaksi_itemAggregateArgs>): Prisma.PrismaPromise<GetTransaksi_itemAggregateType<T>>

    /**
     * Group by Transaksi_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksi_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksi_itemGroupByArgs['orderBy'] }
        : { orderBy?: transaksi_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksi_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksi_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi_item model
   */
  readonly fields: transaksi_itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksi_itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi_item model
   */ 
  interface transaksi_itemFieldRefs {
    readonly id: FieldRef<"transaksi_item", 'Int'>
    readonly tanggal: FieldRef<"transaksi_item", 'DateTime'>
    readonly jenis: FieldRef<"transaksi_item", 'Int'>
    readonly id_transaksi: FieldRef<"transaksi_item", 'Int'>
    readonly id_produk: FieldRef<"transaksi_item", 'Int'>
    readonly harga_beli: FieldRef<"transaksi_item", 'Decimal'>
    readonly harga_jual: FieldRef<"transaksi_item", 'Decimal'>
    readonly jumlah: FieldRef<"transaksi_item", 'Float'>
    readonly diskon: FieldRef<"transaksi_item", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * transaksi_item findUnique
   */
  export type transaksi_itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_item to fetch.
     */
    where: transaksi_itemWhereUniqueInput
  }

  /**
   * transaksi_item findUniqueOrThrow
   */
  export type transaksi_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_item to fetch.
     */
    where: transaksi_itemWhereUniqueInput
  }

  /**
   * transaksi_item findFirst
   */
  export type transaksi_itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_item to fetch.
     */
    where?: transaksi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_items to fetch.
     */
    orderBy?: transaksi_itemOrderByWithRelationInput | transaksi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_items.
     */
    cursor?: transaksi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_items.
     */
    distinct?: Transaksi_itemScalarFieldEnum | Transaksi_itemScalarFieldEnum[]
  }

  /**
   * transaksi_item findFirstOrThrow
   */
  export type transaksi_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_item to fetch.
     */
    where?: transaksi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_items to fetch.
     */
    orderBy?: transaksi_itemOrderByWithRelationInput | transaksi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_items.
     */
    cursor?: transaksi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_items.
     */
    distinct?: Transaksi_itemScalarFieldEnum | Transaksi_itemScalarFieldEnum[]
  }

  /**
   * transaksi_item findMany
   */
  export type transaksi_itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_items to fetch.
     */
    where?: transaksi_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_items to fetch.
     */
    orderBy?: transaksi_itemOrderByWithRelationInput | transaksi_itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksi_items.
     */
    cursor?: transaksi_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_items.
     */
    skip?: number
    distinct?: Transaksi_itemScalarFieldEnum | Transaksi_itemScalarFieldEnum[]
  }

  /**
   * transaksi_item create
   */
  export type transaksi_itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * The data needed to create a transaksi_item.
     */
    data?: XOR<transaksi_itemCreateInput, transaksi_itemUncheckedCreateInput>
  }

  /**
   * transaksi_item createMany
   */
  export type transaksi_itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksi_items.
     */
    data: transaksi_itemCreateManyInput | transaksi_itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi_item update
   */
  export type transaksi_itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * The data needed to update a transaksi_item.
     */
    data: XOR<transaksi_itemUpdateInput, transaksi_itemUncheckedUpdateInput>
    /**
     * Choose, which transaksi_item to update.
     */
    where: transaksi_itemWhereUniqueInput
  }

  /**
   * transaksi_item updateMany
   */
  export type transaksi_itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksi_items.
     */
    data: XOR<transaksi_itemUpdateManyMutationInput, transaksi_itemUncheckedUpdateManyInput>
    /**
     * Filter which transaksi_items to update
     */
    where?: transaksi_itemWhereInput
  }

  /**
   * transaksi_item upsert
   */
  export type transaksi_itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * The filter to search for the transaksi_item to update in case it exists.
     */
    where: transaksi_itemWhereUniqueInput
    /**
     * In case the transaksi_item found by the `where` argument doesn't exist, create a new transaksi_item with this data.
     */
    create: XOR<transaksi_itemCreateInput, transaksi_itemUncheckedCreateInput>
    /**
     * In case the transaksi_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksi_itemUpdateInput, transaksi_itemUncheckedUpdateInput>
  }

  /**
   * transaksi_item delete
   */
  export type transaksi_itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
    /**
     * Filter which transaksi_item to delete.
     */
    where: transaksi_itemWhereUniqueInput
  }

  /**
   * transaksi_item deleteMany
   */
  export type transaksi_itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_items to delete
     */
    where?: transaksi_itemWhereInput
  }

  /**
   * transaksi_item without action
   */
  export type transaksi_itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_item
     */
    select?: transaksi_itemSelect<ExtArgs> | null
  }


  /**
   * Model transaksi_jenis
   */

  export type AggregateTransaksi_jenis = {
    _count: Transaksi_jenisCountAggregateOutputType | null
    _avg: Transaksi_jenisAvgAggregateOutputType | null
    _sum: Transaksi_jenisSumAggregateOutputType | null
    _min: Transaksi_jenisMinAggregateOutputType | null
    _max: Transaksi_jenisMaxAggregateOutputType | null
  }

  export type Transaksi_jenisAvgAggregateOutputType = {
    id: number | null
    tipe: number | null
    fix: number | null
  }

  export type Transaksi_jenisSumAggregateOutputType = {
    id: number | null
    tipe: number | null
    fix: number | null
  }

  export type Transaksi_jenisMinAggregateOutputType = {
    id: number | null
    nama: string | null
    tipe: number | null
    fix: number | null
  }

  export type Transaksi_jenisMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    tipe: number | null
    fix: number | null
  }

  export type Transaksi_jenisCountAggregateOutputType = {
    id: number
    nama: number
    tipe: number
    fix: number
    _all: number
  }


  export type Transaksi_jenisAvgAggregateInputType = {
    id?: true
    tipe?: true
    fix?: true
  }

  export type Transaksi_jenisSumAggregateInputType = {
    id?: true
    tipe?: true
    fix?: true
  }

  export type Transaksi_jenisMinAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    fix?: true
  }

  export type Transaksi_jenisMaxAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    fix?: true
  }

  export type Transaksi_jenisCountAggregateInputType = {
    id?: true
    nama?: true
    tipe?: true
    fix?: true
    _all?: true
  }

  export type Transaksi_jenisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_jenis to aggregate.
     */
    where?: transaksi_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_jenis to fetch.
     */
    orderBy?: transaksi_jenisOrderByWithRelationInput | transaksi_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksi_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksi_jenis
    **/
    _count?: true | Transaksi_jenisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Transaksi_jenisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Transaksi_jenisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaksi_jenisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaksi_jenisMaxAggregateInputType
  }

  export type GetTransaksi_jenisAggregateType<T extends Transaksi_jenisAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi_jenis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi_jenis[P]>
      : GetScalarType<T[P], AggregateTransaksi_jenis[P]>
  }




  export type transaksi_jenisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksi_jenisWhereInput
    orderBy?: transaksi_jenisOrderByWithAggregationInput | transaksi_jenisOrderByWithAggregationInput[]
    by: Transaksi_jenisScalarFieldEnum[] | Transaksi_jenisScalarFieldEnum
    having?: transaksi_jenisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaksi_jenisCountAggregateInputType | true
    _avg?: Transaksi_jenisAvgAggregateInputType
    _sum?: Transaksi_jenisSumAggregateInputType
    _min?: Transaksi_jenisMinAggregateInputType
    _max?: Transaksi_jenisMaxAggregateInputType
  }

  export type Transaksi_jenisGroupByOutputType = {
    id: number
    nama: string
    tipe: number
    fix: number
    _count: Transaksi_jenisCountAggregateOutputType | null
    _avg: Transaksi_jenisAvgAggregateOutputType | null
    _sum: Transaksi_jenisSumAggregateOutputType | null
    _min: Transaksi_jenisMinAggregateOutputType | null
    _max: Transaksi_jenisMaxAggregateOutputType | null
  }

  type GetTransaksi_jenisGroupByPayload<T extends transaksi_jenisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaksi_jenisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaksi_jenisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaksi_jenisGroupByOutputType[P]>
            : GetScalarType<T[P], Transaksi_jenisGroupByOutputType[P]>
        }
      >
    >


  export type transaksi_jenisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    tipe?: boolean
    fix?: boolean
  }, ExtArgs["result"]["transaksi_jenis"]>


  export type transaksi_jenisSelectScalar = {
    id?: boolean
    nama?: boolean
    tipe?: boolean
    fix?: boolean
  }


  export type $transaksi_jenisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi_jenis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      tipe: number
      fix: number
    }, ExtArgs["result"]["transaksi_jenis"]>
    composites: {}
  }

  type transaksi_jenisGetPayload<S extends boolean | null | undefined | transaksi_jenisDefaultArgs> = $Result.GetResult<Prisma.$transaksi_jenisPayload, S>

  type transaksi_jenisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transaksi_jenisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Transaksi_jenisCountAggregateInputType | true
    }

  export interface transaksi_jenisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi_jenis'], meta: { name: 'transaksi_jenis' } }
    /**
     * Find zero or one Transaksi_jenis that matches the filter.
     * @param {transaksi_jenisFindUniqueArgs} args - Arguments to find a Transaksi_jenis
     * @example
     * // Get one Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksi_jenisFindUniqueArgs>(args: SelectSubset<T, transaksi_jenisFindUniqueArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaksi_jenis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transaksi_jenisFindUniqueOrThrowArgs} args - Arguments to find a Transaksi_jenis
     * @example
     * // Get one Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksi_jenisFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksi_jenisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaksi_jenis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisFindFirstArgs} args - Arguments to find a Transaksi_jenis
     * @example
     * // Get one Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksi_jenisFindFirstArgs>(args?: SelectSubset<T, transaksi_jenisFindFirstArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaksi_jenis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisFindFirstOrThrowArgs} args - Arguments to find a Transaksi_jenis
     * @example
     * // Get one Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksi_jenisFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksi_jenisFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transaksi_jenis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findMany()
     * 
     * // Get first 10 Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksi_jenisWithIdOnly = await prisma.transaksi_jenis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksi_jenisFindManyArgs>(args?: SelectSubset<T, transaksi_jenisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaksi_jenis.
     * @param {transaksi_jenisCreateArgs} args - Arguments to create a Transaksi_jenis.
     * @example
     * // Create one Transaksi_jenis
     * const Transaksi_jenis = await prisma.transaksi_jenis.create({
     *   data: {
     *     // ... data to create a Transaksi_jenis
     *   }
     * })
     * 
     */
    create<T extends transaksi_jenisCreateArgs>(args: SelectSubset<T, transaksi_jenisCreateArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transaksi_jenis.
     * @param {transaksi_jenisCreateManyArgs} args - Arguments to create many Transaksi_jenis.
     * @example
     * // Create many Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksi_jenisCreateManyArgs>(args?: SelectSubset<T, transaksi_jenisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaksi_jenis.
     * @param {transaksi_jenisDeleteArgs} args - Arguments to delete one Transaksi_jenis.
     * @example
     * // Delete one Transaksi_jenis
     * const Transaksi_jenis = await prisma.transaksi_jenis.delete({
     *   where: {
     *     // ... filter to delete one Transaksi_jenis
     *   }
     * })
     * 
     */
    delete<T extends transaksi_jenisDeleteArgs>(args: SelectSubset<T, transaksi_jenisDeleteArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaksi_jenis.
     * @param {transaksi_jenisUpdateArgs} args - Arguments to update one Transaksi_jenis.
     * @example
     * // Update one Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksi_jenisUpdateArgs>(args: SelectSubset<T, transaksi_jenisUpdateArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transaksi_jenis.
     * @param {transaksi_jenisDeleteManyArgs} args - Arguments to filter Transaksi_jenis to delete.
     * @example
     * // Delete a few Transaksi_jenis
     * const { count } = await prisma.transaksi_jenis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksi_jenisDeleteManyArgs>(args?: SelectSubset<T, transaksi_jenisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksi_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksi_jenisUpdateManyArgs>(args: SelectSubset<T, transaksi_jenisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaksi_jenis.
     * @param {transaksi_jenisUpsertArgs} args - Arguments to update or create a Transaksi_jenis.
     * @example
     * // Update or create a Transaksi_jenis
     * const transaksi_jenis = await prisma.transaksi_jenis.upsert({
     *   create: {
     *     // ... data to create a Transaksi_jenis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi_jenis we want to update
     *   }
     * })
     */
    upsert<T extends transaksi_jenisUpsertArgs>(args: SelectSubset<T, transaksi_jenisUpsertArgs<ExtArgs>>): Prisma__transaksi_jenisClient<$Result.GetResult<Prisma.$transaksi_jenisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transaksi_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisCountArgs} args - Arguments to filter Transaksi_jenis to count.
     * @example
     * // Count the number of Transaksi_jenis
     * const count = await prisma.transaksi_jenis.count({
     *   where: {
     *     // ... the filter for the Transaksi_jenis we want to count
     *   }
     * })
    **/
    count<T extends transaksi_jenisCountArgs>(
      args?: Subset<T, transaksi_jenisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaksi_jenisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaksi_jenisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaksi_jenisAggregateArgs>(args: Subset<T, Transaksi_jenisAggregateArgs>): Prisma.PrismaPromise<GetTransaksi_jenisAggregateType<T>>

    /**
     * Group by Transaksi_jenis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksi_jenisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksi_jenisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksi_jenisGroupByArgs['orderBy'] }
        : { orderBy?: transaksi_jenisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksi_jenisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksi_jenisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi_jenis model
   */
  readonly fields: transaksi_jenisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi_jenis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksi_jenisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi_jenis model
   */ 
  interface transaksi_jenisFieldRefs {
    readonly id: FieldRef<"transaksi_jenis", 'Int'>
    readonly nama: FieldRef<"transaksi_jenis", 'String'>
    readonly tipe: FieldRef<"transaksi_jenis", 'Int'>
    readonly fix: FieldRef<"transaksi_jenis", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * transaksi_jenis findUnique
   */
  export type transaksi_jenisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_jenis to fetch.
     */
    where: transaksi_jenisWhereUniqueInput
  }

  /**
   * transaksi_jenis findUniqueOrThrow
   */
  export type transaksi_jenisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_jenis to fetch.
     */
    where: transaksi_jenisWhereUniqueInput
  }

  /**
   * transaksi_jenis findFirst
   */
  export type transaksi_jenisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_jenis to fetch.
     */
    where?: transaksi_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_jenis to fetch.
     */
    orderBy?: transaksi_jenisOrderByWithRelationInput | transaksi_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_jenis.
     */
    cursor?: transaksi_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_jenis.
     */
    distinct?: Transaksi_jenisScalarFieldEnum | Transaksi_jenisScalarFieldEnum[]
  }

  /**
   * transaksi_jenis findFirstOrThrow
   */
  export type transaksi_jenisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_jenis to fetch.
     */
    where?: transaksi_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_jenis to fetch.
     */
    orderBy?: transaksi_jenisOrderByWithRelationInput | transaksi_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksi_jenis.
     */
    cursor?: transaksi_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_jenis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksi_jenis.
     */
    distinct?: Transaksi_jenisScalarFieldEnum | Transaksi_jenisScalarFieldEnum[]
  }

  /**
   * transaksi_jenis findMany
   */
  export type transaksi_jenisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter, which transaksi_jenis to fetch.
     */
    where?: transaksi_jenisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksi_jenis to fetch.
     */
    orderBy?: transaksi_jenisOrderByWithRelationInput | transaksi_jenisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksi_jenis.
     */
    cursor?: transaksi_jenisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksi_jenis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksi_jenis.
     */
    skip?: number
    distinct?: Transaksi_jenisScalarFieldEnum | Transaksi_jenisScalarFieldEnum[]
  }

  /**
   * transaksi_jenis create
   */
  export type transaksi_jenisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * The data needed to create a transaksi_jenis.
     */
    data: XOR<transaksi_jenisCreateInput, transaksi_jenisUncheckedCreateInput>
  }

  /**
   * transaksi_jenis createMany
   */
  export type transaksi_jenisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksi_jenis.
     */
    data: transaksi_jenisCreateManyInput | transaksi_jenisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi_jenis update
   */
  export type transaksi_jenisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * The data needed to update a transaksi_jenis.
     */
    data: XOR<transaksi_jenisUpdateInput, transaksi_jenisUncheckedUpdateInput>
    /**
     * Choose, which transaksi_jenis to update.
     */
    where: transaksi_jenisWhereUniqueInput
  }

  /**
   * transaksi_jenis updateMany
   */
  export type transaksi_jenisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksi_jenis.
     */
    data: XOR<transaksi_jenisUpdateManyMutationInput, transaksi_jenisUncheckedUpdateManyInput>
    /**
     * Filter which transaksi_jenis to update
     */
    where?: transaksi_jenisWhereInput
  }

  /**
   * transaksi_jenis upsert
   */
  export type transaksi_jenisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * The filter to search for the transaksi_jenis to update in case it exists.
     */
    where: transaksi_jenisWhereUniqueInput
    /**
     * In case the transaksi_jenis found by the `where` argument doesn't exist, create a new transaksi_jenis with this data.
     */
    create: XOR<transaksi_jenisCreateInput, transaksi_jenisUncheckedCreateInput>
    /**
     * In case the transaksi_jenis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksi_jenisUpdateInput, transaksi_jenisUncheckedUpdateInput>
  }

  /**
   * transaksi_jenis delete
   */
  export type transaksi_jenisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
    /**
     * Filter which transaksi_jenis to delete.
     */
    where: transaksi_jenisWhereUniqueInput
  }

  /**
   * transaksi_jenis deleteMany
   */
  export type transaksi_jenisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi_jenis to delete
     */
    where?: transaksi_jenisWhereInput
  }

  /**
   * transaksi_jenis without action
   */
  export type transaksi_jenisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi_jenis
     */
    select?: transaksi_jenisSelect<ExtArgs> | null
  }


  /**
   * Model tujuan
   */

  export type AggregateTujuan = {
    _count: TujuanCountAggregateOutputType | null
    _avg: TujuanAvgAggregateOutputType | null
    _sum: TujuanSumAggregateOutputType | null
    _min: TujuanMinAggregateOutputType | null
    _max: TujuanMaxAggregateOutputType | null
  }

  export type TujuanAvgAggregateOutputType = {
    id: number | null
  }

  export type TujuanSumAggregateOutputType = {
    id: number | null
  }

  export type TujuanMinAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type TujuanMaxAggregateOutputType = {
    id: number | null
    nama: string | null
  }

  export type TujuanCountAggregateOutputType = {
    id: number
    nama: number
    _all: number
  }


  export type TujuanAvgAggregateInputType = {
    id?: true
  }

  export type TujuanSumAggregateInputType = {
    id?: true
  }

  export type TujuanMinAggregateInputType = {
    id?: true
    nama?: true
  }

  export type TujuanMaxAggregateInputType = {
    id?: true
    nama?: true
  }

  export type TujuanCountAggregateInputType = {
    id?: true
    nama?: true
    _all?: true
  }

  export type TujuanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tujuan to aggregate.
     */
    where?: tujuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tujuans to fetch.
     */
    orderBy?: tujuanOrderByWithRelationInput | tujuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tujuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tujuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tujuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tujuans
    **/
    _count?: true | TujuanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TujuanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TujuanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TujuanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TujuanMaxAggregateInputType
  }

  export type GetTujuanAggregateType<T extends TujuanAggregateArgs> = {
        [P in keyof T & keyof AggregateTujuan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTujuan[P]>
      : GetScalarType<T[P], AggregateTujuan[P]>
  }




  export type tujuanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tujuanWhereInput
    orderBy?: tujuanOrderByWithAggregationInput | tujuanOrderByWithAggregationInput[]
    by: TujuanScalarFieldEnum[] | TujuanScalarFieldEnum
    having?: tujuanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TujuanCountAggregateInputType | true
    _avg?: TujuanAvgAggregateInputType
    _sum?: TujuanSumAggregateInputType
    _min?: TujuanMinAggregateInputType
    _max?: TujuanMaxAggregateInputType
  }

  export type TujuanGroupByOutputType = {
    id: number
    nama: string
    _count: TujuanCountAggregateOutputType | null
    _avg: TujuanAvgAggregateOutputType | null
    _sum: TujuanSumAggregateOutputType | null
    _min: TujuanMinAggregateOutputType | null
    _max: TujuanMaxAggregateOutputType | null
  }

  type GetTujuanGroupByPayload<T extends tujuanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TujuanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TujuanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TujuanGroupByOutputType[P]>
            : GetScalarType<T[P], TujuanGroupByOutputType[P]>
        }
      >
    >


  export type tujuanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
  }, ExtArgs["result"]["tujuan"]>


  export type tujuanSelectScalar = {
    id?: boolean
    nama?: boolean
  }


  export type $tujuanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tujuan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
    }, ExtArgs["result"]["tujuan"]>
    composites: {}
  }

  type tujuanGetPayload<S extends boolean | null | undefined | tujuanDefaultArgs> = $Result.GetResult<Prisma.$tujuanPayload, S>

  type tujuanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tujuanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TujuanCountAggregateInputType | true
    }

  export interface tujuanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tujuan'], meta: { name: 'tujuan' } }
    /**
     * Find zero or one Tujuan that matches the filter.
     * @param {tujuanFindUniqueArgs} args - Arguments to find a Tujuan
     * @example
     * // Get one Tujuan
     * const tujuan = await prisma.tujuan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tujuanFindUniqueArgs>(args: SelectSubset<T, tujuanFindUniqueArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tujuan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tujuanFindUniqueOrThrowArgs} args - Arguments to find a Tujuan
     * @example
     * // Get one Tujuan
     * const tujuan = await prisma.tujuan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tujuanFindUniqueOrThrowArgs>(args: SelectSubset<T, tujuanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tujuan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanFindFirstArgs} args - Arguments to find a Tujuan
     * @example
     * // Get one Tujuan
     * const tujuan = await prisma.tujuan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tujuanFindFirstArgs>(args?: SelectSubset<T, tujuanFindFirstArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tujuan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanFindFirstOrThrowArgs} args - Arguments to find a Tujuan
     * @example
     * // Get one Tujuan
     * const tujuan = await prisma.tujuan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tujuanFindFirstOrThrowArgs>(args?: SelectSubset<T, tujuanFindFirstOrThrowArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tujuans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tujuans
     * const tujuans = await prisma.tujuan.findMany()
     * 
     * // Get first 10 Tujuans
     * const tujuans = await prisma.tujuan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tujuanWithIdOnly = await prisma.tujuan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tujuanFindManyArgs>(args?: SelectSubset<T, tujuanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tujuan.
     * @param {tujuanCreateArgs} args - Arguments to create a Tujuan.
     * @example
     * // Create one Tujuan
     * const Tujuan = await prisma.tujuan.create({
     *   data: {
     *     // ... data to create a Tujuan
     *   }
     * })
     * 
     */
    create<T extends tujuanCreateArgs>(args: SelectSubset<T, tujuanCreateArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tujuans.
     * @param {tujuanCreateManyArgs} args - Arguments to create many Tujuans.
     * @example
     * // Create many Tujuans
     * const tujuan = await prisma.tujuan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tujuanCreateManyArgs>(args?: SelectSubset<T, tujuanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tujuan.
     * @param {tujuanDeleteArgs} args - Arguments to delete one Tujuan.
     * @example
     * // Delete one Tujuan
     * const Tujuan = await prisma.tujuan.delete({
     *   where: {
     *     // ... filter to delete one Tujuan
     *   }
     * })
     * 
     */
    delete<T extends tujuanDeleteArgs>(args: SelectSubset<T, tujuanDeleteArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tujuan.
     * @param {tujuanUpdateArgs} args - Arguments to update one Tujuan.
     * @example
     * // Update one Tujuan
     * const tujuan = await prisma.tujuan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tujuanUpdateArgs>(args: SelectSubset<T, tujuanUpdateArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tujuans.
     * @param {tujuanDeleteManyArgs} args - Arguments to filter Tujuans to delete.
     * @example
     * // Delete a few Tujuans
     * const { count } = await prisma.tujuan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tujuanDeleteManyArgs>(args?: SelectSubset<T, tujuanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tujuans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tujuans
     * const tujuan = await prisma.tujuan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tujuanUpdateManyArgs>(args: SelectSubset<T, tujuanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tujuan.
     * @param {tujuanUpsertArgs} args - Arguments to update or create a Tujuan.
     * @example
     * // Update or create a Tujuan
     * const tujuan = await prisma.tujuan.upsert({
     *   create: {
     *     // ... data to create a Tujuan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tujuan we want to update
     *   }
     * })
     */
    upsert<T extends tujuanUpsertArgs>(args: SelectSubset<T, tujuanUpsertArgs<ExtArgs>>): Prisma__tujuanClient<$Result.GetResult<Prisma.$tujuanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tujuans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanCountArgs} args - Arguments to filter Tujuans to count.
     * @example
     * // Count the number of Tujuans
     * const count = await prisma.tujuan.count({
     *   where: {
     *     // ... the filter for the Tujuans we want to count
     *   }
     * })
    **/
    count<T extends tujuanCountArgs>(
      args?: Subset<T, tujuanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TujuanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tujuan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TujuanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TujuanAggregateArgs>(args: Subset<T, TujuanAggregateArgs>): Prisma.PrismaPromise<GetTujuanAggregateType<T>>

    /**
     * Group by Tujuan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tujuanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tujuanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tujuanGroupByArgs['orderBy'] }
        : { orderBy?: tujuanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tujuanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTujuanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tujuan model
   */
  readonly fields: tujuanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tujuan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tujuanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tujuan model
   */ 
  interface tujuanFieldRefs {
    readonly id: FieldRef<"tujuan", 'Int'>
    readonly nama: FieldRef<"tujuan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tujuan findUnique
   */
  export type tujuanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter, which tujuan to fetch.
     */
    where: tujuanWhereUniqueInput
  }

  /**
   * tujuan findUniqueOrThrow
   */
  export type tujuanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter, which tujuan to fetch.
     */
    where: tujuanWhereUniqueInput
  }

  /**
   * tujuan findFirst
   */
  export type tujuanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter, which tujuan to fetch.
     */
    where?: tujuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tujuans to fetch.
     */
    orderBy?: tujuanOrderByWithRelationInput | tujuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tujuans.
     */
    cursor?: tujuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tujuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tujuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tujuans.
     */
    distinct?: TujuanScalarFieldEnum | TujuanScalarFieldEnum[]
  }

  /**
   * tujuan findFirstOrThrow
   */
  export type tujuanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter, which tujuan to fetch.
     */
    where?: tujuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tujuans to fetch.
     */
    orderBy?: tujuanOrderByWithRelationInput | tujuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tujuans.
     */
    cursor?: tujuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tujuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tujuans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tujuans.
     */
    distinct?: TujuanScalarFieldEnum | TujuanScalarFieldEnum[]
  }

  /**
   * tujuan findMany
   */
  export type tujuanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter, which tujuans to fetch.
     */
    where?: tujuanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tujuans to fetch.
     */
    orderBy?: tujuanOrderByWithRelationInput | tujuanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tujuans.
     */
    cursor?: tujuanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tujuans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tujuans.
     */
    skip?: number
    distinct?: TujuanScalarFieldEnum | TujuanScalarFieldEnum[]
  }

  /**
   * tujuan create
   */
  export type tujuanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * The data needed to create a tujuan.
     */
    data: XOR<tujuanCreateInput, tujuanUncheckedCreateInput>
  }

  /**
   * tujuan createMany
   */
  export type tujuanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tujuans.
     */
    data: tujuanCreateManyInput | tujuanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tujuan update
   */
  export type tujuanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * The data needed to update a tujuan.
     */
    data: XOR<tujuanUpdateInput, tujuanUncheckedUpdateInput>
    /**
     * Choose, which tujuan to update.
     */
    where: tujuanWhereUniqueInput
  }

  /**
   * tujuan updateMany
   */
  export type tujuanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tujuans.
     */
    data: XOR<tujuanUpdateManyMutationInput, tujuanUncheckedUpdateManyInput>
    /**
     * Filter which tujuans to update
     */
    where?: tujuanWhereInput
  }

  /**
   * tujuan upsert
   */
  export type tujuanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * The filter to search for the tujuan to update in case it exists.
     */
    where: tujuanWhereUniqueInput
    /**
     * In case the tujuan found by the `where` argument doesn't exist, create a new tujuan with this data.
     */
    create: XOR<tujuanCreateInput, tujuanUncheckedCreateInput>
    /**
     * In case the tujuan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tujuanUpdateInput, tujuanUncheckedUpdateInput>
  }

  /**
   * tujuan delete
   */
  export type tujuanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
    /**
     * Filter which tujuan to delete.
     */
    where: tujuanWhereUniqueInput
  }

  /**
   * tujuan deleteMany
   */
  export type tujuanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tujuans to delete
     */
    where?: tujuanWhereInput
  }

  /**
   * tujuan without action
   */
  export type tujuanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tujuan
     */
    select?: tujuanSelect<ExtArgs> | null
  }


  /**
   * Model tutup_kasir
   */

  export type AggregateTutup_kasir = {
    _count: Tutup_kasirCountAggregateOutputType | null
    _avg: Tutup_kasirAvgAggregateOutputType | null
    _sum: Tutup_kasirSumAggregateOutputType | null
    _min: Tutup_kasirMinAggregateOutputType | null
    _max: Tutup_kasirMaxAggregateOutputType | null
  }

  export type Tutup_kasirAvgAggregateOutputType = {
    id: number | null
    shift: number | null
    kasir: number | null
    tunai: Decimal | null
    bon: Decimal | null
    struk: Decimal | null
  }

  export type Tutup_kasirSumAggregateOutputType = {
    id: number | null
    shift: number | null
    kasir: number | null
    tunai: Decimal | null
    bon: Decimal | null
    struk: Decimal | null
  }

  export type Tutup_kasirMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    shift: number | null
    kasir: number | null
    tunai: Decimal | null
    bon: Decimal | null
    struk: Decimal | null
  }

  export type Tutup_kasirMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    shift: number | null
    kasir: number | null
    tunai: Decimal | null
    bon: Decimal | null
    struk: Decimal | null
  }

  export type Tutup_kasirCountAggregateOutputType = {
    id: number
    tanggal: number
    shift: number
    kasir: number
    tunai: number
    bon: number
    struk: number
    _all: number
  }


  export type Tutup_kasirAvgAggregateInputType = {
    id?: true
    shift?: true
    kasir?: true
    tunai?: true
    bon?: true
    struk?: true
  }

  export type Tutup_kasirSumAggregateInputType = {
    id?: true
    shift?: true
    kasir?: true
    tunai?: true
    bon?: true
    struk?: true
  }

  export type Tutup_kasirMinAggregateInputType = {
    id?: true
    tanggal?: true
    shift?: true
    kasir?: true
    tunai?: true
    bon?: true
    struk?: true
  }

  export type Tutup_kasirMaxAggregateInputType = {
    id?: true
    tanggal?: true
    shift?: true
    kasir?: true
    tunai?: true
    bon?: true
    struk?: true
  }

  export type Tutup_kasirCountAggregateInputType = {
    id?: true
    tanggal?: true
    shift?: true
    kasir?: true
    tunai?: true
    bon?: true
    struk?: true
    _all?: true
  }

  export type Tutup_kasirAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutup_kasir to aggregate.
     */
    where?: tutup_kasirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutup_kasirs to fetch.
     */
    orderBy?: tutup_kasirOrderByWithRelationInput | tutup_kasirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tutup_kasirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutup_kasirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutup_kasirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tutup_kasirs
    **/
    _count?: true | Tutup_kasirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tutup_kasirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tutup_kasirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tutup_kasirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tutup_kasirMaxAggregateInputType
  }

  export type GetTutup_kasirAggregateType<T extends Tutup_kasirAggregateArgs> = {
        [P in keyof T & keyof AggregateTutup_kasir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutup_kasir[P]>
      : GetScalarType<T[P], AggregateTutup_kasir[P]>
  }




  export type tutup_kasirGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tutup_kasirWhereInput
    orderBy?: tutup_kasirOrderByWithAggregationInput | tutup_kasirOrderByWithAggregationInput[]
    by: Tutup_kasirScalarFieldEnum[] | Tutup_kasirScalarFieldEnum
    having?: tutup_kasirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tutup_kasirCountAggregateInputType | true
    _avg?: Tutup_kasirAvgAggregateInputType
    _sum?: Tutup_kasirSumAggregateInputType
    _min?: Tutup_kasirMinAggregateInputType
    _max?: Tutup_kasirMaxAggregateInputType
  }

  export type Tutup_kasirGroupByOutputType = {
    id: number
    tanggal: Date
    shift: number
    kasir: number
    tunai: Decimal
    bon: Decimal
    struk: Decimal
    _count: Tutup_kasirCountAggregateOutputType | null
    _avg: Tutup_kasirAvgAggregateOutputType | null
    _sum: Tutup_kasirSumAggregateOutputType | null
    _min: Tutup_kasirMinAggregateOutputType | null
    _max: Tutup_kasirMaxAggregateOutputType | null
  }

  type GetTutup_kasirGroupByPayload<T extends tutup_kasirGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tutup_kasirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tutup_kasirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tutup_kasirGroupByOutputType[P]>
            : GetScalarType<T[P], Tutup_kasirGroupByOutputType[P]>
        }
      >
    >


  export type tutup_kasirSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    shift?: boolean
    kasir?: boolean
    tunai?: boolean
    bon?: boolean
    struk?: boolean
  }, ExtArgs["result"]["tutup_kasir"]>


  export type tutup_kasirSelectScalar = {
    id?: boolean
    tanggal?: boolean
    shift?: boolean
    kasir?: boolean
    tunai?: boolean
    bon?: boolean
    struk?: boolean
  }


  export type $tutup_kasirPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tutup_kasir"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      shift: number
      kasir: number
      tunai: Prisma.Decimal
      bon: Prisma.Decimal
      struk: Prisma.Decimal
    }, ExtArgs["result"]["tutup_kasir"]>
    composites: {}
  }

  type tutup_kasirGetPayload<S extends boolean | null | undefined | tutup_kasirDefaultArgs> = $Result.GetResult<Prisma.$tutup_kasirPayload, S>

  type tutup_kasirCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tutup_kasirFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tutup_kasirCountAggregateInputType | true
    }

  export interface tutup_kasirDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tutup_kasir'], meta: { name: 'tutup_kasir' } }
    /**
     * Find zero or one Tutup_kasir that matches the filter.
     * @param {tutup_kasirFindUniqueArgs} args - Arguments to find a Tutup_kasir
     * @example
     * // Get one Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tutup_kasirFindUniqueArgs>(args: SelectSubset<T, tutup_kasirFindUniqueArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tutup_kasir that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tutup_kasirFindUniqueOrThrowArgs} args - Arguments to find a Tutup_kasir
     * @example
     * // Get one Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tutup_kasirFindUniqueOrThrowArgs>(args: SelectSubset<T, tutup_kasirFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tutup_kasir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirFindFirstArgs} args - Arguments to find a Tutup_kasir
     * @example
     * // Get one Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tutup_kasirFindFirstArgs>(args?: SelectSubset<T, tutup_kasirFindFirstArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tutup_kasir that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirFindFirstOrThrowArgs} args - Arguments to find a Tutup_kasir
     * @example
     * // Get one Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tutup_kasirFindFirstOrThrowArgs>(args?: SelectSubset<T, tutup_kasirFindFirstOrThrowArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tutup_kasirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutup_kasirs
     * const tutup_kasirs = await prisma.tutup_kasir.findMany()
     * 
     * // Get first 10 Tutup_kasirs
     * const tutup_kasirs = await prisma.tutup_kasir.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutup_kasirWithIdOnly = await prisma.tutup_kasir.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tutup_kasirFindManyArgs>(args?: SelectSubset<T, tutup_kasirFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tutup_kasir.
     * @param {tutup_kasirCreateArgs} args - Arguments to create a Tutup_kasir.
     * @example
     * // Create one Tutup_kasir
     * const Tutup_kasir = await prisma.tutup_kasir.create({
     *   data: {
     *     // ... data to create a Tutup_kasir
     *   }
     * })
     * 
     */
    create<T extends tutup_kasirCreateArgs>(args: SelectSubset<T, tutup_kasirCreateArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tutup_kasirs.
     * @param {tutup_kasirCreateManyArgs} args - Arguments to create many Tutup_kasirs.
     * @example
     * // Create many Tutup_kasirs
     * const tutup_kasir = await prisma.tutup_kasir.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tutup_kasirCreateManyArgs>(args?: SelectSubset<T, tutup_kasirCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tutup_kasir.
     * @param {tutup_kasirDeleteArgs} args - Arguments to delete one Tutup_kasir.
     * @example
     * // Delete one Tutup_kasir
     * const Tutup_kasir = await prisma.tutup_kasir.delete({
     *   where: {
     *     // ... filter to delete one Tutup_kasir
     *   }
     * })
     * 
     */
    delete<T extends tutup_kasirDeleteArgs>(args: SelectSubset<T, tutup_kasirDeleteArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tutup_kasir.
     * @param {tutup_kasirUpdateArgs} args - Arguments to update one Tutup_kasir.
     * @example
     * // Update one Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tutup_kasirUpdateArgs>(args: SelectSubset<T, tutup_kasirUpdateArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tutup_kasirs.
     * @param {tutup_kasirDeleteManyArgs} args - Arguments to filter Tutup_kasirs to delete.
     * @example
     * // Delete a few Tutup_kasirs
     * const { count } = await prisma.tutup_kasir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tutup_kasirDeleteManyArgs>(args?: SelectSubset<T, tutup_kasirDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutup_kasirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutup_kasirs
     * const tutup_kasir = await prisma.tutup_kasir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tutup_kasirUpdateManyArgs>(args: SelectSubset<T, tutup_kasirUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tutup_kasir.
     * @param {tutup_kasirUpsertArgs} args - Arguments to update or create a Tutup_kasir.
     * @example
     * // Update or create a Tutup_kasir
     * const tutup_kasir = await prisma.tutup_kasir.upsert({
     *   create: {
     *     // ... data to create a Tutup_kasir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutup_kasir we want to update
     *   }
     * })
     */
    upsert<T extends tutup_kasirUpsertArgs>(args: SelectSubset<T, tutup_kasirUpsertArgs<ExtArgs>>): Prisma__tutup_kasirClient<$Result.GetResult<Prisma.$tutup_kasirPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tutup_kasirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirCountArgs} args - Arguments to filter Tutup_kasirs to count.
     * @example
     * // Count the number of Tutup_kasirs
     * const count = await prisma.tutup_kasir.count({
     *   where: {
     *     // ... the filter for the Tutup_kasirs we want to count
     *   }
     * })
    **/
    count<T extends tutup_kasirCountArgs>(
      args?: Subset<T, tutup_kasirCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tutup_kasirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutup_kasir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tutup_kasirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tutup_kasirAggregateArgs>(args: Subset<T, Tutup_kasirAggregateArgs>): Prisma.PrismaPromise<GetTutup_kasirAggregateType<T>>

    /**
     * Group by Tutup_kasir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tutup_kasirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tutup_kasirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tutup_kasirGroupByArgs['orderBy'] }
        : { orderBy?: tutup_kasirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tutup_kasirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutup_kasirGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tutup_kasir model
   */
  readonly fields: tutup_kasirFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tutup_kasir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tutup_kasirClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tutup_kasir model
   */ 
  interface tutup_kasirFieldRefs {
    readonly id: FieldRef<"tutup_kasir", 'Int'>
    readonly tanggal: FieldRef<"tutup_kasir", 'DateTime'>
    readonly shift: FieldRef<"tutup_kasir", 'Int'>
    readonly kasir: FieldRef<"tutup_kasir", 'Int'>
    readonly tunai: FieldRef<"tutup_kasir", 'Decimal'>
    readonly bon: FieldRef<"tutup_kasir", 'Decimal'>
    readonly struk: FieldRef<"tutup_kasir", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * tutup_kasir findUnique
   */
  export type tutup_kasirFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter, which tutup_kasir to fetch.
     */
    where: tutup_kasirWhereUniqueInput
  }

  /**
   * tutup_kasir findUniqueOrThrow
   */
  export type tutup_kasirFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter, which tutup_kasir to fetch.
     */
    where: tutup_kasirWhereUniqueInput
  }

  /**
   * tutup_kasir findFirst
   */
  export type tutup_kasirFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter, which tutup_kasir to fetch.
     */
    where?: tutup_kasirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutup_kasirs to fetch.
     */
    orderBy?: tutup_kasirOrderByWithRelationInput | tutup_kasirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutup_kasirs.
     */
    cursor?: tutup_kasirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutup_kasirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutup_kasirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutup_kasirs.
     */
    distinct?: Tutup_kasirScalarFieldEnum | Tutup_kasirScalarFieldEnum[]
  }

  /**
   * tutup_kasir findFirstOrThrow
   */
  export type tutup_kasirFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter, which tutup_kasir to fetch.
     */
    where?: tutup_kasirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutup_kasirs to fetch.
     */
    orderBy?: tutup_kasirOrderByWithRelationInput | tutup_kasirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tutup_kasirs.
     */
    cursor?: tutup_kasirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutup_kasirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutup_kasirs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tutup_kasirs.
     */
    distinct?: Tutup_kasirScalarFieldEnum | Tutup_kasirScalarFieldEnum[]
  }

  /**
   * tutup_kasir findMany
   */
  export type tutup_kasirFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter, which tutup_kasirs to fetch.
     */
    where?: tutup_kasirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tutup_kasirs to fetch.
     */
    orderBy?: tutup_kasirOrderByWithRelationInput | tutup_kasirOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tutup_kasirs.
     */
    cursor?: tutup_kasirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tutup_kasirs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tutup_kasirs.
     */
    skip?: number
    distinct?: Tutup_kasirScalarFieldEnum | Tutup_kasirScalarFieldEnum[]
  }

  /**
   * tutup_kasir create
   */
  export type tutup_kasirCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * The data needed to create a tutup_kasir.
     */
    data: XOR<tutup_kasirCreateInput, tutup_kasirUncheckedCreateInput>
  }

  /**
   * tutup_kasir createMany
   */
  export type tutup_kasirCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tutup_kasirs.
     */
    data: tutup_kasirCreateManyInput | tutup_kasirCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tutup_kasir update
   */
  export type tutup_kasirUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * The data needed to update a tutup_kasir.
     */
    data: XOR<tutup_kasirUpdateInput, tutup_kasirUncheckedUpdateInput>
    /**
     * Choose, which tutup_kasir to update.
     */
    where: tutup_kasirWhereUniqueInput
  }

  /**
   * tutup_kasir updateMany
   */
  export type tutup_kasirUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tutup_kasirs.
     */
    data: XOR<tutup_kasirUpdateManyMutationInput, tutup_kasirUncheckedUpdateManyInput>
    /**
     * Filter which tutup_kasirs to update
     */
    where?: tutup_kasirWhereInput
  }

  /**
   * tutup_kasir upsert
   */
  export type tutup_kasirUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * The filter to search for the tutup_kasir to update in case it exists.
     */
    where: tutup_kasirWhereUniqueInput
    /**
     * In case the tutup_kasir found by the `where` argument doesn't exist, create a new tutup_kasir with this data.
     */
    create: XOR<tutup_kasirCreateInput, tutup_kasirUncheckedCreateInput>
    /**
     * In case the tutup_kasir was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tutup_kasirUpdateInput, tutup_kasirUncheckedUpdateInput>
  }

  /**
   * tutup_kasir delete
   */
  export type tutup_kasirDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
    /**
     * Filter which tutup_kasir to delete.
     */
    where: tutup_kasirWhereUniqueInput
  }

  /**
   * tutup_kasir deleteMany
   */
  export type tutup_kasirDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tutup_kasirs to delete
     */
    where?: tutup_kasirWhereInput
  }

  /**
   * tutup_kasir without action
   */
  export type tutup_kasirDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tutup_kasir
     */
    select?: tutup_kasirSelect<ExtArgs> | null
  }


  /**
   * Model utang_sp
   */

  export type AggregateUtang_sp = {
    _count: Utang_spCountAggregateOutputType | null
    _avg: Utang_spAvgAggregateOutputType | null
    _sum: Utang_spSumAggregateOutputType | null
    _min: Utang_spMinAggregateOutputType | null
    _max: Utang_spMaxAggregateOutputType | null
  }

  export type Utang_spAvgAggregateOutputType = {
    id: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Utang_spSumAggregateOutputType = {
    id: number | null
    debet: Decimal | null
    kredit: Decimal | null
  }

  export type Utang_spMinAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Utang_spMaxAggregateOutputType = {
    id: number | null
    tanggal: Date | null
    debet: Decimal | null
    kredit: Decimal | null
    keterangan: string | null
  }

  export type Utang_spCountAggregateOutputType = {
    id: number
    tanggal: number
    debet: number
    kredit: number
    keterangan: number
    _all: number
  }


  export type Utang_spAvgAggregateInputType = {
    id?: true
    debet?: true
    kredit?: true
  }

  export type Utang_spSumAggregateInputType = {
    id?: true
    debet?: true
    kredit?: true
  }

  export type Utang_spMinAggregateInputType = {
    id?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Utang_spMaxAggregateInputType = {
    id?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
  }

  export type Utang_spCountAggregateInputType = {
    id?: true
    tanggal?: true
    debet?: true
    kredit?: true
    keterangan?: true
    _all?: true
  }

  export type Utang_spAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utang_sp to aggregate.
     */
    where?: utang_spWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utang_sps to fetch.
     */
    orderBy?: utang_spOrderByWithRelationInput | utang_spOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: utang_spWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utang_sps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utang_sps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned utang_sps
    **/
    _count?: true | Utang_spCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Utang_spAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Utang_spSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Utang_spMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Utang_spMaxAggregateInputType
  }

  export type GetUtang_spAggregateType<T extends Utang_spAggregateArgs> = {
        [P in keyof T & keyof AggregateUtang_sp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtang_sp[P]>
      : GetScalarType<T[P], AggregateUtang_sp[P]>
  }




  export type utang_spGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: utang_spWhereInput
    orderBy?: utang_spOrderByWithAggregationInput | utang_spOrderByWithAggregationInput[]
    by: Utang_spScalarFieldEnum[] | Utang_spScalarFieldEnum
    having?: utang_spScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Utang_spCountAggregateInputType | true
    _avg?: Utang_spAvgAggregateInputType
    _sum?: Utang_spSumAggregateInputType
    _min?: Utang_spMinAggregateInputType
    _max?: Utang_spMaxAggregateInputType
  }

  export type Utang_spGroupByOutputType = {
    id: number
    tanggal: Date
    debet: Decimal
    kredit: Decimal
    keterangan: string
    _count: Utang_spCountAggregateOutputType | null
    _avg: Utang_spAvgAggregateOutputType | null
    _sum: Utang_spSumAggregateOutputType | null
    _min: Utang_spMinAggregateOutputType | null
    _max: Utang_spMaxAggregateOutputType | null
  }

  type GetUtang_spGroupByPayload<T extends utang_spGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Utang_spGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Utang_spGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Utang_spGroupByOutputType[P]>
            : GetScalarType<T[P], Utang_spGroupByOutputType[P]>
        }
      >
    >


  export type utang_spSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }, ExtArgs["result"]["utang_sp"]>


  export type utang_spSelectScalar = {
    id?: boolean
    tanggal?: boolean
    debet?: boolean
    kredit?: boolean
    keterangan?: boolean
  }


  export type $utang_spPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "utang_sp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tanggal: Date
      debet: Prisma.Decimal
      kredit: Prisma.Decimal
      keterangan: string
    }, ExtArgs["result"]["utang_sp"]>
    composites: {}
  }

  type utang_spGetPayload<S extends boolean | null | undefined | utang_spDefaultArgs> = $Result.GetResult<Prisma.$utang_spPayload, S>

  type utang_spCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<utang_spFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Utang_spCountAggregateInputType | true
    }

  export interface utang_spDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['utang_sp'], meta: { name: 'utang_sp' } }
    /**
     * Find zero or one Utang_sp that matches the filter.
     * @param {utang_spFindUniqueArgs} args - Arguments to find a Utang_sp
     * @example
     * // Get one Utang_sp
     * const utang_sp = await prisma.utang_sp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends utang_spFindUniqueArgs>(args: SelectSubset<T, utang_spFindUniqueArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Utang_sp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {utang_spFindUniqueOrThrowArgs} args - Arguments to find a Utang_sp
     * @example
     * // Get one Utang_sp
     * const utang_sp = await prisma.utang_sp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends utang_spFindUniqueOrThrowArgs>(args: SelectSubset<T, utang_spFindUniqueOrThrowArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Utang_sp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spFindFirstArgs} args - Arguments to find a Utang_sp
     * @example
     * // Get one Utang_sp
     * const utang_sp = await prisma.utang_sp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends utang_spFindFirstArgs>(args?: SelectSubset<T, utang_spFindFirstArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Utang_sp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spFindFirstOrThrowArgs} args - Arguments to find a Utang_sp
     * @example
     * // Get one Utang_sp
     * const utang_sp = await prisma.utang_sp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends utang_spFindFirstOrThrowArgs>(args?: SelectSubset<T, utang_spFindFirstOrThrowArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Utang_sps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utang_sps
     * const utang_sps = await prisma.utang_sp.findMany()
     * 
     * // Get first 10 Utang_sps
     * const utang_sps = await prisma.utang_sp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utang_spWithIdOnly = await prisma.utang_sp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends utang_spFindManyArgs>(args?: SelectSubset<T, utang_spFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Utang_sp.
     * @param {utang_spCreateArgs} args - Arguments to create a Utang_sp.
     * @example
     * // Create one Utang_sp
     * const Utang_sp = await prisma.utang_sp.create({
     *   data: {
     *     // ... data to create a Utang_sp
     *   }
     * })
     * 
     */
    create<T extends utang_spCreateArgs>(args: SelectSubset<T, utang_spCreateArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Utang_sps.
     * @param {utang_spCreateManyArgs} args - Arguments to create many Utang_sps.
     * @example
     * // Create many Utang_sps
     * const utang_sp = await prisma.utang_sp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends utang_spCreateManyArgs>(args?: SelectSubset<T, utang_spCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utang_sp.
     * @param {utang_spDeleteArgs} args - Arguments to delete one Utang_sp.
     * @example
     * // Delete one Utang_sp
     * const Utang_sp = await prisma.utang_sp.delete({
     *   where: {
     *     // ... filter to delete one Utang_sp
     *   }
     * })
     * 
     */
    delete<T extends utang_spDeleteArgs>(args: SelectSubset<T, utang_spDeleteArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Utang_sp.
     * @param {utang_spUpdateArgs} args - Arguments to update one Utang_sp.
     * @example
     * // Update one Utang_sp
     * const utang_sp = await prisma.utang_sp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends utang_spUpdateArgs>(args: SelectSubset<T, utang_spUpdateArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Utang_sps.
     * @param {utang_spDeleteManyArgs} args - Arguments to filter Utang_sps to delete.
     * @example
     * // Delete a few Utang_sps
     * const { count } = await prisma.utang_sp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends utang_spDeleteManyArgs>(args?: SelectSubset<T, utang_spDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utang_sps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utang_sps
     * const utang_sp = await prisma.utang_sp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends utang_spUpdateManyArgs>(args: SelectSubset<T, utang_spUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utang_sp.
     * @param {utang_spUpsertArgs} args - Arguments to update or create a Utang_sp.
     * @example
     * // Update or create a Utang_sp
     * const utang_sp = await prisma.utang_sp.upsert({
     *   create: {
     *     // ... data to create a Utang_sp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utang_sp we want to update
     *   }
     * })
     */
    upsert<T extends utang_spUpsertArgs>(args: SelectSubset<T, utang_spUpsertArgs<ExtArgs>>): Prisma__utang_spClient<$Result.GetResult<Prisma.$utang_spPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Utang_sps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spCountArgs} args - Arguments to filter Utang_sps to count.
     * @example
     * // Count the number of Utang_sps
     * const count = await prisma.utang_sp.count({
     *   where: {
     *     // ... the filter for the Utang_sps we want to count
     *   }
     * })
    **/
    count<T extends utang_spCountArgs>(
      args?: Subset<T, utang_spCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Utang_spCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utang_sp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Utang_spAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Utang_spAggregateArgs>(args: Subset<T, Utang_spAggregateArgs>): Prisma.PrismaPromise<GetUtang_spAggregateType<T>>

    /**
     * Group by Utang_sp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {utang_spGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends utang_spGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: utang_spGroupByArgs['orderBy'] }
        : { orderBy?: utang_spGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, utang_spGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtang_spGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the utang_sp model
   */
  readonly fields: utang_spFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for utang_sp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__utang_spClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the utang_sp model
   */ 
  interface utang_spFieldRefs {
    readonly id: FieldRef<"utang_sp", 'Int'>
    readonly tanggal: FieldRef<"utang_sp", 'DateTime'>
    readonly debet: FieldRef<"utang_sp", 'Decimal'>
    readonly kredit: FieldRef<"utang_sp", 'Decimal'>
    readonly keterangan: FieldRef<"utang_sp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * utang_sp findUnique
   */
  export type utang_spFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter, which utang_sp to fetch.
     */
    where: utang_spWhereUniqueInput
  }

  /**
   * utang_sp findUniqueOrThrow
   */
  export type utang_spFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter, which utang_sp to fetch.
     */
    where: utang_spWhereUniqueInput
  }

  /**
   * utang_sp findFirst
   */
  export type utang_spFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter, which utang_sp to fetch.
     */
    where?: utang_spWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utang_sps to fetch.
     */
    orderBy?: utang_spOrderByWithRelationInput | utang_spOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utang_sps.
     */
    cursor?: utang_spWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utang_sps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utang_sps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utang_sps.
     */
    distinct?: Utang_spScalarFieldEnum | Utang_spScalarFieldEnum[]
  }

  /**
   * utang_sp findFirstOrThrow
   */
  export type utang_spFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter, which utang_sp to fetch.
     */
    where?: utang_spWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utang_sps to fetch.
     */
    orderBy?: utang_spOrderByWithRelationInput | utang_spOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for utang_sps.
     */
    cursor?: utang_spWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utang_sps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utang_sps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of utang_sps.
     */
    distinct?: Utang_spScalarFieldEnum | Utang_spScalarFieldEnum[]
  }

  /**
   * utang_sp findMany
   */
  export type utang_spFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter, which utang_sps to fetch.
     */
    where?: utang_spWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of utang_sps to fetch.
     */
    orderBy?: utang_spOrderByWithRelationInput | utang_spOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing utang_sps.
     */
    cursor?: utang_spWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` utang_sps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` utang_sps.
     */
    skip?: number
    distinct?: Utang_spScalarFieldEnum | Utang_spScalarFieldEnum[]
  }

  /**
   * utang_sp create
   */
  export type utang_spCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * The data needed to create a utang_sp.
     */
    data: XOR<utang_spCreateInput, utang_spUncheckedCreateInput>
  }

  /**
   * utang_sp createMany
   */
  export type utang_spCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many utang_sps.
     */
    data: utang_spCreateManyInput | utang_spCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * utang_sp update
   */
  export type utang_spUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * The data needed to update a utang_sp.
     */
    data: XOR<utang_spUpdateInput, utang_spUncheckedUpdateInput>
    /**
     * Choose, which utang_sp to update.
     */
    where: utang_spWhereUniqueInput
  }

  /**
   * utang_sp updateMany
   */
  export type utang_spUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update utang_sps.
     */
    data: XOR<utang_spUpdateManyMutationInput, utang_spUncheckedUpdateManyInput>
    /**
     * Filter which utang_sps to update
     */
    where?: utang_spWhereInput
  }

  /**
   * utang_sp upsert
   */
  export type utang_spUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * The filter to search for the utang_sp to update in case it exists.
     */
    where: utang_spWhereUniqueInput
    /**
     * In case the utang_sp found by the `where` argument doesn't exist, create a new utang_sp with this data.
     */
    create: XOR<utang_spCreateInput, utang_spUncheckedCreateInput>
    /**
     * In case the utang_sp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<utang_spUpdateInput, utang_spUncheckedUpdateInput>
  }

  /**
   * utang_sp delete
   */
  export type utang_spDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
    /**
     * Filter which utang_sp to delete.
     */
    where: utang_spWhereUniqueInput
  }

  /**
   * utang_sp deleteMany
   */
  export type utang_spDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which utang_sps to delete
     */
    where?: utang_spWhereInput
  }

  /**
   * utang_sp without action
   */
  export type utang_spDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the utang_sp
     */
    select?: utang_spSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    bagian: 'bagian',
    username: 'username',
    password: 'password',
    nama: 'nama',
    type: 'type',
    level: 'level'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AnggotaScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    nama: 'nama',
    alamat: 'alamat',
    telp: 'telp',
    kredit_limit: 'kredit_limit',
    kredit_pinjaman: 'kredit_pinjaman',
    status: 'status',
    created: 'created',
    modified: 'modified'
  };

  export type AnggotaScalarFieldEnum = (typeof AnggotaScalarFieldEnum)[keyof typeof AnggotaScalarFieldEnum]


  export const Anggota_kreditScalarFieldEnum: {
    id: 'id',
    id_anggota: 'id_anggota',
    id_transaksi: 'id_transaksi',
    ex_bukti: 'ex_bukti',
    tanggal: 'tanggal',
    debet: 'debet',
    kredit: 'kredit',
    keterangan: 'keterangan'
  };

  export type Anggota_kreditScalarFieldEnum = (typeof Anggota_kreditScalarFieldEnum)[keyof typeof Anggota_kreditScalarFieldEnum]


  export const BagianScalarFieldEnum: {
    id: 'id',
    nama: 'nama'
  };

  export type BagianScalarFieldEnum = (typeof BagianScalarFieldEnum)[keyof typeof BagianScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    nama: 'nama',
    saldo: 'saldo'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const Bank_mutasiScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    id_bank: 'id_bank',
    debet: 'debet',
    kredit: 'kredit',
    debet2: 'debet2',
    kredit2: 'kredit2',
    adm: 'adm',
    pajak: 'pajak',
    jasa: 'jasa',
    keterangan: 'keterangan'
  };

  export type Bank_mutasiScalarFieldEnum = (typeof Bank_mutasiScalarFieldEnum)[keyof typeof Bank_mutasiScalarFieldEnum]


  export const BayarScalarFieldEnum: {
    id: 'id',
    nama: 'nama'
  };

  export type BayarScalarFieldEnum = (typeof BayarScalarFieldEnum)[keyof typeof BayarScalarFieldEnum]


  export const Beban_operasionalScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    keterangan: 'keterangan',
    jumlah: 'jumlah'
  };

  export type Beban_operasionalScalarFieldEnum = (typeof Beban_operasionalScalarFieldEnum)[keyof typeof Beban_operasionalScalarFieldEnum]


  export const Cash_in_outScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    jenis: 'jenis',
    detail: 'detail',
    input: 'input',
    output: 'output',
    keterangan: 'keterangan'
  };

  export type Cash_in_outScalarFieldEnum = (typeof Cash_in_outScalarFieldEnum)[keyof typeof Cash_in_outScalarFieldEnum]


  export const Cash_jenisScalarFieldEnum: {
    id: 'id',
    parent: 'parent',
    nama: 'nama',
    nilai: 'nilai'
  };

  export type Cash_jenisScalarFieldEnum = (typeof Cash_jenisScalarFieldEnum)[keyof typeof Cash_jenisScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    alamat: 'alamat',
    telp: 'telp',
    bulat: 'bulat',
    versi: 'versi',
    shortcut: 'shortcut',
    modified: 'modified'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const DanaScalarFieldEnum: {
    id: 'id',
    jenis: 'jenis',
    kode: 'kode',
    nama: 'nama',
    jumlah: 'jumlah'
  };

  export type DanaScalarFieldEnum = (typeof DanaScalarFieldEnum)[keyof typeof DanaScalarFieldEnum]


  export const Dana_testScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    nilai: 'nilai',
    nilai2: 'nilai2'
  };

  export type Dana_testScalarFieldEnum = (typeof Dana_testScalarFieldEnum)[keyof typeof Dana_testScalarFieldEnum]


  export const DivisiScalarFieldEnum: {
    id: 'id',
    jenis: 'jenis',
    kode: 'kode',
    nama: 'nama',
    created: 'created',
    modified: 'modified'
  };

  export type DivisiScalarFieldEnum = (typeof DivisiScalarFieldEnum)[keyof typeof DivisiScalarFieldEnum]


  export const EstimasiScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    tanggal: 'tanggal',
    jumlah: 'jumlah',
    produk: 'produk',
    total_beli: 'total_beli',
    total_jual: 'total_jual',
    keterangan: 'keterangan',
    admin: 'admin',
    created: 'created',
    modified: 'modified'
  };

  export type EstimasiScalarFieldEnum = (typeof EstimasiScalarFieldEnum)[keyof typeof EstimasiScalarFieldEnum]


  export const Estimasi_itemScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    id_estimasi: 'id_estimasi',
    id_produk: 'id_produk',
    id_supplier: 'id_supplier',
    harga_beli: 'harga_beli',
    harga_jual: 'harga_jual',
    jumlah: 'jumlah'
  };

  export type Estimasi_itemScalarFieldEnum = (typeof Estimasi_itemScalarFieldEnum)[keyof typeof Estimasi_itemScalarFieldEnum]


  export const InventarisScalarFieldEnum: {
    id: 'id',
    jenis: 'jenis',
    nama: 'nama',
    tanggal: 'tanggal',
    nilai: 'nilai',
    persen: 'persen',
    sisa_2023: 'sisa_2023',
    created: 'created',
    modified: 'modified'
  };

  export type InventarisScalarFieldEnum = (typeof InventarisScalarFieldEnum)[keyof typeof InventarisScalarFieldEnum]


  export const Pelunasan_pembelianScalarFieldEnum: {
    id: 'id',
    id_supplier: 'id_supplier',
    id_transaksi: 'id_transaksi',
    tanggal: 'tanggal',
    jumlah: 'jumlah',
    keterangan: 'keterangan'
  };

  export type Pelunasan_pembelianScalarFieldEnum = (typeof Pelunasan_pembelianScalarFieldEnum)[keyof typeof Pelunasan_pembelianScalarFieldEnum]


  export const PemusnahanScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    jumlah: 'jumlah',
    jumlah_fix: 'jumlah_fix',
    jangka: 'jangka',
    keterangan: 'keterangan'
  };

  export type PemusnahanScalarFieldEnum = (typeof PemusnahanScalarFieldEnum)[keyof typeof PemusnahanScalarFieldEnum]


  export const ProdukScalarFieldEnum: {
    id: 'id',
    divisi: 'divisi',
    supplier: 'supplier',
    kode: 'kode',
    nama: 'nama',
    harga_beli: 'harga_beli',
    harga_jual: 'harga_jual',
    jumlah: 'jumlah',
    diskon: 'diskon',
    keterangan: 'keterangan',
    status: 'status',
    created: 'created',
    modified: 'modified'
  };

  export type ProdukScalarFieldEnum = (typeof ProdukScalarFieldEnum)[keyof typeof ProdukScalarFieldEnum]


  export const Produk_hargaScalarFieldEnum: {
    id: 'id',
    id_produk: 'id_produk',
    tanggal: 'tanggal',
    harga_beli: 'harga_beli',
    harga_jual: 'harga_jual'
  };

  export type Produk_hargaScalarFieldEnum = (typeof Produk_hargaScalarFieldEnum)[keyof typeof Produk_hargaScalarFieldEnum]


  export const RapbScalarFieldEnum: {
    no: 'no',
    tahun: 'tahun',
    hasil_usaha: 'hasil_usaha',
    jasa_bank: 'jasa_bank',
    pendapatan_lain: 'pendapatan_lain',
    beban_gaji: 'beban_gaji',
    uang_makan: 'uang_makan',
    thr_karyawan: 'thr_karyawan',
    tunjangan_pangan: 'tunjangan_pangan',
    beban_adm: 'beban_adm',
    beban_perlengkapan: 'beban_perlengkapan',
    tunjangan_kesehatan: 'tunjangan_kesehatan',
    peny_inventaris: 'peny_inventaris',
    peny_gedung: 'peny_gedung',
    pemeliharaan_inventaris: 'pemeliharaan_inventaris',
    pemeliharaan_gedung: 'pemeliharaan_gedung',
    beban_pensiun: 'beban_pensiun',
    kerugian_persediaan: 'kerugian_persediaan',
    sisa_hasil_usaha: 'sisa_hasil_usaha'
  };

  export type RapbScalarFieldEnum = (typeof RapbScalarFieldEnum)[keyof typeof RapbScalarFieldEnum]


  export const Saldo_tokoScalarFieldEnum: {
    id: 'id',
    jenis: 'jenis',
    id_transaksi: 'id_transaksi',
    tanggal: 'tanggal',
    debet: 'debet',
    kredit: 'kredit',
    saldo: 'saldo',
    keterangan: 'keterangan'
  };

  export type Saldo_tokoScalarFieldEnum = (typeof Saldo_tokoScalarFieldEnum)[keyof typeof Saldo_tokoScalarFieldEnum]


  export const Shu_mutasiScalarFieldEnum: {
    id: 'id',
    tahun_shu: 'tahun_shu',
    tanggal: 'tanggal',
    debet: 'debet',
    kredit: 'kredit',
    keterangan: 'keterangan'
  };

  export type Shu_mutasiScalarFieldEnum = (typeof Shu_mutasiScalarFieldEnum)[keyof typeof Shu_mutasiScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    nama: 'nama',
    alamat: 'alamat',
    pemilik: 'pemilik',
    kontak: 'kontak',
    kredit: 'kredit',
    created: 'created',
    modified: 'modified'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const Supplier_kreditScalarFieldEnum: {
    id: 'id',
    id_supplier: 'id_supplier',
    id_transaksi: 'id_transaksi',
    ex_bukti: 'ex_bukti',
    tanggal: 'tanggal',
    debet: 'debet',
    kredit: 'kredit',
    keterangan: 'keterangan'
  };

  export type Supplier_kreditScalarFieldEnum = (typeof Supplier_kreditScalarFieldEnum)[keyof typeof Supplier_kreditScalarFieldEnum]


  export const TransaksiScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    kode_ex: 'kode_ex',
    kode_2: 'kode_2',
    tanggal: 'tanggal',
    jenis: 'jenis',
    sumber: 'sumber',
    jumlah: 'jumlah',
    produk: 'produk',
    total_beli: 'total_beli',
    total_jual: 'total_jual',
    diskon_item: 'diskon_item',
    diskon_persen: 'diskon_persen',
    diskon_total: 'diskon_total',
    bayar: 'bayar',
    kredit: 'kredit',
    keterangan: 'keterangan',
    anggota: 'anggota',
    admin: 'admin',
    status: 'status',
    created: 'created',
    modified: 'modified'
  };

  export type TransaksiScalarFieldEnum = (typeof TransaksiScalarFieldEnum)[keyof typeof TransaksiScalarFieldEnum]


  export const Transaksi_itemScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    jenis: 'jenis',
    id_transaksi: 'id_transaksi',
    id_produk: 'id_produk',
    harga_beli: 'harga_beli',
    harga_jual: 'harga_jual',
    jumlah: 'jumlah',
    diskon: 'diskon'
  };

  export type Transaksi_itemScalarFieldEnum = (typeof Transaksi_itemScalarFieldEnum)[keyof typeof Transaksi_itemScalarFieldEnum]


  export const Transaksi_jenisScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    tipe: 'tipe',
    fix: 'fix'
  };

  export type Transaksi_jenisScalarFieldEnum = (typeof Transaksi_jenisScalarFieldEnum)[keyof typeof Transaksi_jenisScalarFieldEnum]


  export const TujuanScalarFieldEnum: {
    id: 'id',
    nama: 'nama'
  };

  export type TujuanScalarFieldEnum = (typeof TujuanScalarFieldEnum)[keyof typeof TujuanScalarFieldEnum]


  export const Tutup_kasirScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    shift: 'shift',
    kasir: 'kasir',
    tunai: 'tunai',
    bon: 'bon',
    struk: 'struk'
  };

  export type Tutup_kasirScalarFieldEnum = (typeof Tutup_kasirScalarFieldEnum)[keyof typeof Tutup_kasirScalarFieldEnum]


  export const Utang_spScalarFieldEnum: {
    id: 'id',
    tanggal: 'tanggal',
    debet: 'debet',
    kredit: 'kredit',
    keterangan: 'keterangan'
  };

  export type Utang_spScalarFieldEnum = (typeof Utang_spScalarFieldEnum)[keyof typeof Utang_spScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    bagian?: IntFilter<"admin"> | number
    username?: StringFilter<"admin"> | string
    password?: StringFilter<"admin"> | string
    nama?: StringFilter<"admin"> | string
    type?: StringFilter<"admin"> | string
    level?: IntFilter<"admin"> | number
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    bagian?: SortOrder
    username?: SortOrder
    password?: SortOrder
    nama?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    bagian?: IntFilter<"admin"> | number
    username?: StringFilter<"admin"> | string
    password?: StringFilter<"admin"> | string
    nama?: StringFilter<"admin"> | string
    type?: StringFilter<"admin"> | string
    level?: IntFilter<"admin"> | number
  }, "id">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    bagian?: SortOrder
    username?: SortOrder
    password?: SortOrder
    nama?: SortOrder
    type?: SortOrder
    level?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    bagian?: IntWithAggregatesFilter<"admin"> | number
    username?: StringWithAggregatesFilter<"admin"> | string
    password?: StringWithAggregatesFilter<"admin"> | string
    nama?: StringWithAggregatesFilter<"admin"> | string
    type?: StringWithAggregatesFilter<"admin"> | string
    level?: IntWithAggregatesFilter<"admin"> | number
  }

  export type anggotaWhereInput = {
    AND?: anggotaWhereInput | anggotaWhereInput[]
    OR?: anggotaWhereInput[]
    NOT?: anggotaWhereInput | anggotaWhereInput[]
    id?: IntFilter<"anggota"> | number
    kode?: StringFilter<"anggota"> | string
    nama?: StringFilter<"anggota"> | string
    alamat?: StringFilter<"anggota"> | string
    telp?: StringFilter<"anggota"> | string
    kredit_limit?: DecimalFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"anggota"> | number
    created?: DateTimeNullableFilter<"anggota"> | Date | string | null
    modified?: DateTimeNullableFilter<"anggota"> | Date | string | null
  }

  export type anggotaOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
  }

  export type anggotaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: anggotaWhereInput | anggotaWhereInput[]
    OR?: anggotaWhereInput[]
    NOT?: anggotaWhereInput | anggotaWhereInput[]
    kode?: StringFilter<"anggota"> | string
    nama?: StringFilter<"anggota"> | string
    alamat?: StringFilter<"anggota"> | string
    telp?: StringFilter<"anggota"> | string
    kredit_limit?: DecimalFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    status?: IntFilter<"anggota"> | number
    created?: DateTimeNullableFilter<"anggota"> | Date | string | null
    modified?: DateTimeNullableFilter<"anggota"> | Date | string | null
  }, "id">

  export type anggotaOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
    _count?: anggotaCountOrderByAggregateInput
    _avg?: anggotaAvgOrderByAggregateInput
    _max?: anggotaMaxOrderByAggregateInput
    _min?: anggotaMinOrderByAggregateInput
    _sum?: anggotaSumOrderByAggregateInput
  }

  export type anggotaScalarWhereWithAggregatesInput = {
    AND?: anggotaScalarWhereWithAggregatesInput | anggotaScalarWhereWithAggregatesInput[]
    OR?: anggotaScalarWhereWithAggregatesInput[]
    NOT?: anggotaScalarWhereWithAggregatesInput | anggotaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"anggota"> | number
    kode?: StringWithAggregatesFilter<"anggota"> | string
    nama?: StringWithAggregatesFilter<"anggota"> | string
    alamat?: StringWithAggregatesFilter<"anggota"> | string
    telp?: StringWithAggregatesFilter<"anggota"> | string
    kredit_limit?: DecimalWithAggregatesFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalWithAggregatesFilter<"anggota"> | Decimal | DecimalJsLike | number | string
    status?: IntWithAggregatesFilter<"anggota"> | number
    created?: DateTimeNullableWithAggregatesFilter<"anggota"> | Date | string | null
    modified?: DateTimeNullableWithAggregatesFilter<"anggota"> | Date | string | null
  }

  export type anggota_kreditWhereInput = {
    AND?: anggota_kreditWhereInput | anggota_kreditWhereInput[]
    OR?: anggota_kreditWhereInput[]
    NOT?: anggota_kreditWhereInput | anggota_kreditWhereInput[]
    id?: IntFilter<"anggota_kredit"> | number
    id_anggota?: IntFilter<"anggota_kredit"> | number
    id_transaksi?: IntFilter<"anggota_kredit"> | number
    ex_bukti?: StringFilter<"anggota_kredit"> | string
    tanggal?: DateTimeNullableFilter<"anggota_kredit"> | Date | string | null
    debet?: DecimalFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"anggota_kredit"> | string
  }

  export type anggota_kreditOrderByWithRelationInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type anggota_kreditWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: anggota_kreditWhereInput | anggota_kreditWhereInput[]
    OR?: anggota_kreditWhereInput[]
    NOT?: anggota_kreditWhereInput | anggota_kreditWhereInput[]
    id_anggota?: IntFilter<"anggota_kredit"> | number
    id_transaksi?: IntFilter<"anggota_kredit"> | number
    ex_bukti?: StringFilter<"anggota_kredit"> | string
    tanggal?: DateTimeNullableFilter<"anggota_kredit"> | Date | string | null
    debet?: DecimalFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"anggota_kredit"> | string
  }, "id">

  export type anggota_kreditOrderByWithAggregationInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    _count?: anggota_kreditCountOrderByAggregateInput
    _avg?: anggota_kreditAvgOrderByAggregateInput
    _max?: anggota_kreditMaxOrderByAggregateInput
    _min?: anggota_kreditMinOrderByAggregateInput
    _sum?: anggota_kreditSumOrderByAggregateInput
  }

  export type anggota_kreditScalarWhereWithAggregatesInput = {
    AND?: anggota_kreditScalarWhereWithAggregatesInput | anggota_kreditScalarWhereWithAggregatesInput[]
    OR?: anggota_kreditScalarWhereWithAggregatesInput[]
    NOT?: anggota_kreditScalarWhereWithAggregatesInput | anggota_kreditScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"anggota_kredit"> | number
    id_anggota?: IntWithAggregatesFilter<"anggota_kredit"> | number
    id_transaksi?: IntWithAggregatesFilter<"anggota_kredit"> | number
    ex_bukti?: StringWithAggregatesFilter<"anggota_kredit"> | string
    tanggal?: DateTimeNullableWithAggregatesFilter<"anggota_kredit"> | Date | string | null
    debet?: DecimalWithAggregatesFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalWithAggregatesFilter<"anggota_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"anggota_kredit"> | string
  }

  export type bagianWhereInput = {
    AND?: bagianWhereInput | bagianWhereInput[]
    OR?: bagianWhereInput[]
    NOT?: bagianWhereInput | bagianWhereInput[]
    id?: IntFilter<"bagian"> | number
    nama?: StringFilter<"bagian"> | string
  }

  export type bagianOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bagianWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bagianWhereInput | bagianWhereInput[]
    OR?: bagianWhereInput[]
    NOT?: bagianWhereInput | bagianWhereInput[]
    nama?: StringFilter<"bagian"> | string
  }, "id">

  export type bagianOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    _count?: bagianCountOrderByAggregateInput
    _avg?: bagianAvgOrderByAggregateInput
    _max?: bagianMaxOrderByAggregateInput
    _min?: bagianMinOrderByAggregateInput
    _sum?: bagianSumOrderByAggregateInput
  }

  export type bagianScalarWhereWithAggregatesInput = {
    AND?: bagianScalarWhereWithAggregatesInput | bagianScalarWhereWithAggregatesInput[]
    OR?: bagianScalarWhereWithAggregatesInput[]
    NOT?: bagianScalarWhereWithAggregatesInput | bagianScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bagian"> | number
    nama?: StringWithAggregatesFilter<"bagian"> | string
  }

  export type bankWhereInput = {
    AND?: bankWhereInput | bankWhereInput[]
    OR?: bankWhereInput[]
    NOT?: bankWhereInput | bankWhereInput[]
    id?: IntFilter<"bank"> | number
    kode?: StringFilter<"bank"> | string
    nama?: StringFilter<"bank"> | string
    saldo?: DecimalFilter<"bank"> | Decimal | DecimalJsLike | number | string
  }

  export type bankOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    saldo?: SortOrder
  }

  export type bankWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bankWhereInput | bankWhereInput[]
    OR?: bankWhereInput[]
    NOT?: bankWhereInput | bankWhereInput[]
    kode?: StringFilter<"bank"> | string
    nama?: StringFilter<"bank"> | string
    saldo?: DecimalFilter<"bank"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type bankOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    saldo?: SortOrder
    _count?: bankCountOrderByAggregateInput
    _avg?: bankAvgOrderByAggregateInput
    _max?: bankMaxOrderByAggregateInput
    _min?: bankMinOrderByAggregateInput
    _sum?: bankSumOrderByAggregateInput
  }

  export type bankScalarWhereWithAggregatesInput = {
    AND?: bankScalarWhereWithAggregatesInput | bankScalarWhereWithAggregatesInput[]
    OR?: bankScalarWhereWithAggregatesInput[]
    NOT?: bankScalarWhereWithAggregatesInput | bankScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bank"> | number
    kode?: StringWithAggregatesFilter<"bank"> | string
    nama?: StringWithAggregatesFilter<"bank"> | string
    saldo?: DecimalWithAggregatesFilter<"bank"> | Decimal | DecimalJsLike | number | string
  }

  export type bank_mutasiWhereInput = {
    AND?: bank_mutasiWhereInput | bank_mutasiWhereInput[]
    OR?: bank_mutasiWhereInput[]
    NOT?: bank_mutasiWhereInput | bank_mutasiWhereInput[]
    id?: IntFilter<"bank_mutasi"> | number
    tanggal?: DateTimeFilter<"bank_mutasi"> | Date | string
    id_bank?: IntFilter<"bank_mutasi"> | number
    debet?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    adm?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"bank_mutasi"> | string
  }

  export type bank_mutasiOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
    keterangan?: SortOrder
  }

  export type bank_mutasiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bank_mutasiWhereInput | bank_mutasiWhereInput[]
    OR?: bank_mutasiWhereInput[]
    NOT?: bank_mutasiWhereInput | bank_mutasiWhereInput[]
    tanggal?: DateTimeFilter<"bank_mutasi"> | Date | string
    id_bank?: IntFilter<"bank_mutasi"> | number
    debet?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    adm?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"bank_mutasi"> | string
  }, "id">

  export type bank_mutasiOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
    keterangan?: SortOrder
    _count?: bank_mutasiCountOrderByAggregateInput
    _avg?: bank_mutasiAvgOrderByAggregateInput
    _max?: bank_mutasiMaxOrderByAggregateInput
    _min?: bank_mutasiMinOrderByAggregateInput
    _sum?: bank_mutasiSumOrderByAggregateInput
  }

  export type bank_mutasiScalarWhereWithAggregatesInput = {
    AND?: bank_mutasiScalarWhereWithAggregatesInput | bank_mutasiScalarWhereWithAggregatesInput[]
    OR?: bank_mutasiScalarWhereWithAggregatesInput[]
    NOT?: bank_mutasiScalarWhereWithAggregatesInput | bank_mutasiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bank_mutasi"> | number
    tanggal?: DateTimeWithAggregatesFilter<"bank_mutasi"> | Date | string
    id_bank?: IntWithAggregatesFilter<"bank_mutasi"> | number
    debet?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    debet2?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    adm?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    pajak?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    jasa?: DecimalWithAggregatesFilter<"bank_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"bank_mutasi"> | string
  }

  export type bayarWhereInput = {
    AND?: bayarWhereInput | bayarWhereInput[]
    OR?: bayarWhereInput[]
    NOT?: bayarWhereInput | bayarWhereInput[]
    id?: IntFilter<"bayar"> | number
    nama?: StringFilter<"bayar"> | string
  }

  export type bayarOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bayarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bayarWhereInput | bayarWhereInput[]
    OR?: bayarWhereInput[]
    NOT?: bayarWhereInput | bayarWhereInput[]
    nama?: StringFilter<"bayar"> | string
  }, "id">

  export type bayarOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    _count?: bayarCountOrderByAggregateInput
    _avg?: bayarAvgOrderByAggregateInput
    _max?: bayarMaxOrderByAggregateInput
    _min?: bayarMinOrderByAggregateInput
    _sum?: bayarSumOrderByAggregateInput
  }

  export type bayarScalarWhereWithAggregatesInput = {
    AND?: bayarScalarWhereWithAggregatesInput | bayarScalarWhereWithAggregatesInput[]
    OR?: bayarScalarWhereWithAggregatesInput[]
    NOT?: bayarScalarWhereWithAggregatesInput | bayarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bayar"> | number
    nama?: StringWithAggregatesFilter<"bayar"> | string
  }

  export type beban_operasionalWhereInput = {
    AND?: beban_operasionalWhereInput | beban_operasionalWhereInput[]
    OR?: beban_operasionalWhereInput[]
    NOT?: beban_operasionalWhereInput | beban_operasionalWhereInput[]
    id?: IntFilter<"beban_operasional"> | number
    tanggal?: DateTimeNullableFilter<"beban_operasional"> | Date | string | null
    keterangan?: StringFilter<"beban_operasional"> | string
    jumlah?: FloatFilter<"beban_operasional"> | number
  }

  export type beban_operasionalOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    keterangan?: SortOrder
    jumlah?: SortOrder
  }

  export type beban_operasionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: beban_operasionalWhereInput | beban_operasionalWhereInput[]
    OR?: beban_operasionalWhereInput[]
    NOT?: beban_operasionalWhereInput | beban_operasionalWhereInput[]
    tanggal?: DateTimeNullableFilter<"beban_operasional"> | Date | string | null
    keterangan?: StringFilter<"beban_operasional"> | string
    jumlah?: FloatFilter<"beban_operasional"> | number
  }, "id">

  export type beban_operasionalOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    keterangan?: SortOrder
    jumlah?: SortOrder
    _count?: beban_operasionalCountOrderByAggregateInput
    _avg?: beban_operasionalAvgOrderByAggregateInput
    _max?: beban_operasionalMaxOrderByAggregateInput
    _min?: beban_operasionalMinOrderByAggregateInput
    _sum?: beban_operasionalSumOrderByAggregateInput
  }

  export type beban_operasionalScalarWhereWithAggregatesInput = {
    AND?: beban_operasionalScalarWhereWithAggregatesInput | beban_operasionalScalarWhereWithAggregatesInput[]
    OR?: beban_operasionalScalarWhereWithAggregatesInput[]
    NOT?: beban_operasionalScalarWhereWithAggregatesInput | beban_operasionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"beban_operasional"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"beban_operasional"> | Date | string | null
    keterangan?: StringWithAggregatesFilter<"beban_operasional"> | string
    jumlah?: FloatWithAggregatesFilter<"beban_operasional"> | number
  }

  export type cash_in_outWhereInput = {
    AND?: cash_in_outWhereInput | cash_in_outWhereInput[]
    OR?: cash_in_outWhereInput[]
    NOT?: cash_in_outWhereInput | cash_in_outWhereInput[]
    id?: IntFilter<"cash_in_out"> | number
    tanggal?: DateTimeFilter<"cash_in_out"> | Date | string
    jenis?: IntFilter<"cash_in_out"> | number
    detail?: IntFilter<"cash_in_out"> | number
    input?: DecimalFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    output?: DecimalFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"cash_in_out"> | string
  }

  export type cash_in_outOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
    keterangan?: SortOrder
  }

  export type cash_in_outWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cash_in_outWhereInput | cash_in_outWhereInput[]
    OR?: cash_in_outWhereInput[]
    NOT?: cash_in_outWhereInput | cash_in_outWhereInput[]
    tanggal?: DateTimeFilter<"cash_in_out"> | Date | string
    jenis?: IntFilter<"cash_in_out"> | number
    detail?: IntFilter<"cash_in_out"> | number
    input?: DecimalFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    output?: DecimalFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"cash_in_out"> | string
  }, "id">

  export type cash_in_outOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
    keterangan?: SortOrder
    _count?: cash_in_outCountOrderByAggregateInput
    _avg?: cash_in_outAvgOrderByAggregateInput
    _max?: cash_in_outMaxOrderByAggregateInput
    _min?: cash_in_outMinOrderByAggregateInput
    _sum?: cash_in_outSumOrderByAggregateInput
  }

  export type cash_in_outScalarWhereWithAggregatesInput = {
    AND?: cash_in_outScalarWhereWithAggregatesInput | cash_in_outScalarWhereWithAggregatesInput[]
    OR?: cash_in_outScalarWhereWithAggregatesInput[]
    NOT?: cash_in_outScalarWhereWithAggregatesInput | cash_in_outScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cash_in_out"> | number
    tanggal?: DateTimeWithAggregatesFilter<"cash_in_out"> | Date | string
    jenis?: IntWithAggregatesFilter<"cash_in_out"> | number
    detail?: IntWithAggregatesFilter<"cash_in_out"> | number
    input?: DecimalWithAggregatesFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    output?: DecimalWithAggregatesFilter<"cash_in_out"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"cash_in_out"> | string
  }

  export type cash_jenisWhereInput = {
    AND?: cash_jenisWhereInput | cash_jenisWhereInput[]
    OR?: cash_jenisWhereInput[]
    NOT?: cash_jenisWhereInput | cash_jenisWhereInput[]
    id?: IntFilter<"cash_jenis"> | number
    parent?: IntFilter<"cash_jenis"> | number
    nama?: StringFilter<"cash_jenis"> | string
    nilai?: IntFilter<"cash_jenis"> | number
  }

  export type cash_jenisOrderByWithRelationInput = {
    id?: SortOrder
    parent?: SortOrder
    nama?: SortOrder
    nilai?: SortOrder
  }

  export type cash_jenisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cash_jenisWhereInput | cash_jenisWhereInput[]
    OR?: cash_jenisWhereInput[]
    NOT?: cash_jenisWhereInput | cash_jenisWhereInput[]
    parent?: IntFilter<"cash_jenis"> | number
    nama?: StringFilter<"cash_jenis"> | string
    nilai?: IntFilter<"cash_jenis"> | number
  }, "id">

  export type cash_jenisOrderByWithAggregationInput = {
    id?: SortOrder
    parent?: SortOrder
    nama?: SortOrder
    nilai?: SortOrder
    _count?: cash_jenisCountOrderByAggregateInput
    _avg?: cash_jenisAvgOrderByAggregateInput
    _max?: cash_jenisMaxOrderByAggregateInput
    _min?: cash_jenisMinOrderByAggregateInput
    _sum?: cash_jenisSumOrderByAggregateInput
  }

  export type cash_jenisScalarWhereWithAggregatesInput = {
    AND?: cash_jenisScalarWhereWithAggregatesInput | cash_jenisScalarWhereWithAggregatesInput[]
    OR?: cash_jenisScalarWhereWithAggregatesInput[]
    NOT?: cash_jenisScalarWhereWithAggregatesInput | cash_jenisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cash_jenis"> | number
    parent?: IntWithAggregatesFilter<"cash_jenis"> | number
    nama?: StringWithAggregatesFilter<"cash_jenis"> | string
    nilai?: IntWithAggregatesFilter<"cash_jenis"> | number
  }

  export type configWhereInput = {
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    id?: IntFilter<"config"> | number
    nama?: StringFilter<"config"> | string
    alamat?: StringFilter<"config"> | string
    telp?: StringFilter<"config"> | string
    bulat?: IntFilter<"config"> | number
    versi?: IntFilter<"config"> | number
    shortcut?: IntFilter<"config"> | number
    modified?: DateTimeNullableFilter<"config"> | Date | string | null
  }

  export type configOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
    modified?: SortOrderInput | SortOrder
  }

  export type configWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    nama?: StringFilter<"config"> | string
    alamat?: StringFilter<"config"> | string
    telp?: StringFilter<"config"> | string
    bulat?: IntFilter<"config"> | number
    versi?: IntFilter<"config"> | number
    shortcut?: IntFilter<"config"> | number
    modified?: DateTimeNullableFilter<"config"> | Date | string | null
  }, "id">

  export type configOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
    modified?: SortOrderInput | SortOrder
    _count?: configCountOrderByAggregateInput
    _avg?: configAvgOrderByAggregateInput
    _max?: configMaxOrderByAggregateInput
    _min?: configMinOrderByAggregateInput
    _sum?: configSumOrderByAggregateInput
  }

  export type configScalarWhereWithAggregatesInput = {
    AND?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    OR?: configScalarWhereWithAggregatesInput[]
    NOT?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"config"> | number
    nama?: StringWithAggregatesFilter<"config"> | string
    alamat?: StringWithAggregatesFilter<"config"> | string
    telp?: StringWithAggregatesFilter<"config"> | string
    bulat?: IntWithAggregatesFilter<"config"> | number
    versi?: IntWithAggregatesFilter<"config"> | number
    shortcut?: IntWithAggregatesFilter<"config"> | number
    modified?: DateTimeNullableWithAggregatesFilter<"config"> | Date | string | null
  }

  export type danaWhereInput = {
    AND?: danaWhereInput | danaWhereInput[]
    OR?: danaWhereInput[]
    NOT?: danaWhereInput | danaWhereInput[]
    id?: IntFilter<"dana"> | number
    jenis?: IntFilter<"dana"> | number
    kode?: StringFilter<"dana"> | string
    nama?: StringFilter<"dana"> | string
    jumlah?: DecimalFilter<"dana"> | Decimal | DecimalJsLike | number | string
  }

  export type danaOrderByWithRelationInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    jumlah?: SortOrder
  }

  export type danaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: danaWhereInput | danaWhereInput[]
    OR?: danaWhereInput[]
    NOT?: danaWhereInput | danaWhereInput[]
    jenis?: IntFilter<"dana"> | number
    kode?: StringFilter<"dana"> | string
    nama?: StringFilter<"dana"> | string
    jumlah?: DecimalFilter<"dana"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type danaOrderByWithAggregationInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    jumlah?: SortOrder
    _count?: danaCountOrderByAggregateInput
    _avg?: danaAvgOrderByAggregateInput
    _max?: danaMaxOrderByAggregateInput
    _min?: danaMinOrderByAggregateInput
    _sum?: danaSumOrderByAggregateInput
  }

  export type danaScalarWhereWithAggregatesInput = {
    AND?: danaScalarWhereWithAggregatesInput | danaScalarWhereWithAggregatesInput[]
    OR?: danaScalarWhereWithAggregatesInput[]
    NOT?: danaScalarWhereWithAggregatesInput | danaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dana"> | number
    jenis?: IntWithAggregatesFilter<"dana"> | number
    kode?: StringWithAggregatesFilter<"dana"> | string
    nama?: StringWithAggregatesFilter<"dana"> | string
    jumlah?: DecimalWithAggregatesFilter<"dana"> | Decimal | DecimalJsLike | number | string
  }

  export type dana_testWhereInput = {
    AND?: dana_testWhereInput | dana_testWhereInput[]
    OR?: dana_testWhereInput[]
    NOT?: dana_testWhereInput | dana_testWhereInput[]
    id?: IntFilter<"dana_test"> | number
    tanggal?: DateTimeFilter<"dana_test"> | Date | string
    nilai?: DecimalFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
  }

  export type dana_testOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type dana_testWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dana_testWhereInput | dana_testWhereInput[]
    OR?: dana_testWhereInput[]
    NOT?: dana_testWhereInput | dana_testWhereInput[]
    tanggal?: DateTimeFilter<"dana_test"> | Date | string
    nilai?: DecimalFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type dana_testOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
    _count?: dana_testCountOrderByAggregateInput
    _avg?: dana_testAvgOrderByAggregateInput
    _max?: dana_testMaxOrderByAggregateInput
    _min?: dana_testMinOrderByAggregateInput
    _sum?: dana_testSumOrderByAggregateInput
  }

  export type dana_testScalarWhereWithAggregatesInput = {
    AND?: dana_testScalarWhereWithAggregatesInput | dana_testScalarWhereWithAggregatesInput[]
    OR?: dana_testScalarWhereWithAggregatesInput[]
    NOT?: dana_testScalarWhereWithAggregatesInput | dana_testScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dana_test"> | number
    tanggal?: DateTimeWithAggregatesFilter<"dana_test"> | Date | string
    nilai?: DecimalWithAggregatesFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalWithAggregatesFilter<"dana_test"> | Decimal | DecimalJsLike | number | string
  }

  export type divisiWhereInput = {
    AND?: divisiWhereInput | divisiWhereInput[]
    OR?: divisiWhereInput[]
    NOT?: divisiWhereInput | divisiWhereInput[]
    id?: IntFilter<"divisi"> | number
    jenis?: IntFilter<"divisi"> | number
    kode?: StringFilter<"divisi"> | string
    nama?: StringFilter<"divisi"> | string
    created?: DateTimeFilter<"divisi"> | Date | string
    modified?: DateTimeFilter<"divisi"> | Date | string
  }

  export type divisiOrderByWithRelationInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type divisiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: divisiWhereInput | divisiWhereInput[]
    OR?: divisiWhereInput[]
    NOT?: divisiWhereInput | divisiWhereInput[]
    jenis?: IntFilter<"divisi"> | number
    kode?: StringFilter<"divisi"> | string
    nama?: StringFilter<"divisi"> | string
    created?: DateTimeFilter<"divisi"> | Date | string
    modified?: DateTimeFilter<"divisi"> | Date | string
  }, "id">

  export type divisiOrderByWithAggregationInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    created?: SortOrder
    modified?: SortOrder
    _count?: divisiCountOrderByAggregateInput
    _avg?: divisiAvgOrderByAggregateInput
    _max?: divisiMaxOrderByAggregateInput
    _min?: divisiMinOrderByAggregateInput
    _sum?: divisiSumOrderByAggregateInput
  }

  export type divisiScalarWhereWithAggregatesInput = {
    AND?: divisiScalarWhereWithAggregatesInput | divisiScalarWhereWithAggregatesInput[]
    OR?: divisiScalarWhereWithAggregatesInput[]
    NOT?: divisiScalarWhereWithAggregatesInput | divisiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"divisi"> | number
    jenis?: IntWithAggregatesFilter<"divisi"> | number
    kode?: StringWithAggregatesFilter<"divisi"> | string
    nama?: StringWithAggregatesFilter<"divisi"> | string
    created?: DateTimeWithAggregatesFilter<"divisi"> | Date | string
    modified?: DateTimeWithAggregatesFilter<"divisi"> | Date | string
  }

  export type estimasiWhereInput = {
    AND?: estimasiWhereInput | estimasiWhereInput[]
    OR?: estimasiWhereInput[]
    NOT?: estimasiWhereInput | estimasiWhereInput[]
    id?: IntFilter<"estimasi"> | number
    kode?: StringFilter<"estimasi"> | string
    tanggal?: DateTimeNullableFilter<"estimasi"> | Date | string | null
    jumlah?: FloatFilter<"estimasi"> | number
    produk?: IntFilter<"estimasi"> | number
    total_beli?: DecimalFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"estimasi"> | string
    admin?: IntFilter<"estimasi"> | number
    created?: DateTimeNullableFilter<"estimasi"> | Date | string | null
    modified?: DateTimeNullableFilter<"estimasi"> | Date | string | null
  }

  export type estimasiOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    keterangan?: SortOrder
    admin?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
  }

  export type estimasiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: estimasiWhereInput | estimasiWhereInput[]
    OR?: estimasiWhereInput[]
    NOT?: estimasiWhereInput | estimasiWhereInput[]
    kode?: StringFilter<"estimasi"> | string
    tanggal?: DateTimeNullableFilter<"estimasi"> | Date | string | null
    jumlah?: FloatFilter<"estimasi"> | number
    produk?: IntFilter<"estimasi"> | number
    total_beli?: DecimalFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"estimasi"> | string
    admin?: IntFilter<"estimasi"> | number
    created?: DateTimeNullableFilter<"estimasi"> | Date | string | null
    modified?: DateTimeNullableFilter<"estimasi"> | Date | string | null
  }, "id">

  export type estimasiOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    keterangan?: SortOrder
    admin?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
    _count?: estimasiCountOrderByAggregateInput
    _avg?: estimasiAvgOrderByAggregateInput
    _max?: estimasiMaxOrderByAggregateInput
    _min?: estimasiMinOrderByAggregateInput
    _sum?: estimasiSumOrderByAggregateInput
  }

  export type estimasiScalarWhereWithAggregatesInput = {
    AND?: estimasiScalarWhereWithAggregatesInput | estimasiScalarWhereWithAggregatesInput[]
    OR?: estimasiScalarWhereWithAggregatesInput[]
    NOT?: estimasiScalarWhereWithAggregatesInput | estimasiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estimasi"> | number
    kode?: StringWithAggregatesFilter<"estimasi"> | string
    tanggal?: DateTimeNullableWithAggregatesFilter<"estimasi"> | Date | string | null
    jumlah?: FloatWithAggregatesFilter<"estimasi"> | number
    produk?: IntWithAggregatesFilter<"estimasi"> | number
    total_beli?: DecimalWithAggregatesFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalWithAggregatesFilter<"estimasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"estimasi"> | string
    admin?: IntWithAggregatesFilter<"estimasi"> | number
    created?: DateTimeNullableWithAggregatesFilter<"estimasi"> | Date | string | null
    modified?: DateTimeNullableWithAggregatesFilter<"estimasi"> | Date | string | null
  }

  export type estimasi_itemWhereInput = {
    AND?: estimasi_itemWhereInput | estimasi_itemWhereInput[]
    OR?: estimasi_itemWhereInput[]
    NOT?: estimasi_itemWhereInput | estimasi_itemWhereInput[]
    id?: IntFilter<"estimasi_item"> | number
    tanggal?: DateTimeNullableFilter<"estimasi_item"> | Date | string | null
    id_estimasi?: IntFilter<"estimasi_item"> | number
    id_produk?: IntFilter<"estimasi_item"> | number
    id_supplier?: IntFilter<"estimasi_item"> | number
    harga_beli?: DecimalFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"estimasi_item"> | number
  }

  export type estimasi_itemOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type estimasi_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: estimasi_itemWhereInput | estimasi_itemWhereInput[]
    OR?: estimasi_itemWhereInput[]
    NOT?: estimasi_itemWhereInput | estimasi_itemWhereInput[]
    tanggal?: DateTimeNullableFilter<"estimasi_item"> | Date | string | null
    id_estimasi?: IntFilter<"estimasi_item"> | number
    id_produk?: IntFilter<"estimasi_item"> | number
    id_supplier?: IntFilter<"estimasi_item"> | number
    harga_beli?: DecimalFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"estimasi_item"> | number
  }, "id">

  export type estimasi_itemOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    _count?: estimasi_itemCountOrderByAggregateInput
    _avg?: estimasi_itemAvgOrderByAggregateInput
    _max?: estimasi_itemMaxOrderByAggregateInput
    _min?: estimasi_itemMinOrderByAggregateInput
    _sum?: estimasi_itemSumOrderByAggregateInput
  }

  export type estimasi_itemScalarWhereWithAggregatesInput = {
    AND?: estimasi_itemScalarWhereWithAggregatesInput | estimasi_itemScalarWhereWithAggregatesInput[]
    OR?: estimasi_itemScalarWhereWithAggregatesInput[]
    NOT?: estimasi_itemScalarWhereWithAggregatesInput | estimasi_itemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estimasi_item"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"estimasi_item"> | Date | string | null
    id_estimasi?: IntWithAggregatesFilter<"estimasi_item"> | number
    id_produk?: IntWithAggregatesFilter<"estimasi_item"> | number
    id_supplier?: IntWithAggregatesFilter<"estimasi_item"> | number
    harga_beli?: DecimalWithAggregatesFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalWithAggregatesFilter<"estimasi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatWithAggregatesFilter<"estimasi_item"> | number
  }

  export type inventarisWhereInput = {
    AND?: inventarisWhereInput | inventarisWhereInput[]
    OR?: inventarisWhereInput[]
    NOT?: inventarisWhereInput | inventarisWhereInput[]
    id?: IntFilter<"inventaris"> | number
    jenis?: IntFilter<"inventaris"> | number
    nama?: StringFilter<"inventaris"> | string
    tanggal?: DateTimeNullableFilter<"inventaris"> | Date | string | null
    nilai?: DecimalFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    persen?: IntFilter<"inventaris"> | number
    sisa_2023?: DecimalFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeNullableFilter<"inventaris"> | Date | string | null
    modified?: DateTimeNullableFilter<"inventaris"> | Date | string | null
  }

  export type inventarisOrderByWithRelationInput = {
    id?: SortOrder
    jenis?: SortOrder
    nama?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
  }

  export type inventarisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: inventarisWhereInput | inventarisWhereInput[]
    OR?: inventarisWhereInput[]
    NOT?: inventarisWhereInput | inventarisWhereInput[]
    jenis?: IntFilter<"inventaris"> | number
    nama?: StringFilter<"inventaris"> | string
    tanggal?: DateTimeNullableFilter<"inventaris"> | Date | string | null
    nilai?: DecimalFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    persen?: IntFilter<"inventaris"> | number
    sisa_2023?: DecimalFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeNullableFilter<"inventaris"> | Date | string | null
    modified?: DateTimeNullableFilter<"inventaris"> | Date | string | null
  }, "id">

  export type inventarisOrderByWithAggregationInput = {
    id?: SortOrder
    jenis?: SortOrder
    nama?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
    _count?: inventarisCountOrderByAggregateInput
    _avg?: inventarisAvgOrderByAggregateInput
    _max?: inventarisMaxOrderByAggregateInput
    _min?: inventarisMinOrderByAggregateInput
    _sum?: inventarisSumOrderByAggregateInput
  }

  export type inventarisScalarWhereWithAggregatesInput = {
    AND?: inventarisScalarWhereWithAggregatesInput | inventarisScalarWhereWithAggregatesInput[]
    OR?: inventarisScalarWhereWithAggregatesInput[]
    NOT?: inventarisScalarWhereWithAggregatesInput | inventarisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inventaris"> | number
    jenis?: IntWithAggregatesFilter<"inventaris"> | number
    nama?: StringWithAggregatesFilter<"inventaris"> | string
    tanggal?: DateTimeNullableWithAggregatesFilter<"inventaris"> | Date | string | null
    nilai?: DecimalWithAggregatesFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    persen?: IntWithAggregatesFilter<"inventaris"> | number
    sisa_2023?: DecimalWithAggregatesFilter<"inventaris"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeNullableWithAggregatesFilter<"inventaris"> | Date | string | null
    modified?: DateTimeNullableWithAggregatesFilter<"inventaris"> | Date | string | null
  }

  export type pelunasan_pembelianWhereInput = {
    AND?: pelunasan_pembelianWhereInput | pelunasan_pembelianWhereInput[]
    OR?: pelunasan_pembelianWhereInput[]
    NOT?: pelunasan_pembelianWhereInput | pelunasan_pembelianWhereInput[]
    id?: IntFilter<"pelunasan_pembelian"> | number
    id_supplier?: IntFilter<"pelunasan_pembelian"> | number
    id_transaksi?: IntFilter<"pelunasan_pembelian"> | number
    tanggal?: DateTimeNullableFilter<"pelunasan_pembelian"> | Date | string | null
    jumlah?: DecimalFilter<"pelunasan_pembelian"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"pelunasan_pembelian"> | string
  }

  export type pelunasan_pembelianOrderByWithRelationInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    keterangan?: SortOrder
  }

  export type pelunasan_pembelianWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pelunasan_pembelianWhereInput | pelunasan_pembelianWhereInput[]
    OR?: pelunasan_pembelianWhereInput[]
    NOT?: pelunasan_pembelianWhereInput | pelunasan_pembelianWhereInput[]
    id_supplier?: IntFilter<"pelunasan_pembelian"> | number
    id_transaksi?: IntFilter<"pelunasan_pembelian"> | number
    tanggal?: DateTimeNullableFilter<"pelunasan_pembelian"> | Date | string | null
    jumlah?: DecimalFilter<"pelunasan_pembelian"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"pelunasan_pembelian"> | string
  }, "id">

  export type pelunasan_pembelianOrderByWithAggregationInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jumlah?: SortOrder
    keterangan?: SortOrder
    _count?: pelunasan_pembelianCountOrderByAggregateInput
    _avg?: pelunasan_pembelianAvgOrderByAggregateInput
    _max?: pelunasan_pembelianMaxOrderByAggregateInput
    _min?: pelunasan_pembelianMinOrderByAggregateInput
    _sum?: pelunasan_pembelianSumOrderByAggregateInput
  }

  export type pelunasan_pembelianScalarWhereWithAggregatesInput = {
    AND?: pelunasan_pembelianScalarWhereWithAggregatesInput | pelunasan_pembelianScalarWhereWithAggregatesInput[]
    OR?: pelunasan_pembelianScalarWhereWithAggregatesInput[]
    NOT?: pelunasan_pembelianScalarWhereWithAggregatesInput | pelunasan_pembelianScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pelunasan_pembelian"> | number
    id_supplier?: IntWithAggregatesFilter<"pelunasan_pembelian"> | number
    id_transaksi?: IntWithAggregatesFilter<"pelunasan_pembelian"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"pelunasan_pembelian"> | Date | string | null
    jumlah?: DecimalWithAggregatesFilter<"pelunasan_pembelian"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"pelunasan_pembelian"> | string
  }

  export type pemusnahanWhereInput = {
    AND?: pemusnahanWhereInput | pemusnahanWhereInput[]
    OR?: pemusnahanWhereInput[]
    NOT?: pemusnahanWhereInput | pemusnahanWhereInput[]
    id?: IntFilter<"pemusnahan"> | number
    tanggal?: DateTimeFilter<"pemusnahan"> | Date | string
    jumlah?: DecimalFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jangka?: IntFilter<"pemusnahan"> | number
    keterangan?: StringFilter<"pemusnahan"> | string
  }

  export type pemusnahanOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
    keterangan?: SortOrder
  }

  export type pemusnahanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pemusnahanWhereInput | pemusnahanWhereInput[]
    OR?: pemusnahanWhereInput[]
    NOT?: pemusnahanWhereInput | pemusnahanWhereInput[]
    tanggal?: DateTimeFilter<"pemusnahan"> | Date | string
    jumlah?: DecimalFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jangka?: IntFilter<"pemusnahan"> | number
    keterangan?: StringFilter<"pemusnahan"> | string
  }, "id">

  export type pemusnahanOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
    keterangan?: SortOrder
    _count?: pemusnahanCountOrderByAggregateInput
    _avg?: pemusnahanAvgOrderByAggregateInput
    _max?: pemusnahanMaxOrderByAggregateInput
    _min?: pemusnahanMinOrderByAggregateInput
    _sum?: pemusnahanSumOrderByAggregateInput
  }

  export type pemusnahanScalarWhereWithAggregatesInput = {
    AND?: pemusnahanScalarWhereWithAggregatesInput | pemusnahanScalarWhereWithAggregatesInput[]
    OR?: pemusnahanScalarWhereWithAggregatesInput[]
    NOT?: pemusnahanScalarWhereWithAggregatesInput | pemusnahanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pemusnahan"> | number
    tanggal?: DateTimeWithAggregatesFilter<"pemusnahan"> | Date | string
    jumlah?: DecimalWithAggregatesFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalWithAggregatesFilter<"pemusnahan"> | Decimal | DecimalJsLike | number | string
    jangka?: IntWithAggregatesFilter<"pemusnahan"> | number
    keterangan?: StringWithAggregatesFilter<"pemusnahan"> | string
  }

  export type produkWhereInput = {
    AND?: produkWhereInput | produkWhereInput[]
    OR?: produkWhereInput[]
    NOT?: produkWhereInput | produkWhereInput[]
    id?: IntFilter<"produk"> | number
    divisi?: IntFilter<"produk"> | number
    supplier?: IntFilter<"produk"> | number
    kode?: StringFilter<"produk"> | string
    nama?: StringFilter<"produk"> | string
    harga_beli?: DecimalFilter<"produk"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"produk"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"produk"> | number
    diskon?: IntFilter<"produk"> | number
    keterangan?: StringFilter<"produk"> | string
    status?: IntFilter<"produk"> | number
    created?: DateTimeFilter<"produk"> | Date | string
    modified?: DateTimeFilter<"produk"> | Date | string
  }

  export type produkOrderByWithRelationInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    keterangan?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type produkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produkWhereInput | produkWhereInput[]
    OR?: produkWhereInput[]
    NOT?: produkWhereInput | produkWhereInput[]
    divisi?: IntFilter<"produk"> | number
    supplier?: IntFilter<"produk"> | number
    kode?: StringFilter<"produk"> | string
    nama?: StringFilter<"produk"> | string
    harga_beli?: DecimalFilter<"produk"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"produk"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"produk"> | number
    diskon?: IntFilter<"produk"> | number
    keterangan?: StringFilter<"produk"> | string
    status?: IntFilter<"produk"> | number
    created?: DateTimeFilter<"produk"> | Date | string
    modified?: DateTimeFilter<"produk"> | Date | string
  }, "id">

  export type produkOrderByWithAggregationInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    keterangan?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
    _count?: produkCountOrderByAggregateInput
    _avg?: produkAvgOrderByAggregateInput
    _max?: produkMaxOrderByAggregateInput
    _min?: produkMinOrderByAggregateInput
    _sum?: produkSumOrderByAggregateInput
  }

  export type produkScalarWhereWithAggregatesInput = {
    AND?: produkScalarWhereWithAggregatesInput | produkScalarWhereWithAggregatesInput[]
    OR?: produkScalarWhereWithAggregatesInput[]
    NOT?: produkScalarWhereWithAggregatesInput | produkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produk"> | number
    divisi?: IntWithAggregatesFilter<"produk"> | number
    supplier?: IntWithAggregatesFilter<"produk"> | number
    kode?: StringWithAggregatesFilter<"produk"> | string
    nama?: StringWithAggregatesFilter<"produk"> | string
    harga_beli?: DecimalWithAggregatesFilter<"produk"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalWithAggregatesFilter<"produk"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatWithAggregatesFilter<"produk"> | number
    diskon?: IntWithAggregatesFilter<"produk"> | number
    keterangan?: StringWithAggregatesFilter<"produk"> | string
    status?: IntWithAggregatesFilter<"produk"> | number
    created?: DateTimeWithAggregatesFilter<"produk"> | Date | string
    modified?: DateTimeWithAggregatesFilter<"produk"> | Date | string
  }

  export type produk_hargaWhereInput = {
    AND?: produk_hargaWhereInput | produk_hargaWhereInput[]
    OR?: produk_hargaWhereInput[]
    NOT?: produk_hargaWhereInput | produk_hargaWhereInput[]
    id?: IntFilter<"produk_harga"> | number
    id_produk?: IntFilter<"produk_harga"> | number
    tanggal?: DateTimeNullableFilter<"produk_harga"> | Date | string | null
    harga_beli?: FloatFilter<"produk_harga"> | number
    harga_jual?: FloatFilter<"produk_harga"> | number
  }

  export type produk_hargaOrderByWithRelationInput = {
    id?: SortOrder
    id_produk?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type produk_hargaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: produk_hargaWhereInput | produk_hargaWhereInput[]
    OR?: produk_hargaWhereInput[]
    NOT?: produk_hargaWhereInput | produk_hargaWhereInput[]
    id_produk?: IntFilter<"produk_harga"> | number
    tanggal?: DateTimeNullableFilter<"produk_harga"> | Date | string | null
    harga_beli?: FloatFilter<"produk_harga"> | number
    harga_jual?: FloatFilter<"produk_harga"> | number
  }, "id">

  export type produk_hargaOrderByWithAggregationInput = {
    id?: SortOrder
    id_produk?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    _count?: produk_hargaCountOrderByAggregateInput
    _avg?: produk_hargaAvgOrderByAggregateInput
    _max?: produk_hargaMaxOrderByAggregateInput
    _min?: produk_hargaMinOrderByAggregateInput
    _sum?: produk_hargaSumOrderByAggregateInput
  }

  export type produk_hargaScalarWhereWithAggregatesInput = {
    AND?: produk_hargaScalarWhereWithAggregatesInput | produk_hargaScalarWhereWithAggregatesInput[]
    OR?: produk_hargaScalarWhereWithAggregatesInput[]
    NOT?: produk_hargaScalarWhereWithAggregatesInput | produk_hargaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"produk_harga"> | number
    id_produk?: IntWithAggregatesFilter<"produk_harga"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"produk_harga"> | Date | string | null
    harga_beli?: FloatWithAggregatesFilter<"produk_harga"> | number
    harga_jual?: FloatWithAggregatesFilter<"produk_harga"> | number
  }

  export type rapbWhereInput = {
    AND?: rapbWhereInput | rapbWhereInput[]
    OR?: rapbWhereInput[]
    NOT?: rapbWhereInput | rapbWhereInput[]
    no?: IntFilter<"rapb"> | number
    tahun?: IntFilter<"rapb"> | number
    hasil_usaha?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
  }

  export type rapbOrderByWithRelationInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type rapbWhereUniqueInput = Prisma.AtLeast<{
    no?: number
    AND?: rapbWhereInput | rapbWhereInput[]
    OR?: rapbWhereInput[]
    NOT?: rapbWhereInput | rapbWhereInput[]
    tahun?: IntFilter<"rapb"> | number
    hasil_usaha?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFilter<"rapb"> | Decimal | DecimalJsLike | number | string
  }, "no">

  export type rapbOrderByWithAggregationInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
    _count?: rapbCountOrderByAggregateInput
    _avg?: rapbAvgOrderByAggregateInput
    _max?: rapbMaxOrderByAggregateInput
    _min?: rapbMinOrderByAggregateInput
    _sum?: rapbSumOrderByAggregateInput
  }

  export type rapbScalarWhereWithAggregatesInput = {
    AND?: rapbScalarWhereWithAggregatesInput | rapbScalarWhereWithAggregatesInput[]
    OR?: rapbScalarWhereWithAggregatesInput[]
    NOT?: rapbScalarWhereWithAggregatesInput | rapbScalarWhereWithAggregatesInput[]
    no?: IntWithAggregatesFilter<"rapb"> | number
    tahun?: IntWithAggregatesFilter<"rapb"> | number
    hasil_usaha?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalWithAggregatesFilter<"rapb"> | Decimal | DecimalJsLike | number | string
  }

  export type saldo_tokoWhereInput = {
    AND?: saldo_tokoWhereInput | saldo_tokoWhereInput[]
    OR?: saldo_tokoWhereInput[]
    NOT?: saldo_tokoWhereInput | saldo_tokoWhereInput[]
    id?: IntFilter<"saldo_toko"> | number
    jenis?: IntFilter<"saldo_toko"> | number
    id_transaksi?: IntFilter<"saldo_toko"> | number
    tanggal?: DateTimeNullableFilter<"saldo_toko"> | Date | string | null
    debet?: FloatFilter<"saldo_toko"> | number
    kredit?: FloatFilter<"saldo_toko"> | number
    saldo?: FloatFilter<"saldo_toko"> | number
    keterangan?: StringFilter<"saldo_toko"> | string
  }

  export type saldo_tokoOrderByWithRelationInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
    keterangan?: SortOrder
  }

  export type saldo_tokoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saldo_tokoWhereInput | saldo_tokoWhereInput[]
    OR?: saldo_tokoWhereInput[]
    NOT?: saldo_tokoWhereInput | saldo_tokoWhereInput[]
    jenis?: IntFilter<"saldo_toko"> | number
    id_transaksi?: IntFilter<"saldo_toko"> | number
    tanggal?: DateTimeNullableFilter<"saldo_toko"> | Date | string | null
    debet?: FloatFilter<"saldo_toko"> | number
    kredit?: FloatFilter<"saldo_toko"> | number
    saldo?: FloatFilter<"saldo_toko"> | number
    keterangan?: StringFilter<"saldo_toko"> | string
  }, "id">

  export type saldo_tokoOrderByWithAggregationInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
    keterangan?: SortOrder
    _count?: saldo_tokoCountOrderByAggregateInput
    _avg?: saldo_tokoAvgOrderByAggregateInput
    _max?: saldo_tokoMaxOrderByAggregateInput
    _min?: saldo_tokoMinOrderByAggregateInput
    _sum?: saldo_tokoSumOrderByAggregateInput
  }

  export type saldo_tokoScalarWhereWithAggregatesInput = {
    AND?: saldo_tokoScalarWhereWithAggregatesInput | saldo_tokoScalarWhereWithAggregatesInput[]
    OR?: saldo_tokoScalarWhereWithAggregatesInput[]
    NOT?: saldo_tokoScalarWhereWithAggregatesInput | saldo_tokoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saldo_toko"> | number
    jenis?: IntWithAggregatesFilter<"saldo_toko"> | number
    id_transaksi?: IntWithAggregatesFilter<"saldo_toko"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"saldo_toko"> | Date | string | null
    debet?: FloatWithAggregatesFilter<"saldo_toko"> | number
    kredit?: FloatWithAggregatesFilter<"saldo_toko"> | number
    saldo?: FloatWithAggregatesFilter<"saldo_toko"> | number
    keterangan?: StringWithAggregatesFilter<"saldo_toko"> | string
  }

  export type shu_mutasiWhereInput = {
    AND?: shu_mutasiWhereInput | shu_mutasiWhereInput[]
    OR?: shu_mutasiWhereInput[]
    NOT?: shu_mutasiWhereInput | shu_mutasiWhereInput[]
    id?: IntFilter<"shu_mutasi"> | number
    tahun_shu?: IntFilter<"shu_mutasi"> | number
    tanggal?: DateTimeFilter<"shu_mutasi"> | Date | string
    debet?: DecimalFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"shu_mutasi"> | string
  }

  export type shu_mutasiOrderByWithRelationInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type shu_mutasiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shu_mutasiWhereInput | shu_mutasiWhereInput[]
    OR?: shu_mutasiWhereInput[]
    NOT?: shu_mutasiWhereInput | shu_mutasiWhereInput[]
    tahun_shu?: IntFilter<"shu_mutasi"> | number
    tanggal?: DateTimeFilter<"shu_mutasi"> | Date | string
    debet?: DecimalFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"shu_mutasi"> | string
  }, "id">

  export type shu_mutasiOrderByWithAggregationInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    _count?: shu_mutasiCountOrderByAggregateInput
    _avg?: shu_mutasiAvgOrderByAggregateInput
    _max?: shu_mutasiMaxOrderByAggregateInput
    _min?: shu_mutasiMinOrderByAggregateInput
    _sum?: shu_mutasiSumOrderByAggregateInput
  }

  export type shu_mutasiScalarWhereWithAggregatesInput = {
    AND?: shu_mutasiScalarWhereWithAggregatesInput | shu_mutasiScalarWhereWithAggregatesInput[]
    OR?: shu_mutasiScalarWhereWithAggregatesInput[]
    NOT?: shu_mutasiScalarWhereWithAggregatesInput | shu_mutasiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"shu_mutasi"> | number
    tahun_shu?: IntWithAggregatesFilter<"shu_mutasi"> | number
    tanggal?: DateTimeWithAggregatesFilter<"shu_mutasi"> | Date | string
    debet?: DecimalWithAggregatesFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalWithAggregatesFilter<"shu_mutasi"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"shu_mutasi"> | string
  }

  export type supplierWhereInput = {
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    id?: IntFilter<"supplier"> | number
    kode?: StringFilter<"supplier"> | string
    nama?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    pemilik?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    kredit?: DecimalFilter<"supplier"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeFilter<"supplier"> | Date | string
    modified?: DateTimeFilter<"supplier"> | Date | string
  }

  export type supplierOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    pemilik?: SortOrder
    kontak?: SortOrder
    kredit?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type supplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplierWhereInput | supplierWhereInput[]
    OR?: supplierWhereInput[]
    NOT?: supplierWhereInput | supplierWhereInput[]
    kode?: StringFilter<"supplier"> | string
    nama?: StringFilter<"supplier"> | string
    alamat?: StringFilter<"supplier"> | string
    pemilik?: StringFilter<"supplier"> | string
    kontak?: StringFilter<"supplier"> | string
    kredit?: DecimalFilter<"supplier"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeFilter<"supplier"> | Date | string
    modified?: DateTimeFilter<"supplier"> | Date | string
  }, "id">

  export type supplierOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    pemilik?: SortOrder
    kontak?: SortOrder
    kredit?: SortOrder
    created?: SortOrder
    modified?: SortOrder
    _count?: supplierCountOrderByAggregateInput
    _avg?: supplierAvgOrderByAggregateInput
    _max?: supplierMaxOrderByAggregateInput
    _min?: supplierMinOrderByAggregateInput
    _sum?: supplierSumOrderByAggregateInput
  }

  export type supplierScalarWhereWithAggregatesInput = {
    AND?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    OR?: supplierScalarWhereWithAggregatesInput[]
    NOT?: supplierScalarWhereWithAggregatesInput | supplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplier"> | number
    kode?: StringWithAggregatesFilter<"supplier"> | string
    nama?: StringWithAggregatesFilter<"supplier"> | string
    alamat?: StringWithAggregatesFilter<"supplier"> | string
    pemilik?: StringWithAggregatesFilter<"supplier"> | string
    kontak?: StringWithAggregatesFilter<"supplier"> | string
    kredit?: DecimalWithAggregatesFilter<"supplier"> | Decimal | DecimalJsLike | number | string
    created?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
    modified?: DateTimeWithAggregatesFilter<"supplier"> | Date | string
  }

  export type supplier_kreditWhereInput = {
    AND?: supplier_kreditWhereInput | supplier_kreditWhereInput[]
    OR?: supplier_kreditWhereInput[]
    NOT?: supplier_kreditWhereInput | supplier_kreditWhereInput[]
    id?: IntFilter<"supplier_kredit"> | number
    id_supplier?: IntFilter<"supplier_kredit"> | number
    id_transaksi?: IntFilter<"supplier_kredit"> | number
    ex_bukti?: StringFilter<"supplier_kredit"> | string
    tanggal?: DateTimeNullableFilter<"supplier_kredit"> | Date | string | null
    debet?: DecimalFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"supplier_kredit"> | string
  }

  export type supplier_kreditOrderByWithRelationInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type supplier_kreditWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: supplier_kreditWhereInput | supplier_kreditWhereInput[]
    OR?: supplier_kreditWhereInput[]
    NOT?: supplier_kreditWhereInput | supplier_kreditWhereInput[]
    id_supplier?: IntFilter<"supplier_kredit"> | number
    id_transaksi?: IntFilter<"supplier_kredit"> | number
    ex_bukti?: StringFilter<"supplier_kredit"> | string
    tanggal?: DateTimeNullableFilter<"supplier_kredit"> | Date | string | null
    debet?: DecimalFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"supplier_kredit"> | string
  }, "id">

  export type supplier_kreditOrderByWithAggregationInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    _count?: supplier_kreditCountOrderByAggregateInput
    _avg?: supplier_kreditAvgOrderByAggregateInput
    _max?: supplier_kreditMaxOrderByAggregateInput
    _min?: supplier_kreditMinOrderByAggregateInput
    _sum?: supplier_kreditSumOrderByAggregateInput
  }

  export type supplier_kreditScalarWhereWithAggregatesInput = {
    AND?: supplier_kreditScalarWhereWithAggregatesInput | supplier_kreditScalarWhereWithAggregatesInput[]
    OR?: supplier_kreditScalarWhereWithAggregatesInput[]
    NOT?: supplier_kreditScalarWhereWithAggregatesInput | supplier_kreditScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"supplier_kredit"> | number
    id_supplier?: IntWithAggregatesFilter<"supplier_kredit"> | number
    id_transaksi?: IntWithAggregatesFilter<"supplier_kredit"> | number
    ex_bukti?: StringWithAggregatesFilter<"supplier_kredit"> | string
    tanggal?: DateTimeNullableWithAggregatesFilter<"supplier_kredit"> | Date | string | null
    debet?: DecimalWithAggregatesFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalWithAggregatesFilter<"supplier_kredit"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"supplier_kredit"> | string
  }

  export type transaksiWhereInput = {
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    id?: IntFilter<"transaksi"> | number
    kode?: StringFilter<"transaksi"> | string
    kode_ex?: StringFilter<"transaksi"> | string
    kode_2?: StringFilter<"transaksi"> | string
    tanggal?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    jenis?: IntFilter<"transaksi"> | number
    sumber?: IntFilter<"transaksi"> | number
    jumlah?: FloatFilter<"transaksi"> | number
    produk?: IntFilter<"transaksi"> | number
    total_beli?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFilter<"transaksi"> | number
    diskon_persen?: IntFilter<"transaksi"> | number
    diskon_total?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    kredit?: IntFilter<"transaksi"> | number
    keterangan?: StringFilter<"transaksi"> | string
    anggota?: IntFilter<"transaksi"> | number
    admin?: IntFilter<"transaksi"> | number
    status?: IntFilter<"transaksi"> | number
    created?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    modified?: DateTimeNullableFilter<"transaksi"> | Date | string | null
  }

  export type transaksiOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    kode_ex?: SortOrder
    kode_2?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
  }

  export type transaksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    kode?: StringFilter<"transaksi"> | string
    kode_ex?: StringFilter<"transaksi"> | string
    kode_2?: StringFilter<"transaksi"> | string
    tanggal?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    jenis?: IntFilter<"transaksi"> | number
    sumber?: IntFilter<"transaksi"> | number
    jumlah?: FloatFilter<"transaksi"> | number
    produk?: IntFilter<"transaksi"> | number
    total_beli?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFilter<"transaksi"> | number
    diskon_persen?: IntFilter<"transaksi"> | number
    diskon_total?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    kredit?: IntFilter<"transaksi"> | number
    keterangan?: StringFilter<"transaksi"> | string
    anggota?: IntFilter<"transaksi"> | number
    admin?: IntFilter<"transaksi"> | number
    status?: IntFilter<"transaksi"> | number
    created?: DateTimeNullableFilter<"transaksi"> | Date | string | null
    modified?: DateTimeNullableFilter<"transaksi"> | Date | string | null
  }, "id">

  export type transaksiOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    kode_ex?: SortOrder
    kode_2?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
    created?: SortOrderInput | SortOrder
    modified?: SortOrderInput | SortOrder
    _count?: transaksiCountOrderByAggregateInput
    _avg?: transaksiAvgOrderByAggregateInput
    _max?: transaksiMaxOrderByAggregateInput
    _min?: transaksiMinOrderByAggregateInput
    _sum?: transaksiSumOrderByAggregateInput
  }

  export type transaksiScalarWhereWithAggregatesInput = {
    AND?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    OR?: transaksiScalarWhereWithAggregatesInput[]
    NOT?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaksi"> | number
    kode?: StringWithAggregatesFilter<"transaksi"> | string
    kode_ex?: StringWithAggregatesFilter<"transaksi"> | string
    kode_2?: StringWithAggregatesFilter<"transaksi"> | string
    tanggal?: DateTimeNullableWithAggregatesFilter<"transaksi"> | Date | string | null
    jenis?: IntWithAggregatesFilter<"transaksi"> | number
    sumber?: IntWithAggregatesFilter<"transaksi"> | number
    jumlah?: FloatWithAggregatesFilter<"transaksi"> | number
    produk?: IntWithAggregatesFilter<"transaksi"> | number
    total_beli?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatWithAggregatesFilter<"transaksi"> | number
    diskon_persen?: IntWithAggregatesFilter<"transaksi"> | number
    diskon_total?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    bayar?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    kredit?: IntWithAggregatesFilter<"transaksi"> | number
    keterangan?: StringWithAggregatesFilter<"transaksi"> | string
    anggota?: IntWithAggregatesFilter<"transaksi"> | number
    admin?: IntWithAggregatesFilter<"transaksi"> | number
    status?: IntWithAggregatesFilter<"transaksi"> | number
    created?: DateTimeNullableWithAggregatesFilter<"transaksi"> | Date | string | null
    modified?: DateTimeNullableWithAggregatesFilter<"transaksi"> | Date | string | null
  }

  export type transaksi_itemWhereInput = {
    AND?: transaksi_itemWhereInput | transaksi_itemWhereInput[]
    OR?: transaksi_itemWhereInput[]
    NOT?: transaksi_itemWhereInput | transaksi_itemWhereInput[]
    id?: IntFilter<"transaksi_item"> | number
    tanggal?: DateTimeNullableFilter<"transaksi_item"> | Date | string | null
    jenis?: IntFilter<"transaksi_item"> | number
    id_transaksi?: IntFilter<"transaksi_item"> | number
    id_produk?: IntFilter<"transaksi_item"> | number
    harga_beli?: DecimalFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"transaksi_item"> | number
    diskon?: IntFilter<"transaksi_item"> | number
  }

  export type transaksi_itemOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_itemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transaksi_itemWhereInput | transaksi_itemWhereInput[]
    OR?: transaksi_itemWhereInput[]
    NOT?: transaksi_itemWhereInput | transaksi_itemWhereInput[]
    tanggal?: DateTimeNullableFilter<"transaksi_item"> | Date | string | null
    jenis?: IntFilter<"transaksi_item"> | number
    id_transaksi?: IntFilter<"transaksi_item"> | number
    id_produk?: IntFilter<"transaksi_item"> | number
    harga_beli?: DecimalFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFilter<"transaksi_item"> | number
    diskon?: IntFilter<"transaksi_item"> | number
  }, "id">

  export type transaksi_itemOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrderInput | SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    _count?: transaksi_itemCountOrderByAggregateInput
    _avg?: transaksi_itemAvgOrderByAggregateInput
    _max?: transaksi_itemMaxOrderByAggregateInput
    _min?: transaksi_itemMinOrderByAggregateInput
    _sum?: transaksi_itemSumOrderByAggregateInput
  }

  export type transaksi_itemScalarWhereWithAggregatesInput = {
    AND?: transaksi_itemScalarWhereWithAggregatesInput | transaksi_itemScalarWhereWithAggregatesInput[]
    OR?: transaksi_itemScalarWhereWithAggregatesInput[]
    NOT?: transaksi_itemScalarWhereWithAggregatesInput | transaksi_itemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaksi_item"> | number
    tanggal?: DateTimeNullableWithAggregatesFilter<"transaksi_item"> | Date | string | null
    jenis?: IntWithAggregatesFilter<"transaksi_item"> | number
    id_transaksi?: IntWithAggregatesFilter<"transaksi_item"> | number
    id_produk?: IntWithAggregatesFilter<"transaksi_item"> | number
    harga_beli?: DecimalWithAggregatesFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalWithAggregatesFilter<"transaksi_item"> | Decimal | DecimalJsLike | number | string
    jumlah?: FloatWithAggregatesFilter<"transaksi_item"> | number
    diskon?: IntWithAggregatesFilter<"transaksi_item"> | number
  }

  export type transaksi_jenisWhereInput = {
    AND?: transaksi_jenisWhereInput | transaksi_jenisWhereInput[]
    OR?: transaksi_jenisWhereInput[]
    NOT?: transaksi_jenisWhereInput | transaksi_jenisWhereInput[]
    id?: IntFilter<"transaksi_jenis"> | number
    nama?: StringFilter<"transaksi_jenis"> | string
    tipe?: IntFilter<"transaksi_jenis"> | number
    fix?: IntFilter<"transaksi_jenis"> | number
  }

  export type transaksi_jenisOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type transaksi_jenisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transaksi_jenisWhereInput | transaksi_jenisWhereInput[]
    OR?: transaksi_jenisWhereInput[]
    NOT?: transaksi_jenisWhereInput | transaksi_jenisWhereInput[]
    nama?: StringFilter<"transaksi_jenis"> | string
    tipe?: IntFilter<"transaksi_jenis"> | number
    fix?: IntFilter<"transaksi_jenis"> | number
  }, "id">

  export type transaksi_jenisOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
    _count?: transaksi_jenisCountOrderByAggregateInput
    _avg?: transaksi_jenisAvgOrderByAggregateInput
    _max?: transaksi_jenisMaxOrderByAggregateInput
    _min?: transaksi_jenisMinOrderByAggregateInput
    _sum?: transaksi_jenisSumOrderByAggregateInput
  }

  export type transaksi_jenisScalarWhereWithAggregatesInput = {
    AND?: transaksi_jenisScalarWhereWithAggregatesInput | transaksi_jenisScalarWhereWithAggregatesInput[]
    OR?: transaksi_jenisScalarWhereWithAggregatesInput[]
    NOT?: transaksi_jenisScalarWhereWithAggregatesInput | transaksi_jenisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaksi_jenis"> | number
    nama?: StringWithAggregatesFilter<"transaksi_jenis"> | string
    tipe?: IntWithAggregatesFilter<"transaksi_jenis"> | number
    fix?: IntWithAggregatesFilter<"transaksi_jenis"> | number
  }

  export type tujuanWhereInput = {
    AND?: tujuanWhereInput | tujuanWhereInput[]
    OR?: tujuanWhereInput[]
    NOT?: tujuanWhereInput | tujuanWhereInput[]
    id?: IntFilter<"tujuan"> | number
    nama?: StringFilter<"tujuan"> | string
  }

  export type tujuanOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type tujuanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tujuanWhereInput | tujuanWhereInput[]
    OR?: tujuanWhereInput[]
    NOT?: tujuanWhereInput | tujuanWhereInput[]
    nama?: StringFilter<"tujuan"> | string
  }, "id">

  export type tujuanOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    _count?: tujuanCountOrderByAggregateInput
    _avg?: tujuanAvgOrderByAggregateInput
    _max?: tujuanMaxOrderByAggregateInput
    _min?: tujuanMinOrderByAggregateInput
    _sum?: tujuanSumOrderByAggregateInput
  }

  export type tujuanScalarWhereWithAggregatesInput = {
    AND?: tujuanScalarWhereWithAggregatesInput | tujuanScalarWhereWithAggregatesInput[]
    OR?: tujuanScalarWhereWithAggregatesInput[]
    NOT?: tujuanScalarWhereWithAggregatesInput | tujuanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tujuan"> | number
    nama?: StringWithAggregatesFilter<"tujuan"> | string
  }

  export type tutup_kasirWhereInput = {
    AND?: tutup_kasirWhereInput | tutup_kasirWhereInput[]
    OR?: tutup_kasirWhereInput[]
    NOT?: tutup_kasirWhereInput | tutup_kasirWhereInput[]
    id?: IntFilter<"tutup_kasir"> | number
    tanggal?: DateTimeFilter<"tutup_kasir"> | Date | string
    shift?: IntFilter<"tutup_kasir"> | number
    kasir?: IntFilter<"tutup_kasir"> | number
    tunai?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    bon?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    struk?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type tutup_kasirWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tutup_kasirWhereInput | tutup_kasirWhereInput[]
    OR?: tutup_kasirWhereInput[]
    NOT?: tutup_kasirWhereInput | tutup_kasirWhereInput[]
    tanggal?: DateTimeFilter<"tutup_kasir"> | Date | string
    shift?: IntFilter<"tutup_kasir"> | number
    kasir?: IntFilter<"tutup_kasir"> | number
    tunai?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    bon?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    struk?: DecimalFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type tutup_kasirOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
    _count?: tutup_kasirCountOrderByAggregateInput
    _avg?: tutup_kasirAvgOrderByAggregateInput
    _max?: tutup_kasirMaxOrderByAggregateInput
    _min?: tutup_kasirMinOrderByAggregateInput
    _sum?: tutup_kasirSumOrderByAggregateInput
  }

  export type tutup_kasirScalarWhereWithAggregatesInput = {
    AND?: tutup_kasirScalarWhereWithAggregatesInput | tutup_kasirScalarWhereWithAggregatesInput[]
    OR?: tutup_kasirScalarWhereWithAggregatesInput[]
    NOT?: tutup_kasirScalarWhereWithAggregatesInput | tutup_kasirScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tutup_kasir"> | number
    tanggal?: DateTimeWithAggregatesFilter<"tutup_kasir"> | Date | string
    shift?: IntWithAggregatesFilter<"tutup_kasir"> | number
    kasir?: IntWithAggregatesFilter<"tutup_kasir"> | number
    tunai?: DecimalWithAggregatesFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    bon?: DecimalWithAggregatesFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
    struk?: DecimalWithAggregatesFilter<"tutup_kasir"> | Decimal | DecimalJsLike | number | string
  }

  export type utang_spWhereInput = {
    AND?: utang_spWhereInput | utang_spWhereInput[]
    OR?: utang_spWhereInput[]
    NOT?: utang_spWhereInput | utang_spWhereInput[]
    id?: IntFilter<"utang_sp"> | number
    tanggal?: DateTimeFilter<"utang_sp"> | Date | string
    debet?: DecimalFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"utang_sp"> | string
  }

  export type utang_spOrderByWithRelationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type utang_spWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: utang_spWhereInput | utang_spWhereInput[]
    OR?: utang_spWhereInput[]
    NOT?: utang_spWhereInput | utang_spWhereInput[]
    tanggal?: DateTimeFilter<"utang_sp"> | Date | string
    debet?: DecimalFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringFilter<"utang_sp"> | string
  }, "id">

  export type utang_spOrderByWithAggregationInput = {
    id?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    _count?: utang_spCountOrderByAggregateInput
    _avg?: utang_spAvgOrderByAggregateInput
    _max?: utang_spMaxOrderByAggregateInput
    _min?: utang_spMinOrderByAggregateInput
    _sum?: utang_spSumOrderByAggregateInput
  }

  export type utang_spScalarWhereWithAggregatesInput = {
    AND?: utang_spScalarWhereWithAggregatesInput | utang_spScalarWhereWithAggregatesInput[]
    OR?: utang_spScalarWhereWithAggregatesInput[]
    NOT?: utang_spScalarWhereWithAggregatesInput | utang_spScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"utang_sp"> | number
    tanggal?: DateTimeWithAggregatesFilter<"utang_sp"> | Date | string
    debet?: DecimalWithAggregatesFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    kredit?: DecimalWithAggregatesFilter<"utang_sp"> | Decimal | DecimalJsLike | number | string
    keterangan?: StringWithAggregatesFilter<"utang_sp"> | string
  }

  export type adminCreateInput = {
    bagian: number
    username: string
    password: string
    nama: string
    type?: string
    level?: number
  }

  export type adminUncheckedCreateInput = {
    id?: number
    bagian: number
    username: string
    password: string
    nama: string
    type?: string
    level?: number
  }

  export type adminUpdateInput = {
    bagian?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bagian?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type adminCreateManyInput = {
    id?: number
    bagian: number
    username: string
    password: string
    nama: string
    type?: string
    level?: number
  }

  export type adminUpdateManyMutationInput = {
    bagian?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bagian?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type anggotaCreateInput = {
    kode?: string
    nama?: string
    alamat: string
    telp?: string
    kredit_limit?: Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: Decimal | DecimalJsLike | number | string
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type anggotaUncheckedCreateInput = {
    id?: number
    kode?: string
    nama?: string
    alamat: string
    telp?: string
    kredit_limit?: Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: Decimal | DecimalJsLike | number | string
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type anggotaUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    kredit_limit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type anggotaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    kredit_limit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type anggotaCreateManyInput = {
    id?: number
    kode?: string
    nama?: string
    alamat: string
    telp?: string
    kredit_limit?: Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: Decimal | DecimalJsLike | number | string
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type anggotaUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    kredit_limit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type anggotaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    kredit_limit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit_pinjaman?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type anggota_kreditCreateInput = {
    id_anggota?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type anggota_kreditUncheckedCreateInput = {
    id?: number
    id_anggota?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type anggota_kreditUpdateInput = {
    id_anggota?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type anggota_kreditUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_anggota?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type anggota_kreditCreateManyInput = {
    id?: number
    id_anggota?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type anggota_kreditUpdateManyMutationInput = {
    id_anggota?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type anggota_kreditUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_anggota?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type bagianCreateInput = {
    nama: string
  }

  export type bagianUncheckedCreateInput = {
    id?: number
    nama: string
  }

  export type bagianUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bagianUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bagianCreateManyInput = {
    id?: number
    nama: string
  }

  export type bagianUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bagianUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bankCreateInput = {
    kode: string
    nama: string
    saldo: Decimal | DecimalJsLike | number | string
  }

  export type bankUncheckedCreateInput = {
    id?: number
    kode: string
    nama: string
    saldo: Decimal | DecimalJsLike | number | string
  }

  export type bankUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type bankUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type bankCreateManyInput = {
    id?: number
    kode: string
    nama: string
    saldo: Decimal | DecimalJsLike | number | string
  }

  export type bankUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type bankUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    saldo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type bank_mutasiCreateInput = {
    tanggal: Date | string
    id_bank: number
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    debet2?: Decimal | DecimalJsLike | number | string
    kredit2?: Decimal | DecimalJsLike | number | string
    adm?: Decimal | DecimalJsLike | number | string
    pajak?: Decimal | DecimalJsLike | number | string
    jasa?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type bank_mutasiUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    id_bank: number
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    debet2?: Decimal | DecimalJsLike | number | string
    kredit2?: Decimal | DecimalJsLike | number | string
    adm?: Decimal | DecimalJsLike | number | string
    pajak?: Decimal | DecimalJsLike | number | string
    jasa?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type bank_mutasiUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    id_bank?: IntFieldUpdateOperationsInput | number
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type bank_mutasiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    id_bank?: IntFieldUpdateOperationsInput | number
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type bank_mutasiCreateManyInput = {
    id?: number
    tanggal: Date | string
    id_bank: number
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    debet2?: Decimal | DecimalJsLike | number | string
    kredit2?: Decimal | DecimalJsLike | number | string
    adm?: Decimal | DecimalJsLike | number | string
    pajak?: Decimal | DecimalJsLike | number | string
    jasa?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type bank_mutasiUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    id_bank?: IntFieldUpdateOperationsInput | number
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type bank_mutasiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    id_bank?: IntFieldUpdateOperationsInput | number
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    debet2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pajak?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type bayarCreateInput = {
    nama: string
  }

  export type bayarUncheckedCreateInput = {
    id?: number
    nama: string
  }

  export type bayarUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bayarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bayarCreateManyInput = {
    id?: number
    nama: string
  }

  export type bayarUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type bayarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type beban_operasionalCreateInput = {
    tanggal?: Date | string | null
    keterangan: string
    jumlah?: number
  }

  export type beban_operasionalUncheckedCreateInput = {
    id?: number
    tanggal?: Date | string | null
    keterangan: string
    jumlah?: number
  }

  export type beban_operasionalUpdateInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: StringFieldUpdateOperationsInput | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type beban_operasionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: StringFieldUpdateOperationsInput | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type beban_operasionalCreateManyInput = {
    id?: number
    tanggal?: Date | string | null
    keterangan: string
    jumlah?: number
  }

  export type beban_operasionalUpdateManyMutationInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: StringFieldUpdateOperationsInput | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type beban_operasionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    keterangan?: StringFieldUpdateOperationsInput | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type cash_in_outCreateInput = {
    tanggal: Date | string
    jenis: number
    detail?: number
    input: Decimal | DecimalJsLike | number | string
    output: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type cash_in_outUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    jenis: number
    detail?: number
    input: Decimal | DecimalJsLike | number | string
    output: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type cash_in_outUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis?: IntFieldUpdateOperationsInput | number
    detail?: IntFieldUpdateOperationsInput | number
    input?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    output?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type cash_in_outUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis?: IntFieldUpdateOperationsInput | number
    detail?: IntFieldUpdateOperationsInput | number
    input?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    output?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type cash_in_outCreateManyInput = {
    id?: number
    tanggal: Date | string
    jenis: number
    detail?: number
    input: Decimal | DecimalJsLike | number | string
    output: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type cash_in_outUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis?: IntFieldUpdateOperationsInput | number
    detail?: IntFieldUpdateOperationsInput | number
    input?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    output?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type cash_in_outUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jenis?: IntFieldUpdateOperationsInput | number
    detail?: IntFieldUpdateOperationsInput | number
    input?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    output?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type cash_jenisCreateInput = {
    parent?: number
    nama: string
    nilai: number
  }

  export type cash_jenisUncheckedCreateInput = {
    id?: number
    parent?: number
    nama: string
    nilai: number
  }

  export type cash_jenisUpdateInput = {
    parent?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nilai?: IntFieldUpdateOperationsInput | number
  }

  export type cash_jenisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nilai?: IntFieldUpdateOperationsInput | number
  }

  export type cash_jenisCreateManyInput = {
    id?: number
    parent?: number
    nama: string
    nilai: number
  }

  export type cash_jenisUpdateManyMutationInput = {
    parent?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nilai?: IntFieldUpdateOperationsInput | number
  }

  export type cash_jenisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    nilai?: IntFieldUpdateOperationsInput | number
  }

  export type configCreateInput = {
    nama: string
    alamat: string
    telp: string
    bulat: number
    versi: number
    shortcut: number
    modified?: Date | string | null
  }

  export type configUncheckedCreateInput = {
    id?: number
    nama: string
    alamat: string
    telp: string
    bulat: number
    versi: number
    shortcut: number
    modified?: Date | string | null
  }

  export type configUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    bulat?: IntFieldUpdateOperationsInput | number
    versi?: IntFieldUpdateOperationsInput | number
    shortcut?: IntFieldUpdateOperationsInput | number
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    bulat?: IntFieldUpdateOperationsInput | number
    versi?: IntFieldUpdateOperationsInput | number
    shortcut?: IntFieldUpdateOperationsInput | number
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configCreateManyInput = {
    id?: number
    nama: string
    alamat: string
    telp: string
    bulat: number
    versi: number
    shortcut: number
    modified?: Date | string | null
  }

  export type configUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    bulat?: IntFieldUpdateOperationsInput | number
    versi?: IntFieldUpdateOperationsInput | number
    shortcut?: IntFieldUpdateOperationsInput | number
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type configUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    telp?: StringFieldUpdateOperationsInput | string
    bulat?: IntFieldUpdateOperationsInput | number
    versi?: IntFieldUpdateOperationsInput | number
    shortcut?: IntFieldUpdateOperationsInput | number
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type danaCreateInput = {
    jenis?: number
    kode: string
    nama: string
    jumlah?: Decimal | DecimalJsLike | number | string
  }

  export type danaUncheckedCreateInput = {
    id?: number
    jenis?: number
    kode: string
    nama: string
    jumlah?: Decimal | DecimalJsLike | number | string
  }

  export type danaUpdateInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type danaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type danaCreateManyInput = {
    id?: number
    jenis?: number
    kode: string
    nama: string
    jumlah?: Decimal | DecimalJsLike | number | string
  }

  export type danaUpdateManyMutationInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type danaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type dana_testCreateInput = {
    tanggal: Date | string
    nilai: Decimal | DecimalJsLike | number | string
    nilai2: Decimal | DecimalJsLike | number | string
  }

  export type dana_testUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    nilai: Decimal | DecimalJsLike | number | string
    nilai2: Decimal | DecimalJsLike | number | string
  }

  export type dana_testUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type dana_testUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type dana_testCreateManyInput = {
    id?: number
    tanggal: Date | string
    nilai: Decimal | DecimalJsLike | number | string
    nilai2: Decimal | DecimalJsLike | number | string
  }

  export type dana_testUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type dana_testUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nilai2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type divisiCreateInput = {
    jenis?: number
    kode: string
    nama: string
    created?: Date | string
    modified?: Date | string
  }

  export type divisiUncheckedCreateInput = {
    id?: number
    jenis?: number
    kode: string
    nama: string
    created?: Date | string
    modified?: Date | string
  }

  export type divisiUpdateInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type divisiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type divisiCreateManyInput = {
    id?: number
    jenis?: number
    kode: string
    nama: string
    created?: Date | string
    modified?: Date | string
  }

  export type divisiUpdateManyMutationInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type divisiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type estimasiCreateInput = {
    kode: string
    tanggal?: Date | string | null
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    keterangan: string
    admin?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type estimasiUncheckedCreateInput = {
    id?: number
    kode: string
    tanggal?: Date | string | null
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    keterangan: string
    admin?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type estimasiUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
    admin?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimasiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
    admin?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimasiCreateManyInput = {
    id?: number
    kode: string
    tanggal?: Date | string | null
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    keterangan: string
    admin?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type estimasiUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
    admin?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimasiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
    admin?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type estimasi_itemCreateInput = {
    tanggal?: Date | string | null
    id_estimasi?: number
    id_produk?: number
    id_supplier: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
  }

  export type estimasi_itemUncheckedCreateInput = {
    id?: number
    tanggal?: Date | string | null
    id_estimasi?: number
    id_produk?: number
    id_supplier: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
  }

  export type estimasi_itemUpdateInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_estimasi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type estimasi_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_estimasi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type estimasi_itemCreateManyInput = {
    id?: number
    tanggal?: Date | string | null
    id_estimasi?: number
    id_produk?: number
    id_supplier: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
  }

  export type estimasi_itemUpdateManyMutationInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_estimasi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type estimasi_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id_estimasi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
  }

  export type inventarisCreateInput = {
    jenis?: number
    nama: string
    tanggal?: Date | string | null
    nilai?: Decimal | DecimalJsLike | number | string
    persen?: number
    sisa_2023?: Decimal | DecimalJsLike | number | string
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type inventarisUncheckedCreateInput = {
    id?: number
    jenis?: number
    nama: string
    tanggal?: Date | string | null
    nilai?: Decimal | DecimalJsLike | number | string
    persen?: number
    sisa_2023?: Decimal | DecimalJsLike | number | string
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type inventarisUpdateInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    persen?: IntFieldUpdateOperationsInput | number
    sisa_2023?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventarisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    persen?: IntFieldUpdateOperationsInput | number
    sisa_2023?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventarisCreateManyInput = {
    id?: number
    jenis?: number
    nama: string
    tanggal?: Date | string | null
    nilai?: Decimal | DecimalJsLike | number | string
    persen?: number
    sisa_2023?: Decimal | DecimalJsLike | number | string
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type inventarisUpdateManyMutationInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    persen?: IntFieldUpdateOperationsInput | number
    sisa_2023?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type inventarisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    persen?: IntFieldUpdateOperationsInput | number
    sisa_2023?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pelunasan_pembelianCreateInput = {
    id_supplier?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    jumlah?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type pelunasan_pembelianUncheckedCreateInput = {
    id?: number
    id_supplier?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    jumlah?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type pelunasan_pembelianUpdateInput = {
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pelunasan_pembelianUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pelunasan_pembelianCreateManyInput = {
    id?: number
    id_supplier?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    jumlah?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type pelunasan_pembelianUpdateManyMutationInput = {
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pelunasan_pembelianUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pemusnahanCreateInput = {
    tanggal: Date | string
    jumlah?: Decimal | DecimalJsLike | number | string
    jumlah_fix?: Decimal | DecimalJsLike | number | string
    jangka: number
    keterangan: string
  }

  export type pemusnahanUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    jumlah?: Decimal | DecimalJsLike | number | string
    jumlah_fix?: Decimal | DecimalJsLike | number | string
    jangka: number
    keterangan: string
  }

  export type pemusnahanUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jangka?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pemusnahanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jangka?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pemusnahanCreateManyInput = {
    id?: number
    tanggal: Date | string
    jumlah?: Decimal | DecimalJsLike | number | string
    jumlah_fix?: Decimal | DecimalJsLike | number | string
    jangka: number
    keterangan: string
  }

  export type pemusnahanUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jangka?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type pemusnahanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah_fix?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jangka?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type produkCreateInput = {
    divisi?: number
    supplier?: number
    kode: string
    nama: string
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
    keterangan: string
    status?: number
    created?: Date | string
    modified?: Date | string
  }

  export type produkUncheckedCreateInput = {
    id?: number
    divisi?: number
    supplier?: number
    kode: string
    nama: string
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
    keterangan: string
    status?: number
    created?: Date | string
    modified?: Date | string
  }

  export type produkUpdateInput = {
    divisi?: IntFieldUpdateOperationsInput | number
    supplier?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type produkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    divisi?: IntFieldUpdateOperationsInput | number
    supplier?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type produkCreateManyInput = {
    id?: number
    divisi?: number
    supplier?: number
    kode: string
    nama: string
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
    keterangan: string
    status?: number
    created?: Date | string
    modified?: Date | string
  }

  export type produkUpdateManyMutationInput = {
    divisi?: IntFieldUpdateOperationsInput | number
    supplier?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type produkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    divisi?: IntFieldUpdateOperationsInput | number
    supplier?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type produk_hargaCreateInput = {
    id_produk: number
    tanggal?: Date | string | null
    harga_beli?: number
    harga_jual?: number
  }

  export type produk_hargaUncheckedCreateInput = {
    id?: number
    id_produk: number
    tanggal?: Date | string | null
    harga_beli?: number
    harga_jual?: number
  }

  export type produk_hargaUpdateInput = {
    id_produk?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harga_beli?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type produk_hargaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harga_beli?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type produk_hargaCreateManyInput = {
    id?: number
    id_produk: number
    tanggal?: Date | string | null
    harga_beli?: number
    harga_jual?: number
  }

  export type produk_hargaUpdateManyMutationInput = {
    id_produk?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harga_beli?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type produk_hargaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    harga_beli?: FloatFieldUpdateOperationsInput | number
    harga_jual?: FloatFieldUpdateOperationsInput | number
  }

  export type rapbCreateInput = {
    tahun: number
    hasil_usaha?: Decimal | DecimalJsLike | number | string
    jasa_bank?: Decimal | DecimalJsLike | number | string
    pendapatan_lain?: Decimal | DecimalJsLike | number | string
    beban_gaji?: Decimal | DecimalJsLike | number | string
    uang_makan?: Decimal | DecimalJsLike | number | string
    thr_karyawan?: Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: Decimal | DecimalJsLike | number | string
    beban_adm?: Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: Decimal | DecimalJsLike | number | string
    peny_inventaris?: Decimal | DecimalJsLike | number | string
    peny_gedung?: Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: Decimal | DecimalJsLike | number | string
    beban_pensiun?: Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: Decimal | DecimalJsLike | number | string
  }

  export type rapbUncheckedCreateInput = {
    no?: number
    tahun: number
    hasil_usaha?: Decimal | DecimalJsLike | number | string
    jasa_bank?: Decimal | DecimalJsLike | number | string
    pendapatan_lain?: Decimal | DecimalJsLike | number | string
    beban_gaji?: Decimal | DecimalJsLike | number | string
    uang_makan?: Decimal | DecimalJsLike | number | string
    thr_karyawan?: Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: Decimal | DecimalJsLike | number | string
    beban_adm?: Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: Decimal | DecimalJsLike | number | string
    peny_inventaris?: Decimal | DecimalJsLike | number | string
    peny_gedung?: Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: Decimal | DecimalJsLike | number | string
    beban_pensiun?: Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: Decimal | DecimalJsLike | number | string
  }

  export type rapbUpdateInput = {
    tahun?: IntFieldUpdateOperationsInput | number
    hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type rapbUncheckedUpdateInput = {
    no?: IntFieldUpdateOperationsInput | number
    tahun?: IntFieldUpdateOperationsInput | number
    hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type rapbCreateManyInput = {
    no?: number
    tahun: number
    hasil_usaha?: Decimal | DecimalJsLike | number | string
    jasa_bank?: Decimal | DecimalJsLike | number | string
    pendapatan_lain?: Decimal | DecimalJsLike | number | string
    beban_gaji?: Decimal | DecimalJsLike | number | string
    uang_makan?: Decimal | DecimalJsLike | number | string
    thr_karyawan?: Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: Decimal | DecimalJsLike | number | string
    beban_adm?: Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: Decimal | DecimalJsLike | number | string
    peny_inventaris?: Decimal | DecimalJsLike | number | string
    peny_gedung?: Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: Decimal | DecimalJsLike | number | string
    beban_pensiun?: Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: Decimal | DecimalJsLike | number | string
  }

  export type rapbUpdateManyMutationInput = {
    tahun?: IntFieldUpdateOperationsInput | number
    hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type rapbUncheckedUpdateManyInput = {
    no?: IntFieldUpdateOperationsInput | number
    tahun?: IntFieldUpdateOperationsInput | number
    hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jasa_bank?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pendapatan_lain?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_gaji?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    uang_makan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    thr_karyawan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_pangan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_adm?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_perlengkapan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tunjangan_kesehatan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    peny_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_inventaris?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pemeliharaan_gedung?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beban_pensiun?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kerugian_persediaan?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sisa_hasil_usaha?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type saldo_tokoCreateInput = {
    jenis?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    debet?: number
    kredit?: number
    saldo?: number
    keterangan: string
  }

  export type saldo_tokoUncheckedCreateInput = {
    id?: number
    jenis?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    debet?: number
    kredit?: number
    saldo?: number
    keterangan: string
  }

  export type saldo_tokoUpdateInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: FloatFieldUpdateOperationsInput | number
    kredit?: FloatFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type saldo_tokoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: FloatFieldUpdateOperationsInput | number
    kredit?: FloatFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type saldo_tokoCreateManyInput = {
    id?: number
    jenis?: number
    id_transaksi?: number
    tanggal?: Date | string | null
    debet?: number
    kredit?: number
    saldo?: number
    keterangan: string
  }

  export type saldo_tokoUpdateManyMutationInput = {
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: FloatFieldUpdateOperationsInput | number
    kredit?: FloatFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type saldo_tokoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: FloatFieldUpdateOperationsInput | number
    kredit?: FloatFieldUpdateOperationsInput | number
    saldo?: FloatFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type shu_mutasiCreateInput = {
    tahun_shu: number
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type shu_mutasiUncheckedCreateInput = {
    id?: number
    tahun_shu: number
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type shu_mutasiUpdateInput = {
    tahun_shu?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type shu_mutasiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahun_shu?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type shu_mutasiCreateManyInput = {
    id?: number
    tahun_shu: number
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type shu_mutasiUpdateManyMutationInput = {
    tahun_shu?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type shu_mutasiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tahun_shu?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type supplierCreateInput = {
    kode: string
    nama: string
    alamat: string
    pemilik: string
    kontak: string
    kredit?: Decimal | DecimalJsLike | number | string
    created?: Date | string
    modified?: Date | string
  }

  export type supplierUncheckedCreateInput = {
    id?: number
    kode: string
    nama: string
    alamat: string
    pemilik: string
    kontak: string
    kredit?: Decimal | DecimalJsLike | number | string
    created?: Date | string
    modified?: Date | string
  }

  export type supplierUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    pemilik?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    pemilik?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierCreateManyInput = {
    id?: number
    kode: string
    nama: string
    alamat: string
    pemilik: string
    kontak: string
    kredit?: Decimal | DecimalJsLike | number | string
    created?: Date | string
    modified?: Date | string
  }

  export type supplierUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    pemilik?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    alamat?: StringFieldUpdateOperationsInput | string
    pemilik?: StringFieldUpdateOperationsInput | string
    kontak?: StringFieldUpdateOperationsInput | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type supplier_kreditCreateInput = {
    id_supplier?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type supplier_kreditUncheckedCreateInput = {
    id?: number
    id_supplier?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type supplier_kreditUpdateInput = {
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type supplier_kreditUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type supplier_kreditCreateManyInput = {
    id?: number
    id_supplier?: number
    id_transaksi?: number
    ex_bukti?: string
    tanggal?: Date | string | null
    debet?: Decimal | DecimalJsLike | number | string
    kredit?: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type supplier_kreditUpdateManyMutationInput = {
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type supplier_kreditUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    id_supplier?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    ex_bukti?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type transaksiCreateInput = {
    kode: string
    kode_ex?: string
    kode_2?: string
    tanggal?: Date | string | null
    jenis?: number
    sumber?: number
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    diskon_item?: number
    diskon_persen?: number
    diskon_total?: Decimal | DecimalJsLike | number | string
    bayar?: Decimal | DecimalJsLike | number | string
    kredit?: number
    keterangan: string
    anggota?: number
    admin?: number
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type transaksiUncheckedCreateInput = {
    id?: number
    kode: string
    kode_ex?: string
    kode_2?: string
    tanggal?: Date | string | null
    jenis?: number
    sumber?: number
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    diskon_item?: number
    diskon_persen?: number
    diskon_total?: Decimal | DecimalJsLike | number | string
    bayar?: Decimal | DecimalJsLike | number | string
    kredit?: number
    keterangan: string
    anggota?: number
    admin?: number
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type transaksiUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    kode_ex?: StringFieldUpdateOperationsInput | string
    kode_2?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    sumber?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFieldUpdateOperationsInput | number
    diskon_persen?: IntFieldUpdateOperationsInput | number
    diskon_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    anggota?: IntFieldUpdateOperationsInput | number
    admin?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    kode_ex?: StringFieldUpdateOperationsInput | string
    kode_2?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    sumber?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFieldUpdateOperationsInput | number
    diskon_persen?: IntFieldUpdateOperationsInput | number
    diskon_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    anggota?: IntFieldUpdateOperationsInput | number
    admin?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateManyInput = {
    id?: number
    kode: string
    kode_ex?: string
    kode_2?: string
    tanggal?: Date | string | null
    jenis?: number
    sumber?: number
    jumlah?: number
    produk?: number
    total_beli?: Decimal | DecimalJsLike | number | string
    total_jual?: Decimal | DecimalJsLike | number | string
    diskon_item?: number
    diskon_persen?: number
    diskon_total?: Decimal | DecimalJsLike | number | string
    bayar?: Decimal | DecimalJsLike | number | string
    kredit?: number
    keterangan: string
    anggota?: number
    admin?: number
    status?: number
    created?: Date | string | null
    modified?: Date | string | null
  }

  export type transaksiUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
    kode_ex?: StringFieldUpdateOperationsInput | string
    kode_2?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    sumber?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFieldUpdateOperationsInput | number
    diskon_persen?: IntFieldUpdateOperationsInput | number
    diskon_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    anggota?: IntFieldUpdateOperationsInput | number
    admin?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    kode_ex?: StringFieldUpdateOperationsInput | string
    kode_2?: StringFieldUpdateOperationsInput | string
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    sumber?: IntFieldUpdateOperationsInput | number
    jumlah?: FloatFieldUpdateOperationsInput | number
    produk?: IntFieldUpdateOperationsInput | number
    total_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    diskon_item?: FloatFieldUpdateOperationsInput | number
    diskon_persen?: IntFieldUpdateOperationsInput | number
    diskon_total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bayar?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: IntFieldUpdateOperationsInput | number
    keterangan?: StringFieldUpdateOperationsInput | string
    anggota?: IntFieldUpdateOperationsInput | number
    admin?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    created?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksi_itemCreateInput = {
    tanggal?: Date | string | null
    jenis?: number
    id_transaksi?: number
    id_produk?: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
  }

  export type transaksi_itemUncheckedCreateInput = {
    id?: number
    tanggal?: Date | string | null
    jenis?: number
    id_transaksi?: number
    id_produk?: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
  }

  export type transaksi_itemUpdateInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_itemCreateManyInput = {
    id?: number
    tanggal?: Date | string | null
    jenis?: number
    id_transaksi?: number
    id_produk?: number
    harga_beli?: Decimal | DecimalJsLike | number | string
    harga_jual?: Decimal | DecimalJsLike | number | string
    jumlah?: number
    diskon?: number
  }

  export type transaksi_itemUpdateManyMutationInput = {
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jenis?: IntFieldUpdateOperationsInput | number
    id_transaksi?: IntFieldUpdateOperationsInput | number
    id_produk?: IntFieldUpdateOperationsInput | number
    harga_beli?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    harga_jual?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    jumlah?: FloatFieldUpdateOperationsInput | number
    diskon?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_jenisCreateInput = {
    nama: string
    tipe: number
    fix: number
  }

  export type transaksi_jenisUncheckedCreateInput = {
    id?: number
    nama: string
    tipe: number
    fix: number
  }

  export type transaksi_jenisUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: IntFieldUpdateOperationsInput | number
    fix?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_jenisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: IntFieldUpdateOperationsInput | number
    fix?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_jenisCreateManyInput = {
    id?: number
    nama: string
    tipe: number
    fix: number
  }

  export type transaksi_jenisUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: IntFieldUpdateOperationsInput | number
    fix?: IntFieldUpdateOperationsInput | number
  }

  export type transaksi_jenisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    tipe?: IntFieldUpdateOperationsInput | number
    fix?: IntFieldUpdateOperationsInput | number
  }

  export type tujuanCreateInput = {
    nama: string
  }

  export type tujuanUncheckedCreateInput = {
    id?: number
    nama: string
  }

  export type tujuanUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type tujuanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type tujuanCreateManyInput = {
    id?: number
    nama: string
  }

  export type tujuanUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type tujuanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
  }

  export type tutup_kasirCreateInput = {
    tanggal: Date | string
    shift: number
    kasir: number
    tunai: Decimal | DecimalJsLike | number | string
    bon: Decimal | DecimalJsLike | number | string
    struk: Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    shift: number
    kasir: number
    tunai: Decimal | DecimalJsLike | number | string
    bon: Decimal | DecimalJsLike | number | string
    struk: Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: IntFieldUpdateOperationsInput | number
    kasir?: IntFieldUpdateOperationsInput | number
    tunai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    struk?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: IntFieldUpdateOperationsInput | number
    kasir?: IntFieldUpdateOperationsInput | number
    tunai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    struk?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirCreateManyInput = {
    id?: number
    tanggal: Date | string
    shift: number
    kasir: number
    tunai: Decimal | DecimalJsLike | number | string
    bon: Decimal | DecimalJsLike | number | string
    struk: Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: IntFieldUpdateOperationsInput | number
    kasir?: IntFieldUpdateOperationsInput | number
    tunai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    struk?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type tutup_kasirUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    shift?: IntFieldUpdateOperationsInput | number
    kasir?: IntFieldUpdateOperationsInput | number
    tunai?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bon?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    struk?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type utang_spCreateInput = {
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type utang_spUncheckedCreateInput = {
    id?: number
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type utang_spUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type utang_spUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type utang_spCreateManyInput = {
    id?: number
    tanggal: Date | string
    debet: Decimal | DecimalJsLike | number | string
    kredit: Decimal | DecimalJsLike | number | string
    keterangan: string
  }

  export type utang_spUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type utang_spUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    debet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kredit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    keterangan?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    bagian?: SortOrder
    username?: SortOrder
    password?: SortOrder
    nama?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
    bagian?: SortOrder
    level?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    bagian?: SortOrder
    username?: SortOrder
    password?: SortOrder
    nama?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    bagian?: SortOrder
    username?: SortOrder
    password?: SortOrder
    nama?: SortOrder
    type?: SortOrder
    level?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
    bagian?: SortOrder
    level?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type anggotaCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type anggotaAvgOrderByAggregateInput = {
    id?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
  }

  export type anggotaMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type anggotaMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type anggotaSumOrderByAggregateInput = {
    id?: SortOrder
    kredit_limit?: SortOrder
    kredit_pinjaman?: SortOrder
    status?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type anggota_kreditCountOrderByAggregateInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type anggota_kreditAvgOrderByAggregateInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type anggota_kreditMaxOrderByAggregateInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type anggota_kreditMinOrderByAggregateInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type anggota_kreditSumOrderByAggregateInput = {
    id?: SortOrder
    id_anggota?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type bagianCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bagianAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bagianMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bagianMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bagianSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bankCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    saldo?: SortOrder
  }

  export type bankAvgOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
  }

  export type bankMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    saldo?: SortOrder
  }

  export type bankMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    saldo?: SortOrder
  }

  export type bankSumOrderByAggregateInput = {
    id?: SortOrder
    saldo?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type bank_mutasiCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
    keterangan?: SortOrder
  }

  export type bank_mutasiAvgOrderByAggregateInput = {
    id?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
  }

  export type bank_mutasiMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
    keterangan?: SortOrder
  }

  export type bank_mutasiMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
    keterangan?: SortOrder
  }

  export type bank_mutasiSumOrderByAggregateInput = {
    id?: SortOrder
    id_bank?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    debet2?: SortOrder
    kredit2?: SortOrder
    adm?: SortOrder
    pajak?: SortOrder
    jasa?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type bayarCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bayarAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bayarMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bayarMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type bayarSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type beban_operasionalCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    keterangan?: SortOrder
    jumlah?: SortOrder
  }

  export type beban_operasionalAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
  }

  export type beban_operasionalMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    keterangan?: SortOrder
    jumlah?: SortOrder
  }

  export type beban_operasionalMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    keterangan?: SortOrder
    jumlah?: SortOrder
  }

  export type beban_operasionalSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type cash_in_outCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
    keterangan?: SortOrder
  }

  export type cash_in_outAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
  }

  export type cash_in_outMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
    keterangan?: SortOrder
  }

  export type cash_in_outMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
    keterangan?: SortOrder
  }

  export type cash_in_outSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    detail?: SortOrder
    input?: SortOrder
    output?: SortOrder
  }

  export type cash_jenisCountOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    nama?: SortOrder
    nilai?: SortOrder
  }

  export type cash_jenisAvgOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    nilai?: SortOrder
  }

  export type cash_jenisMaxOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    nama?: SortOrder
    nilai?: SortOrder
  }

  export type cash_jenisMinOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    nama?: SortOrder
    nilai?: SortOrder
  }

  export type cash_jenisSumOrderByAggregateInput = {
    id?: SortOrder
    parent?: SortOrder
    nilai?: SortOrder
  }

  export type configCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
    modified?: SortOrder
  }

  export type configAvgOrderByAggregateInput = {
    id?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
  }

  export type configMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
    modified?: SortOrder
  }

  export type configMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    telp?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
    modified?: SortOrder
  }

  export type configSumOrderByAggregateInput = {
    id?: SortOrder
    bulat?: SortOrder
    versi?: SortOrder
    shortcut?: SortOrder
  }

  export type danaCountOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    jumlah?: SortOrder
  }

  export type danaAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    jumlah?: SortOrder
  }

  export type danaMaxOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    jumlah?: SortOrder
  }

  export type danaMinOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    jumlah?: SortOrder
  }

  export type danaSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    jumlah?: SortOrder
  }

  export type dana_testCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type dana_testAvgOrderByAggregateInput = {
    id?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type dana_testMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type dana_testMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type dana_testSumOrderByAggregateInput = {
    id?: SortOrder
    nilai?: SortOrder
    nilai2?: SortOrder
  }

  export type divisiCountOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type divisiAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
  }

  export type divisiMaxOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type divisiMinOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type divisiSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
  }

  export type estimasiCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    keterangan?: SortOrder
    admin?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type estimasiAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    admin?: SortOrder
  }

  export type estimasiMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    keterangan?: SortOrder
    admin?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type estimasiMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    keterangan?: SortOrder
    admin?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type estimasiSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    admin?: SortOrder
  }

  export type estimasi_itemCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type estimasi_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type estimasi_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type estimasi_itemMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type estimasi_itemSumOrderByAggregateInput = {
    id?: SortOrder
    id_estimasi?: SortOrder
    id_produk?: SortOrder
    id_supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
  }

  export type inventarisCountOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    nama?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type inventarisAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
  }

  export type inventarisMaxOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    nama?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type inventarisMinOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    nama?: SortOrder
    tanggal?: SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type inventarisSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    nilai?: SortOrder
    persen?: SortOrder
    sisa_2023?: SortOrder
  }

  export type pelunasan_pembelianCountOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    keterangan?: SortOrder
  }

  export type pelunasan_pembelianAvgOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    jumlah?: SortOrder
  }

  export type pelunasan_pembelianMaxOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    keterangan?: SortOrder
  }

  export type pelunasan_pembelianMinOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    keterangan?: SortOrder
  }

  export type pelunasan_pembelianSumOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    jumlah?: SortOrder
  }

  export type pemusnahanCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
    keterangan?: SortOrder
  }

  export type pemusnahanAvgOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
  }

  export type pemusnahanMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
    keterangan?: SortOrder
  }

  export type pemusnahanMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
    keterangan?: SortOrder
  }

  export type pemusnahanSumOrderByAggregateInput = {
    id?: SortOrder
    jumlah?: SortOrder
    jumlah_fix?: SortOrder
    jangka?: SortOrder
  }

  export type produkCountOrderByAggregateInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    keterangan?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type produkAvgOrderByAggregateInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    status?: SortOrder
  }

  export type produkMaxOrderByAggregateInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    keterangan?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type produkMinOrderByAggregateInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    keterangan?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type produkSumOrderByAggregateInput = {
    id?: SortOrder
    divisi?: SortOrder
    supplier?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
    status?: SortOrder
  }

  export type produk_hargaCountOrderByAggregateInput = {
    id?: SortOrder
    id_produk?: SortOrder
    tanggal?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type produk_hargaAvgOrderByAggregateInput = {
    id?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type produk_hargaMaxOrderByAggregateInput = {
    id?: SortOrder
    id_produk?: SortOrder
    tanggal?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type produk_hargaMinOrderByAggregateInput = {
    id?: SortOrder
    id_produk?: SortOrder
    tanggal?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type produk_hargaSumOrderByAggregateInput = {
    id?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
  }

  export type rapbCountOrderByAggregateInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type rapbAvgOrderByAggregateInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type rapbMaxOrderByAggregateInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type rapbMinOrderByAggregateInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type rapbSumOrderByAggregateInput = {
    no?: SortOrder
    tahun?: SortOrder
    hasil_usaha?: SortOrder
    jasa_bank?: SortOrder
    pendapatan_lain?: SortOrder
    beban_gaji?: SortOrder
    uang_makan?: SortOrder
    thr_karyawan?: SortOrder
    tunjangan_pangan?: SortOrder
    beban_adm?: SortOrder
    beban_perlengkapan?: SortOrder
    tunjangan_kesehatan?: SortOrder
    peny_inventaris?: SortOrder
    peny_gedung?: SortOrder
    pemeliharaan_inventaris?: SortOrder
    pemeliharaan_gedung?: SortOrder
    beban_pensiun?: SortOrder
    kerugian_persediaan?: SortOrder
    sisa_hasil_usaha?: SortOrder
  }

  export type saldo_tokoCountOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
    keterangan?: SortOrder
  }

  export type saldo_tokoAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
  }

  export type saldo_tokoMaxOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
    keterangan?: SortOrder
  }

  export type saldo_tokoMinOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
    keterangan?: SortOrder
  }

  export type saldo_tokoSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    saldo?: SortOrder
  }

  export type shu_mutasiCountOrderByAggregateInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type shu_mutasiAvgOrderByAggregateInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type shu_mutasiMaxOrderByAggregateInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type shu_mutasiMinOrderByAggregateInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type shu_mutasiSumOrderByAggregateInput = {
    id?: SortOrder
    tahun_shu?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type supplierCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    pemilik?: SortOrder
    kontak?: SortOrder
    kredit?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type supplierAvgOrderByAggregateInput = {
    id?: SortOrder
    kredit?: SortOrder
  }

  export type supplierMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    pemilik?: SortOrder
    kontak?: SortOrder
    kredit?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type supplierMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    pemilik?: SortOrder
    kontak?: SortOrder
    kredit?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type supplierSumOrderByAggregateInput = {
    id?: SortOrder
    kredit?: SortOrder
  }

  export type supplier_kreditCountOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type supplier_kreditAvgOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type supplier_kreditMaxOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type supplier_kreditMinOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    ex_bukti?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type supplier_kreditSumOrderByAggregateInput = {
    id?: SortOrder
    id_supplier?: SortOrder
    id_transaksi?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type transaksiCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    kode_ex?: SortOrder
    kode_2?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type transaksiAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
  }

  export type transaksiMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    kode_ex?: SortOrder
    kode_2?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type transaksiMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    kode_ex?: SortOrder
    kode_2?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
    created?: SortOrder
    modified?: SortOrder
  }

  export type transaksiSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    sumber?: SortOrder
    jumlah?: SortOrder
    produk?: SortOrder
    total_beli?: SortOrder
    total_jual?: SortOrder
    diskon_item?: SortOrder
    diskon_persen?: SortOrder
    diskon_total?: SortOrder
    bayar?: SortOrder
    kredit?: SortOrder
    anggota?: SortOrder
    admin?: SortOrder
    status?: SortOrder
  }

  export type transaksi_itemCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_itemMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_itemSumOrderByAggregateInput = {
    id?: SortOrder
    jenis?: SortOrder
    id_transaksi?: SortOrder
    id_produk?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    jumlah?: SortOrder
    diskon?: SortOrder
  }

  export type transaksi_jenisCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type transaksi_jenisAvgOrderByAggregateInput = {
    id?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type transaksi_jenisMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type transaksi_jenisMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type transaksi_jenisSumOrderByAggregateInput = {
    id?: SortOrder
    tipe?: SortOrder
    fix?: SortOrder
  }

  export type tujuanCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type tujuanAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tujuanMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type tujuanMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
  }

  export type tujuanSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tutup_kasirCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type tutup_kasirAvgOrderByAggregateInput = {
    id?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type tutup_kasirMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type tutup_kasirMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type tutup_kasirSumOrderByAggregateInput = {
    id?: SortOrder
    shift?: SortOrder
    kasir?: SortOrder
    tunai?: SortOrder
    bon?: SortOrder
    struk?: SortOrder
  }

  export type utang_spCountOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type utang_spAvgOrderByAggregateInput = {
    id?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type utang_spMaxOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type utang_spMinOrderByAggregateInput = {
    id?: SortOrder
    tanggal?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
    keterangan?: SortOrder
  }

  export type utang_spSumOrderByAggregateInput = {
    id?: SortOrder
    debet?: SortOrder
    kredit?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use adminDefaultArgs instead
     */
    export type adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anggotaDefaultArgs instead
     */
    export type anggotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anggotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anggota_kreditDefaultArgs instead
     */
    export type anggota_kreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anggota_kreditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bagianDefaultArgs instead
     */
    export type bagianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bagianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bankDefaultArgs instead
     */
    export type bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bankDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bank_mutasiDefaultArgs instead
     */
    export type bank_mutasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bank_mutasiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bayarDefaultArgs instead
     */
    export type bayarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bayarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use beban_operasionalDefaultArgs instead
     */
    export type beban_operasionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = beban_operasionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cash_in_outDefaultArgs instead
     */
    export type cash_in_outArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cash_in_outDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cash_jenisDefaultArgs instead
     */
    export type cash_jenisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cash_jenisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use configDefaultArgs instead
     */
    export type configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = configDefaultArgs<ExtArgs>
    /**
     * @deprecated Use danaDefaultArgs instead
     */
    export type danaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = danaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dana_testDefaultArgs instead
     */
    export type dana_testArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dana_testDefaultArgs<ExtArgs>
    /**
     * @deprecated Use divisiDefaultArgs instead
     */
    export type divisiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = divisiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use estimasiDefaultArgs instead
     */
    export type estimasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = estimasiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use estimasi_itemDefaultArgs instead
     */
    export type estimasi_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = estimasi_itemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventarisDefaultArgs instead
     */
    export type inventarisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventarisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pelunasan_pembelianDefaultArgs instead
     */
    export type pelunasan_pembelianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pelunasan_pembelianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pemusnahanDefaultArgs instead
     */
    export type pemusnahanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pemusnahanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use produkDefaultArgs instead
     */
    export type produkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = produkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use produk_hargaDefaultArgs instead
     */
    export type produk_hargaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = produk_hargaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rapbDefaultArgs instead
     */
    export type rapbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rapbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use saldo_tokoDefaultArgs instead
     */
    export type saldo_tokoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = saldo_tokoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use shu_mutasiDefaultArgs instead
     */
    export type shu_mutasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = shu_mutasiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplierDefaultArgs instead
     */
    export type supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supplier_kreditDefaultArgs instead
     */
    export type supplier_kreditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supplier_kreditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transaksiDefaultArgs instead
     */
    export type transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transaksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transaksi_itemDefaultArgs instead
     */
    export type transaksi_itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transaksi_itemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transaksi_jenisDefaultArgs instead
     */
    export type transaksi_jenisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transaksi_jenisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tujuanDefaultArgs instead
     */
    export type tujuanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tujuanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tutup_kasirDefaultArgs instead
     */
    export type tutup_kasirArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tutup_kasirDefaultArgs<ExtArgs>
    /**
     * @deprecated Use utang_spDefaultArgs instead
     */
    export type utang_spArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = utang_spDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}